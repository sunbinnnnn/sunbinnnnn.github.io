<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="NeilSun&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="https://avatars.githubusercontent.com/u/18653098?s=400&amp;u=8b3b494cfa224eb388a933aa9af8ac5e5b65b3f8&amp;v=4"/>
  
  <title>
    
      关于CSI，看这一篇就够了 | Neil&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Neil's blog" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Neil's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>关于CSI，看这一篇就够了</h2>
  <p class="post-date">2021-04-20</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>在了解k8s的CSI plugin编写前，我们需要先了解下有关K8S的持久化存储机制。</p>
<span id="more"></span>



<h2 id="理解k8s持久化存储"><a href="#理解k8s持久化存储" class="headerlink" title="理解k8s持久化存储"></a>理解k8s持久化存储</h2><p>在k8s中，持久化存储采用PV和PVC进行绑定的的方式进行管理。</p>
<p><em>PV（PersistentVolume）：</em>存储卷对象映射，一般由管理员手动创建或通过存储插件（External Provisioner）创建。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv0003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span> <span class="comment"># K8S支持两种volumeMode：Filesystem和Block</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 三种策略可选：Retain\Recycle\Delete，只有NFS和HostPath支持Recycle（纯调用rm -rf命令进行文件系统级别删除）</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">slow</span></span><br><span class="line">  <span class="attr">mountOptions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>



<p><em>PVC（PersistentVolumeClaim）</em>：存储卷声明，一般由开发人员定义，对于支持Dynamic Provisioning的存储类型，通过对PVC的声明（可以在pod中完成），可以让PersistentVolumeController找到一块合适的PV与PVC进行bound操作。示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">fast</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure>



<p>这种绑定操作可以是<strong>静态的（Static Provisioning）</strong>，也可以是<strong>动态的（Dynamic Provisioning）</strong></p>
<p>首先说静态，通过静态方式进行时，由管理员创建PV，通过PersistentVolumeController，k8s可以完成PV和PVC的绑定，PersistentVolumeController(<code>pkg/controller/volume/persistentvolume/pv_controller.go</code>)存在一个控制循环，不断遍历所有可用状态的PV，尝试与PVC进行绑定（Bound）操作，绑定成功后，则为声明该PVC的Pod提供存储服务。</p>
<h3 id="PV和PVC绑定调度流程"><a href="#PV和PVC绑定调度流程" class="headerlink" title="PV和PVC绑定调度流程"></a>PV和PVC绑定调度流程</h3><p>当PVC被声明出来时（单独声明 or statefulSet），会被cache.Controller watch到，并开始执行<code>syncClaim</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *PersistentVolumeController)</span> <span class="title">syncClaim</span><span class="params">(claim *v1.PersistentVolumeClaim)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;synchronizing PersistentVolumeClaim[%s]: %s&quot;</span>, claimToClaimKey(claim), getClaimStatusForLogging(claim))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set correct &quot;migrated-to&quot; annotations on PVC and update in API server if</span></span><br><span class="line">	<span class="comment">// necessary</span></span><br><span class="line">	newClaim, err := ctrl.updateClaimMigrationAnnotations(claim)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Nothing was saved; we will fall back into the same</span></span><br><span class="line">		<span class="comment">// condition in the next call to this method</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	claim = newClaim</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !metav1.HasAnnotation(claim.ObjectMeta, pvutil.AnnBindCompleted) &#123;</span><br><span class="line">		<span class="keyword">return</span> ctrl.syncUnboundClaim(claim)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ctrl.syncBoundClaim(claim)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>pv.kubernetes.io/bind-completed</code> annotation来判断pvc是否已经完成bound操作，如果该PVC未进行bound操作，则调用<code>syncUnboundClaim</code>进行bound操作。</p>
<p>在进行<code>syncUnboundClaim</code>前，首先会确认PVC是否定义了<strong>延迟绑定</strong>策略：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsDelayBindingMode checks if claim is in delay binding mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsDelayBindingMode</span><span class="params">(claim *v1.PersistentVolumeClaim, classLister storagelisters.StorageClassLister)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	className := storagehelpers.GetPersistentVolumeClaimClass(claim)</span><br><span class="line">	<span class="keyword">if</span> className == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class, err := classLister.Get(className)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> class.VolumeBindingMode == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;VolumeBindingMode not set for StorageClass %q&quot;</span>, className)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *class.VolumeBindingMode == storage.VolumeBindingWaitForFirstConsumer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟绑定主要用在Local PersistentVolume的情况下，当采用本地卷作为持久化卷时，如果PVC和PV即时绑定，则可能在pod启动的节点上找不到PV，mount过程会失败，而延迟绑定则将PVC和PV的绑定延后到Pod 调度器中，从而使Volume卷可以被正常挂载到Pod上。</p>
<p>之后执行PV查找过程，首先从<code>pvIndex</code>中按照<code>AccessModes</code>找到所有符合的PV：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allPossibleModes := pvIndex.allPossibleMatchingAccessModes(claim.Spec.AccessModes)</span><br></pre></td></tr></table></figure>

<p>例如PVC请求的PV的AccessMode是<code>ReadWriteOnce</code>，则包含<code>ReadWriteOnce</code>的PV都会被检索出。</p>
<p>之后通过调用<code>FindMatchingVolume</code>方法找到最合适的PV。</p>
<p>这里的逻辑是通过遍历符合AccessMode的所有PV，首先判定PV是否已经被其他PVC预绑定（pre-bound）或已经被绑定：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> volume.Spec.ClaimRef != <span class="literal">nil</span> &amp;&amp; !IsVolumeBoundToClaim(volume, claim) &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsVolumeBoundToClaim</span><span class="params">(volume *v1.PersistentVolume, claim *v1.PersistentVolumeClaim)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> volume.Spec.ClaimRef == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> claim.Name != volume.Spec.ClaimRef.Name || claim.Namespace != volume.Spec.ClaimRef.Namespace &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> volume.Spec.ClaimRef.UID != <span class="string">&quot;&quot;</span> &amp;&amp; claim.UID != volume.Spec.ClaimRef.UID &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当开启了 延迟绑定后，PV将会被直接跳过，交给Pod调度器进行调度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &amp;&amp; delayBinding &#123;</span><br><span class="line">    <span class="comment">// PV controller does not bind this claim.</span></span><br><span class="line">    <span class="comment">// Scheduler will handle binding unbound volumes</span></span><br><span class="line">    <span class="comment">// Scheduler path will have node != nil</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后会检查PV的状态是否处于 Available 、PVC中定义的labelSelector是否符合要求以及StorageClass是否符合（默认都为空，则为符合），不符合则跳过：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> volume.Status.Phase != v1.VolumeAvailable &#123;</span><br><span class="line">    <span class="comment">// We ignore volumes in non-available phase, because volumes that</span></span><br><span class="line">    <span class="comment">// satisfies matching criteria will be updated to available, binding</span></span><br><span class="line">    <span class="comment">// them now has high chance of encountering unnecessary failures</span></span><br><span class="line">    <span class="comment">// due to API conflicts.</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> selector != <span class="literal">nil</span> &amp;&amp; !selector.Matches(labels.Set(volume.Labels)) &#123;</span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> storagehelpers.GetPersistentVolumeClass(volume) != requestedClass &#123;</span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上都完毕后，从所有的符合条件的PV中找到符合PVC requestSize且最小的一个PV：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> smallestVolume == <span class="literal">nil</span> || smallestVolumeQty.Cmp(volumeQty) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    smallestVolume = volume</span><br><span class="line">    smallestVolumeQty = volumeQty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> smallestVolume != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a matching volume</span></span><br><span class="line">    <span class="keyword">return</span> smallestVolume, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是PV和PVC的调度绑定流程。</p>
<h3 id="Dynamic-Provisioning"><a href="#Dynamic-Provisioning" class="headerlink" title="Dynamic Provisioning"></a>Dynamic Provisioning</h3><p>这个过程在PersistentVolumeController中完成，而当Pod在实际使用Volume前，需要通过Attach以及Mount流程后，才能真正进行使用。</p>
<p>而实际的应用场景则是，在环境中可能没有提前创建好可供“bound”的PV，这时候<strong>Dynamic Provisioning</strong>就派上用场了。</p>
<p>使用Dynamic Provisioning方式很简单，通过定义StorageClass就可以完成。</p>
<p>以Rook-Ceph的RBD服务为例，可以创建如下格式的StorageClass，以提供块存储服务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">provisioner:</span> <span class="string">ceph.rook.io/block</span></span><br><span class="line">  <span class="attr">parameters:</span></span><br><span class="line">    <span class="attr">pool:</span> <span class="string">replicapool</span></span><br><span class="line">    <span class="attr">clusterNamespace:</span> <span class="string">rook-ceph</span></span><br></pre></td></tr></table></figure>

<p>通过在PVC中声明storageClassName字段，就可以进行动态使用了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure>

<p>在PVController watch到动态PVC被声明后，首先会寻找该PVC对应的plugin和storageClass:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin, storageClass, err := ctrl.findProvisionablePlugin(claim)</span><br></pre></td></tr></table></figure>

<p>这个过程会通过PersistentVolumeController的findProvisionablePlugin方法来进行寻找in-tree plugin，而find过程的关键在于通过PVC声明的storageClassName寻找对应的in-tree Plugin：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a plugin for the class</span></span><br><span class="line"><span class="keyword">if</span> ctrl.csiMigratedPluginManager.IsMigrationEnabledForPlugin(class.Provisioner) &#123;</span><br><span class="line">    <span class="comment">// CSI migration scenario - do not depend on in-tree plugin</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, class, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">plugin, err := ctrl.volumePluginMgr.FindProvisionablePluginByName(class.Provisioner)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(class.Provisioner, <span class="string">&quot;kubernetes.io/&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// External provisioner is requested, do not report error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, class, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, class, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> plugin, class, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>在1.14之后，PVController会先判断是否属于in-tree plugin到CSI的迁移(migration)场景，如果属于，则会将in-tree的plugin迁移到CSI，关于migration的产生背景，可以看下这篇介绍：<a target="_blank" rel="noopener" href="https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/">https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/</a></p>
<p>简单来说，为了支持Plugin机制的广泛使用，K8S社区越来越倾向于减少in-tree的代码，而通过Plugin的机制来进行扩展，原先in-tree的Plugin也被通过migration的机制，逐渐往CSI上迁，从中也能看出K8S社区对扩展性的考量，未来K8S极有可能成为Plugin的“媒介”系统（目前还未采用Plugin机制的，仅有kube-scheduler，而随着K8S社区的不断演进，kube-scheduler的默认调度器也会和CSI、CNI一样，支持自定义调度插件）。</p>
<p>继续往下分析，PVController会通过scheduleOperation来传入PV的Operation方法作为闭包，scheduleOperation的作用主要是通过grm（goroutinemap）的读写锁来判定，是否有Operation已经在运行中，运行中的作业会被预先加入goroutinemap中，用以判断。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutinemap</span></span><br><span class="line"><span class="keyword">type</span> goRoutineMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	operations                <span class="keyword">map</span>[<span class="keyword">string</span>]operation</span><br><span class="line">	exponentialBackOffOnError <span class="keyword">bool</span></span><br><span class="line">	cond                      *sync.Cond</span><br><span class="line">	lock                      sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Attach-amp-Mount"><a href="#Attach-amp-Mount" class="headerlink" title="Attach &amp; Mount"></a>Attach &amp; Mount</h3><p>在实际挂载时，通过ADController调用CSI的Attach操作，并在kubelet中调用Mount操作，完成存储卷和Pod的挂载过程。</p>
<p>在ADController中，首先会构建出PV对应的VolumeSpec，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSpecFromPersistentVolume creates an Spec from an v1.PersistentVolume</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSpecFromPersistentVolume</span><span class="params">(pv *v1.PersistentVolume, readOnly <span class="keyword">bool</span>)</span> *<span class="title">Spec</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Spec&#123;</span><br><span class="line">		PersistentVolume: pv,</span><br><span class="line">		ReadOnly:         readOnly,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后根据VolumeSpec寻找到plugin， 通过调用operation_executor，完成Attach操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oe *operationExecutor)</span> <span class="title">AttachVolume</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	volumeToAttach VolumeToAttach,</span></span></span><br><span class="line"><span class="function"><span class="params">	actualStateOfWorld ActualStateOfWorldAttacherUpdater)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	generatedOperations :=</span><br><span class="line">		oe.operationGenerator.GenerateAttachVolumeFunc(volumeToAttach, actualStateOfWorld)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> util.IsMultiAttachAllowed(volumeToAttach.VolumeSpec) &#123;</span><br><span class="line">		<span class="keyword">return</span> oe.pendingOperations.Run(</span><br><span class="line">			volumeToAttach.VolumeName, <span class="string">&quot;&quot;</span> <span class="comment">/* podName */</span>, volumeToAttach.NodeName, generatedOperations)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> oe.pendingOperations.Run(</span><br><span class="line">		volumeToAttach.VolumeName, <span class="string">&quot;&quot;</span> <span class="comment">/* podName */</span>, <span class="string">&quot;&quot;</span> <span class="comment">/* nodeName */</span>, generatedOperations)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Mount操作则在kubelet中进行，在kubelet中会生成VolumeManager对象。</p>
<p>关于VolumeManager的处理逻辑会在kubelet的详细介绍文章中介绍。</p>
<h2 id="编写CSI"><a href="#编写CSI" class="headerlink" title="编写CSI"></a>编写CSI</h2><p>在理解了K8S处理持久化卷的机制后，我们就可以来尝试编写CSI了。</p>
<p>首先CSI不是in-tree模式的存储插件，一般通过daemonSet的方式部署在节点上。</p>
<p>CSI插件体系的设计思想，<strong>就是把 Provision 阶段，以及 Kubernetes 里的一部分存储管理功能，从主干代码里剥离出来，做成了几个单独的组件。</strong></p>
<p>CSI设计思想示意图：</p>
<img src="/images/d4bdc7035f1286e7a423da851eee89ad.png" alt="img" style="zoom: 67%;" />

<p>可以看出，CSI可以大体分为两部分（上图External Components和Custum Components部分），其中左半部分是k8S所提供的控制面服务，而右侧则是CSI开发者需要关注的部分。</p>
<p>而再往左侧，K8S原生的控制面服务，则是对CSI组件的请求调用，我们暂且忽略。</p>
<p>先看下左半部分External Components。</p>
<p>External Components同样也是被K8S社区所维护的项目，存放与K8S的CSI SIG中。</p>
<h3 id="Driver-Registrar"><a href="#Driver-Registrar" class="headerlink" title="Driver Registrar"></a><strong>Driver Registrar</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><strong>Driver Registerar 组件通过请求CSI插件的Identity服务，来获取插件信息，将插件注册到kubelet中。</strong>在当前的K8S版本中（CSI spec 0.3后），Driver Registrar已不再维护，取而代之的是<a target="_blank" rel="noopener" href="https://github.com/kubernetes-csi/cluster-driver-registrar">cluster-driver-registrar</a>和<a target="_blank" rel="noopener" href="https://github.com/kubernetes-csi/node-driver-registrar">node-driver-registrar</a>。而在K8S 1.13版本以后，cluster-driver-registrar也进入deprecated，在1.16版本以后被正式弃用。<strong>而<a target="_blank" rel="noopener" href="https://github.com/kubernetes-csi/node-driver-registrar">node-driver-registrar</a>是目前仍在维护的driver registar。而cluster-deriver-registar需要通过创建 <a target="_blank" rel="noopener" href="https://kubernetes-csi.github.io/docs/csi-driver-object.html">CSIDriver Object </a>的方式来实现。</strong></p>
<p>node-driver-registrar的本质是sidecar容器，一般与CSI的daemonSet容器部署在一起。</p>
<p>部署yaml example：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">csi-driver-registrar</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--csi-address=/csi/csi.sock&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--kubelet-registration-path=/var/lib/kubelet/plugins/&lt;drivername.example.com&gt;/csi.sock&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--health-port=9809&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">plugin-dir</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/csi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">registration-dir</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/registration</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9809</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">healthz</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">healthz</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">registration-dir</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/var/lib/kubelet/plugins_registry/</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">plugin-dir</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/var/lib/kubelet/plugins/&lt;drivername.example.com&gt;/</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br></pre></td></tr></table></figure>



<h4 id="核心逻辑分析"><a href="#核心逻辑分析" class="headerlink" title="核心逻辑分析"></a><strong>核心逻辑分析</strong></h4><h3 id="External-Provisioner"><a href="#External-Provisioner" class="headerlink" title="External Provisioner"></a><strong>External Provisioner</strong></h3><h3 id="External-Attacher"><a href="#External-Attacher" class="headerlink" title="**External Attacher **"></a>**External Attacher **</h3></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#k8s" >
    <span class="tag-code">k8s</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/04/09/Cloud-Devops/">
        <span class="nav-arrow">← </span>
        
          Cloud Devops
        
      </a>
    
    
      <a class="nav-right" href="/2021/06/15/garbage-collector-controller/">
        
          garbage-collector-controller
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%90%86%E8%A7%A3k8s%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8"><span class="toc-nav-text">理解k8s持久化存储</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#PV%E5%92%8CPVC%E7%BB%91%E5%AE%9A%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">PV和PVC绑定调度流程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Dynamic-Provisioning"><span class="toc-nav-text">Dynamic Provisioning</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Attach-amp-Mount"><span class="toc-nav-text">Attach &amp; Mount</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%BC%96%E5%86%99CSI"><span class="toc-nav-text">编写CSI</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Driver-Registrar"><span class="toc-nav-text">Driver Registrar</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-nav-text">概述</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90"><span class="toc-nav-text">核心逻辑分析</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#External-Provisioner"><span class="toc-nav-text">External Provisioner</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#External-Attacher"><span class="toc-nav-text">**External Attacher **</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2021/04/20/关于CSI，看这一篇就够了/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>