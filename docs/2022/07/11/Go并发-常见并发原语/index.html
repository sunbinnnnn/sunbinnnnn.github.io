<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="NeilSun&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="https://avatars.githubusercontent.com/u/18653098?s=400&amp;u=8b3b494cfa224eb388a933aa9af8ac5e5b65b3f8&amp;v=4"/>
  
  <title>
    
      Go并发-常见并发原语 | Neil&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Neil's blog" type="application/atom+xml">
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Neil's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Go并发-常见并发原语</h2>
  <p class="post-date">2022-07-11</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>接上文：<a target="_blank" rel="noopener" href="https://blog.neilcloud.net/2022/05/12/Go%E5%B9%B6%E5%8F%91/"><strong>Go并发 - 并发原语Mutex、RWMutex</strong></a></p>
<span id="more"></span>

<p>上文提到了关于Golang的两个基础并发原语Mutex、RWMutex，接下来我们来介绍下Golang中常见的几个并发原语和并发场景：</p>
<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a><strong>WaitGroup</strong></h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Add，用来设置 WaitGroup 的计数值。</li>
<li>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。</li>
<li>Wait，调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li>
</ul>
<p><strong>example:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的计数器</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对计数值加一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前的计数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sleep 1秒，然后计数值加1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c *Counter, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    c.Incr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>) <span class="comment">// WaitGroup的值设置为10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// 启动10个goroutine执行加1任务</span></span><br><span class="line">        <span class="keyword">go</span> worker(&amp;counter, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查点，等待goroutine都完成任务</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="comment">// 输出当前计数器的值</span></span><br><span class="line">    fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span></span><br><span class="line">    noCopy noCopy</span><br><span class="line">    <span class="comment">// 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数</span></span><br><span class="line">    <span class="comment">// 另外32bit是用作信号量的</span></span><br><span class="line">    <span class="comment">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法</span></span><br><span class="line">    <span class="comment">// 总之，会找到对齐的那64bit作为state，其余的32bit做信号量</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>noCopy 的辅助字段，主要就是<strong>辅助 vet 工具检查是否通过 copy 赋值（实际工程中也能使用这个技巧）</strong>这个 WaitGroup 实例。</li>
<li>state1，一个具有复合意义的字段，包含 WaitGroup 的计数、阻塞在检查点的 waiter 数和信号量。因为对 64 位整数的原子操作要求整数的地址是 64 位对齐的，所以针对 64 位和 32 位环境的 state 字段的组成是不一样的。</li>
</ul>
<p><strong>Add方法逻辑：</strong>Add 方法主要操作的是 state 的计数部分。你可以为计数值增加一个 delta 值，内部通过原子操作把这个值加到计数值上。需要注意的是，这个 delta 也可以是个负数，相当于为计数值减去一个值，Done 方法内部其实就是通过 Add(-1) 实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    <span class="comment">// 高32bit是计数值v，所以把delta左移32，增加到计数上</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// 当前计数值</span></span><br><span class="line">    w := <span class="keyword">uint32</span>(state) <span class="comment">// waiter count</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量</span></span><br><span class="line">    <span class="comment">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Done方法实际就是计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Wait 方法的实现逻辑：</strong>不断检查 state 的值。如果其中的计数值变为了 0，那么说明所有的任务已完成，调用者不必再等待，直接返回。如果计数值大于 0，说明此时还有任务没完成，那么调用者就变成了等待者，需要加入 waiter 队列，并且阻塞住自己。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep)</span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// 当前计数值</span></span><br><span class="line">        w := <span class="keyword">uint32</span>(state) <span class="comment">// waiter的数量</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果计数值为0, 调用这个方法的goroutine不必再等待，继续执行它后面的逻辑即可</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞休眠等待</span></span><br><span class="line">            runtime_Semacquire(semap)</span><br><span class="line">            <span class="comment">// 被唤醒，不再阻塞，返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a><strong>Cond</strong></h2><p>Cond并不常用，一般用在需要在唤醒一个或者所有的等待者做一些检查操作的时候（等待/通知（wait/notify）机制）。</p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NeWCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Signal ：</strong>允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。在其他编程语言中，比如 Java 语言中，Signal 方法也被叫做 notify 方法。调用 Signal 方法时，不强求你一定要持有 c.L 的锁。</p>
<p><strong>Broadcast：</strong>允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语言中，比如 Java 语言中，Broadcast 方法也被叫做 notifyAll 方法。同样地，调用 Broadcast 方法时，也不强求你一定持有 c.L 的锁。</p>
<p><strong>Wait：</strong>会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。</p>
<p>Cond包含一个Mutex对象作为参数，在使用时需要进行初始化操作。</p>
<p><strong>example：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">            c.L.Lock()</span><br><span class="line">            ready++</span><br><span class="line">            c.L.Unlock()</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">&quot;等待者#%d 已准备就绪\n&quot;</span>, i)</span><br><span class="line">            <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">            c.Broadcast()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">        c.Wait()</span><br><span class="line">        log.Println(<span class="string">&quot;等待者唤醒一次&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的goroutine是否就绪</span></span><br><span class="line">    log.Println(<span class="string">&quot;所有等待者都准备就绪&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a><strong>Once</strong></h2><p>Once使用比较简单，一般在进行单例对象（如数据库链接、配置对象等）初始化时使用。</p>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p>当我们需要初始化单例对象时，可以通过定义package级别的变量或者在init、main函数开始执行的时候执行一个初始化函数，这些方式都是线程安全的，但很多时候我们需要进行<strong>延迟初始化</strong>。</p>
<p><strong>Once包含方法：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个初始化函数</span></span><br><span class="line">    f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;in f1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    once.Do(f1) <span class="comment">// 打印出 in f1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个初始化函数</span></span><br><span class="line">    f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;in f2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    once.Do(f2) <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为当且仅当第一次调用 Do 方法的时候参数 f 才会执行，即使第二次、第三次、第 n 次调用时 f 参数的值不一样，也不会被执行，比如下面的例子，虽然 f1 和 f2 是不同的函数，但是第二个函数 f2 就不会执行。</p>
<p><strong>典型使用场景：</strong></p>
<p>cache初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span> *<span class="title">Cache</span></span> &#123; <span class="comment">// 获取默认的Cache</span></span><br><span class="line">    defaultOnce.Do(initDefaultCache) <span class="comment">// 初始化cache</span></span><br><span class="line">    <span class="keyword">return</span> defaultCache</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个全局的cache变量，使用Once初始化，所以也定义了一个Once变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    defaultOnce  sync.Once</span><br><span class="line">    defaultCache *Cache</span><br><span class="line">  )</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDefaultCache</span><span class="params">()</span></span> &#123; <span class="comment">//初始化cache,也就是Once.Do使用的f函数</span></span><br><span class="line">    ......</span><br><span class="line">    defaultCache = c</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些Once初始化的变量，比如defaultDir</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    defaultDirOnce sync.Once</span><br><span class="line">    defaultDir     <span class="keyword">string</span></span><br><span class="line">    defaultDirErr  error</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试用例初始化资源：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试window系统调用时区相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForceAusFromTZIForTesting</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ResetLocalOnceForTest()</span><br><span class="line">        <span class="comment">// 使用Once执行一次初始化</span></span><br><span class="line">    localOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; initLocalFromTZI(&amp;aus) &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="comment">// 双检查</span></span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Once 实现要<strong>使用一个互斥锁，这样初始化的时候如果有并发的 goroutine，就会进入doSlow 方法。</strong>互斥锁的机制保证只有一个 goroutine 进行初始化，同时利用双检查的机制（double-checking），再次判断 o.done 是否为 0，如果为 0，则是第一次执行，执行完毕后，就将 o.done 设置为 1，然后释放锁。</p>
<p>使用互斥锁主要是为了当参数f执行很慢时，后续调用Do方法的goroutine虽然看到 done 已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源，因为 f 还没有执行完。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h2><p>map在Go中是非线程安全的数据结构，在多个goroutine同时访问一个map对象时，程序会panic。</p>
<p>我们一般需要通过加锁的方式来实现一个线程安全的map。</p>
<h3 id="采用读写锁来保护map"><a href="#采用读写锁来保护map" class="headerlink" title="采用读写锁来保护map"></a><strong>采用读写锁来保护map</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMap <span class="keyword">struct</span> &#123; <span class="comment">// 一个读写锁保护的线程安全的map</span></span><br><span class="line">    sync.RWMutex <span class="comment">// 读写锁保护下面的map字段</span></span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建一个RWMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRWMap</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">RWMap</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;RWMap&#123;</span><br><span class="line">        m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, n),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123; <span class="comment">//从map中读取一个值</span></span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="keyword">defer</span> m.RUnlock()</span><br><span class="line">    v, existed := m.m[k] <span class="comment">// 在锁的保护下从map中读取</span></span><br><span class="line">    <span class="keyword">return</span> v, existed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Set</span><span class="params">(k <span class="keyword">int</span>, v <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 设置一个键值对</span></span><br><span class="line">    m.Lock()              <span class="comment">// 锁保护</span></span><br><span class="line">    <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">    m.m[k] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Delete</span><span class="params">(k <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//删除一个键</span></span><br><span class="line">    m.Lock()                   <span class="comment">// 锁保护</span></span><br><span class="line">    <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">    <span class="built_in">delete</span>(m.m, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// map的长度</span></span><br><span class="line">    m.RLock()   <span class="comment">// 锁保护</span></span><br><span class="line">    <span class="keyword">defer</span> m.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(m.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Each</span><span class="params">(f <span class="keyword">func</span>(k, v <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123; <span class="comment">// 遍历map</span></span><br><span class="line">    m.RLock()             <span class="comment">//遍历期间一直持有读锁</span></span><br><span class="line">    <span class="keyword">defer</span> m.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="分片加锁"><a href="#分片加锁" class="headerlink" title="分片加锁"></a><strong>分片加锁</strong></h3><p>采用RWMutex可以解决map线程不安全的问题，但在大量并发读写的情况下，性能较差，这里可以采用分片加锁的方式来实现细粒度加锁（<a target="_blank" rel="noopener" href="https://github.com/orcaman/concurrent-map%EF%BC%89%EF%BC%9A">https://github.com/orcaman/concurrent-map）：</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SHARD_COUNT = <span class="number">32</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 分成SHARD_COUNT个分片的map</span></span><br><span class="line"><span class="keyword">type</span> ConcurrentMap []*ConcurrentMapShared</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过RWMutex保护的线程安全的分片，包含一个map</span></span><br><span class="line"><span class="keyword">type</span> ConcurrentMapShared <span class="keyword">struct</span> &#123;</span><br><span class="line">    items        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    sync.RWMutex <span class="comment">// Read Write mutex, guards access to internal map.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建并发map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">ConcurrentMap</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(ConcurrentMap, SHARD_COUNT)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SHARD_COUNT; i++ &#123;</span><br><span class="line">      m[i] = &amp;ConcurrentMapShared&#123;items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key计算分片索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">GetShard</span><span class="params">(key <span class="keyword">string</span>)</span> *<span class="title">ConcurrentMapShared</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m[<span class="keyword">uint</span>(fnv32(key))%<span class="keyword">uint</span>(SHARD_COUNT)]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据key计算出对应的分片</span></span><br><span class="line">    shard := m.GetShard(key)</span><br><span class="line">    shard.Lock() <span class="comment">//对这个分片加锁，执行业务操作</span></span><br><span class="line">    shard.items[key] = value</span><br><span class="line">    shard.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据key计算出对应的分片</span></span><br><span class="line">    shard := m.GetShard(key)</span><br><span class="line">    shard.RLock()</span><br><span class="line">    <span class="comment">// 从这个分片读取key的值</span></span><br><span class="line">    val, ok := shard.items[key]</span><br><span class="line">    shard.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a><strong>sync.Map</strong></h3><p>sync.Map是Go的官方库中的实现，在使用上与标准的map类型有所区别，一般在以下场景下，sync.Map的性能会优于map+RWMutex：</p>
<ul>
<li>只会增长的缓存系统中，一个 key 只写入一次而被读很多次。</li>
<li>多个 goroutine 为不相交的键集读、写和重写键值对。</li>
</ul>
<h4 id="sync-Map的基本使用"><a href="#sync-Map的基本使用" class="headerlink" title="sync.Map的基本使用"></a><strong>sync.Map的基本使用</strong></h4><p>Store：用来设置一个键值对，或者更新一个键值对的。</p>
<p>Load：用来读取一个 key 对应的值。</p>
<p>Delete：用来删除一个key</p>
<p>sync.map 还有一些 LoadAndDelete、LoadOrStore、Range 等辅助方法，但是没有 Len 这样查询 sync.Map 的包含项目数量的方法，并且官方也不准备提供。如果你想得到 sync.Map 的项目数量的话，你可能不得不通过 Range 逐个计数。</p>
<h4 id="sync-Map的实现"><a href="#sync-Map的实现" class="headerlink" title="sync.Map的实现"></a><strong>sync.Map的实现</strong></h4><p>sync.Map主要的实现逻辑如下：</p>
<ul>
<li>空间换时间。通过冗余的两个数据结构（只读的 read 字段、可写的 dirty），来减少加锁对性能的影响。对只读字段（read）的操作不需要加锁。</li>
<li>优先从 read 字段读取、更新、删除，因为对 read 字段的读取不需要锁。</li>
<li>动态调整。miss 次数多了之后，将 dirty 数据提升为 read，避免总是从 dirty 中加锁读取。</li>
<li>double-checking。加锁之后先还要再检查 read 字段，确定真的不存在才操作 dirty 字段。</li>
<li>延迟删除。删除一个键值只是打标记，只有在提升 dirty 字段为 read 字段的时候才清理删除的数据。</li>
</ul>
<p><strong>Map数据结构：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Map struct &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    &#x2F;&#x2F; 基本上你可以把它看成一个安全的只读的map</span><br><span class="line">    &#x2F;&#x2F; 它包含的元素其实也是通过原子操作更新的，但是已删除的entry就需要加锁操作了</span><br><span class="line">    read atomic.Value &#x2F;&#x2F; readOnly</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 包含需要加锁才能访问的元素</span><br><span class="line">    &#x2F;&#x2F; 包括所有在read字段中但未被expunged（删除）的元素以及新加的元素</span><br><span class="line">    dirty map[interface&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录从read中读取miss的次数，一旦miss数和dirty长度一样了，就会把dirty提升为read，并把dirty置空</span><br><span class="line">    misses int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type readOnly struct &#123;</span><br><span class="line">    m       map[interface&#123;&#125;]*entry</span><br><span class="line">    amended bool &#x2F;&#x2F; 当dirty中包含read没有的数据时为true，比如新增一条数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expunged是用来标识此项已经删掉的指针</span><br><span class="line">&#x2F;&#x2F; 当map中的一个项目被删除了，只是把它的值标记为expunged，以后才有机会真正删除此项</span><br><span class="line">var expunged &#x3D; unsafe.Pointer(new(interface&#123;&#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; entry代表一个值</span><br><span class="line">type entry struct &#123;</span><br><span class="line">    p unsafe.Pointer &#x2F;&#x2F; *interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Store方法：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="comment">// 如果read字段包含这个项，说明是更新，cas更新项目的值即可</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read中不存在，或者cas更新失败，就需要加锁访问dirty了</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">// 双检查，看看read是否已经存在了</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 此项目先前已经被删除了，通过将它的值设置为nil，标记为unexpunged</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value) <span class="comment">// 更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123; <span class="comment">// 如果dirty中有此项</span></span><br><span class="line">        e.storeLocked(&amp;value) <span class="comment">// 直接更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就是一个新的key</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123; <span class="comment">//如果dirty为nil</span></span><br><span class="line">            <span class="comment">// 需要创建dirty对象，并且标记read的amended为true,</span></span><br><span class="line">            <span class="comment">// 说明有元素它不包含而dirty包含</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value) <span class="comment">//将新值增加到dirty对象中</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123; <span class="comment">// 如果dirty字段已经存在，不需要创建了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly) <span class="comment">// 获取read字段</span></span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123; <span class="comment">// 遍历read字段</span></span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123; <span class="comment">// 把非punged的键值对复制到dirty中</span></span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Store 既可以是新增元素，也可以是更新元素。如果运气好的话，更新的是已存在的未被删除的元素，直接更新即可，不会用到锁。如果运气不好，需要更新（重用）删除的对象、更新还未提升的 dirty 中的对象，或者新增加元素的时候就会使用到了锁，这个时候，性能就会下降。</p>
<p>所以从这一点来看，sync.Map 适合那些只会增长的缓存系统（k8s operator的workpool就可以使用），可以进行更新，但是不要删除，并且不要频繁地增加新元素。</p>
<p><strong>Load方法：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先从read处理</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// 如果不存在并且dirty不为nil(有新的元素)</span></span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// 双检查，看看read中现在是否存在此key</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//依然不存在，并且dirty不为nil</span></span><br><span class="line">            e, ok = m.dirty[key]<span class="comment">// 从dirty中读取</span></span><br><span class="line">            <span class="comment">// 不管dirty中存不存在，miss数都加1</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load() <span class="comment">//返回读取的对象，e既可能是从read中获得的，也可能是从dirty中获得的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.misses++ <span class="comment">// misses计数加一</span></span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123; <span class="comment">// 如果没达到阈值(dirty字段的长度),返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;) <span class="comment">//把dirty字段的内存提升为read字段</span></span><br><span class="line">    m.dirty = <span class="literal">nil</span> <span class="comment">// 清空dirty</span></span><br><span class="line">    m.misses = <span class="number">0</span>  <span class="comment">// misses数重置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果幸运的话，我们从 read 中读取到了这个 key 对应的值，那么就不需要加锁了，性能会非常好。但是，如果请求的 key 不存在或者是新加的，就需要加锁从 dirty 中读取。所以，读取不存在的 key 会因为加锁而导致性能下降，读取还没有提升的新值的情况下也会因为加锁性能下降。</p>
<p>其中，missLocked 增加 miss 的时候，如果 miss 数等于 dirty 长度，会将 dirty 提升为 read，并将 dirty 置空。</p>
<p><strong>Delete方法：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// 双检查</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// 这一行长坤在1.15中实现的时候忘记加上了，导致在特殊的场景下有些key总是没有被回收</span></span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            <span class="comment">// miss数加1</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Delete 方法也是先从 read 操作开始，因为不需要锁。</p>
<p>如果 read 中不存在，那么就需要从 dirty 中寻找这个项目。最终，如果项目存在就删除（将它的值标记为 nil）。如果项目不为 nil 或者没有被标记为 expunged，那么还可以把它的值返回。</p>
<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a><strong>Pool</strong></h2><p>Pool指代一类建立池化对象的并发数据结构，由于Go自带垃圾回收机制，当需要保留一些创建耗时的对象（例如数据库链接等）时，我们一般会采用Pool的数据结构来存放。</p>
<p>Go标准库中提供了一个通用的Pool数据结构，sync.Pool。</p>
<h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a><strong>sync.Pool</strong></h3><p>sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象，需要注意的是sync.Pool 不可在使用之后再复制使用。</p>
<p><strong>sync.Pool提供了三个对外的方法：</strong></p>
<p><strong>New：</strong></p>
<p>Pool struct 包含一个 New 字段，这个字段的类型是函数 func() interface{}。当调用 Pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。如果你没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。</p>
<p><strong>Get：</strong></p>
<p>如果调用这个方法，就会从 Pool取走一个元素，这也就意味着，这个元素会从 Pool 中移除，返回给调用者。不过，<strong>除了返回值是正常实例化的元素，Get 方法的返回值还可能会是一个 nil（Pool.New 字段没有设置，又没有空闲元素可以返回）</strong>，所以在使用的时候，可能需要判断。</p>
<p><strong>Put</strong></p>
<p>这个方法用于将一个元素返还给 Pool，Pool 会把这个元素保存到池中，并且可以复用。但<strong>如果 Put 一个 nil 值，Pool 就会忽略这个值。</strong></p>
<p><strong>典型使用场景，buffer池：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffers = sync.Pool&#123;</span><br><span class="line">  New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBuffer</span><span class="params">()</span> *<span class="title">bytes</span>.<span class="title">Buffer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> buffers.Get().(*bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutBuffer</span><span class="params">(buf *bytes.Buffer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> buf.Cap() &gt; <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123; <span class="comment">// 判定是否为大buffer，防止Pool未回收对象，导致内存泄漏</span></span><br><span class="line">	retrun</span><br><span class="line">  &#125;</span><br><span class="line">  buf.Reset()</span><br><span class="line">  buffers.Put(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-Pool内部实现"><a href="#sync-Pool内部实现" class="headerlink" title="sync.Pool内部实现"></a><strong>sync.Pool内部实现</strong></h4><h5 id="关于GC"><a href="#关于GC" class="headerlink" title="关于GC"></a><strong>关于GC</strong></h5><p>Go 1.1.3之前，sync.Pool实现有2大问题：</p>
<ol>
<li><p><strong>每次 GC 都会回收创建的对象。</strong></p>
<p>如果缓存元素数量太多，就会导致 STW 耗时变长；缓存元素都被回收后，会导致 Get 命中率下降，Get 方法不得不新创建很多对象。</p>
</li>
<li><p><strong>底层实现使用了 Mutex，对这个锁并发请求竞争激烈的时候，会导致性能的下降。</strong></p>
</li>
</ol>
<p>当前版本sync.Pool的数据结构如下：</p>
<img src="/images/1-sync.Pool数据结构.png" alt="1-sync.Pool数据结构" style="zoom: 67%;" />

<p>Pool 最重要的两个字段是 local 和 victim，因为它们两个主要用来存储空闲的元素。</p>
<p>每次垃圾回收的时候，Pool 会把 victim 中的对象移除，然后把 local 的数据给 victim，这样的话，local 就会被清空，而 victim 就像一个垃圾分拣站，里面的东西可能会被当做垃圾丢弃了，但是里面有用的东西也可能被捡回来重新使用。</p>
<p><strong>victim 中的元素如果被 Get 取走，那么这个元素就很幸运，因为它又“活”过来了</strong>。但是，如果这个时候 Get 的并发不是很大，元素没有被 Get 取走，那么就会被移除掉，因为没有别人引用它的话，就会被垃圾回收掉。</p>
<p><strong>GC时sync.Pool的处理逻辑：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 丢弃当前victim, STW所以不用加锁</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">        p.victim = <span class="literal">nil</span></span><br><span class="line">        p.victimSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将local复制给victim, 并将原local置为nil</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">        p.victim = p.local</span><br><span class="line">        p.victimSize = p.localSize</span><br><span class="line">        p.local = <span class="literal">nil</span></span><br><span class="line">        p.localSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，因为所有当前主要的空闲可用的元素都存放在 local 字段中，<strong>请求元素时也是优先从 local 字段中查找可用的元素。</strong>local 字段包含一个 poolLocalInternal 字段，并提供 CPU 缓存对齐，从而避免 false sharing。</p>
<p>而 poolLocalInternal 也包含两个字段：private 和 shared。</p>
<ul>
<li>private：代表一个缓存的元素，而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，所以不会有并发的问题。</li>
<li>shared：可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相当于只有一个本地的 P 作为生产者（Producer），多个 P 作为消费者（Consumer），它是使用一个 local-free 的 queue 列表实现的。</li>
</ul>
<h5 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a><strong>Get方法</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// 把当前goroutine固定在当前的P上</span></span><br><span class="line">    l, pid := p.pin()</span><br><span class="line">    x := l.private <span class="comment">// 优先从local的private字段取，快速</span></span><br><span class="line">    l.private = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从当前的local.shared弹出一个，注意是从head读取并移除</span></span><br><span class="line">        x, _ = l.shared.popHead()</span><br><span class="line">        <span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">// 如果没有，则去偷一个</span></span><br><span class="line">            x = p.getSlow(pid) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_procUnpin() <span class="comment">// pin方法会将此goroutine固定在当前的P上，免查找元素期间被其它的P执行</span></span><br><span class="line">    <span class="comment">// 如果没有获取到，尝试使用New函数生成一个新的</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">        x = p.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，从本地的 private 字段中获取可用元素，因为没有锁，获取元素的过程会非常快，如果没有获取到，就尝试从本地的 shared 获取一个，如果还没有，会使用 getSlow 方法去其它的 shared 中“偷”一个。最后，如果没有获取到，就尝试使用 New 函数创建一个新的。</p>
<p>这里的重点是 getSlow 方法，我们来分析下。看名字也就知道了，它的耗时可能比较长。它首先要遍历所有的 local，尝试从它们的 shared 弹出一个元素。如果还没找到一个，那么，就开始对 victim 下手了。</p>
<p>在 vintim 中查询可用元素的逻辑还是一样的，先从对应的 victim 的 private 查找，如果查不到，就再从其它 victim 的 shared 中查找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line">    size := atomic.LoadUintptr(&amp;p.localSize)</span><br><span class="line">    locals := p.local                       </span><br><span class="line">    <span class="comment">// 从其它proc中尝试偷取一个元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">        l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其它proc也没有可用元素，那么尝试从vintim中获取</span></span><br><span class="line">    size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    locals = p.victim</span><br><span class="line">    l := indexLocal(locals, pid)</span><br><span class="line">    <span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123; <span class="comment">// 同样的逻辑，先从vintim中的local private获取</span></span><br><span class="line">        l.private = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123; <span class="comment">// 从vintim其它proc尝试偷取</span></span><br><span class="line">        l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果victim中都没有，则把这个victim标记为空，以后的查找可以快速跳过了</span></span><br><span class="line">    atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a><strong>Put方法</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">// nil值直接丢弃</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l, _ := p.pin()</span><br><span class="line">    <span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123; <span class="comment">// 如果本地private没有值，直接设置这个值即可</span></span><br><span class="line">        l.private = x</span><br><span class="line">        x = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x != <span class="literal">nil</span> &#123; <span class="comment">// 否则加入到本地队列中</span></span><br><span class="line">        l.shared.pushHead(x)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Put 的逻辑相对简单，优先设置本地 private，如果 private 字段已经有值了，那么就把此元素 push 到本地队列中。</p>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a><strong>连接池</strong></h3><p>由于sync.Pool 会无通知地在某个时候就把连接移除垃圾回收掉了，而我们需要长久保持这个连接时，一般会使用其它方法来池化连接。</p>
<h4 id="http-client-池"><a href="#http-client-池" class="headerlink" title="http client 池"></a><strong>http client 池</strong></h4><p>标准库的 http.Client 是一个 http client 的库，可以用它来访问 web 服务器。为了提高性能，这个 Client 的实现也是通过池的方法来缓存一定数量的连接，以便后续重用这些连接。</p>
<h4 id="TCP-连接池"><a href="#TCP-连接池" class="headerlink" title="TCP 连接池"></a><strong>TCP 连接池</strong></h4><p>最常用的一个 TCP 连接池是 fatih 开发的<a target="_blank" rel="noopener" href="https://github.com/fatih/pool">fatih/pool</a>，虽然这个项目已经被 fatih 归档（Archived），不再维护了，但是因为它相当稳定了，我们可以开箱即用。即使你有一些特殊的需求，也可以 fork 它，然后自己再做修改。</p>
<p>它通过把 net.Conn 包装成 PoolConn，实现了拦截 net.Conn 的 Close 方法，避免了真正地关闭底层连接，而是把这个连接放回到池中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type PoolConn struct &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">    mu       sync.RWMutex</span><br><span class="line">    c        *channelPool</span><br><span class="line">    unusable bool</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;拦截Close</span><br><span class="line">func (p *PoolConn) Close() error &#123;</span><br><span class="line">    p.mu.RLock()</span><br><span class="line">    defer p.mu.RUnlock()</span><br><span class="line">  </span><br><span class="line">    if p.unusable &#123;</span><br><span class="line">      if p.Conn !&#x3D; nil &#123;</span><br><span class="line">        return p.Conn.Close()</span><br><span class="line">      &#125;</span><br><span class="line">      return nil</span><br><span class="line">    &#125;</span><br><span class="line">    return p.c.put(p.Conn)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a><strong>数据库连接池</strong></h4><p>标准库 sql.DB 还提供了一个通用的数据库的连接池，通过 MaxOpenConns 和 MaxIdleConns 控制最大的连接数和最大的 idle 的连接数。默认的 MaxIdleConns 是 2，这个数对于数据库相关的应用来说太小了，我们一般都会调整它。</p>
<h3 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a><strong>Worker Pool</strong></h3><p>大量的goroutine会导致无效的调度和垃圾回收，为了防止goroutine溢出等情况，有时候我们需要创建Worker Pool来控制goroutine的数量。</p>
<p>常用的Worker Pool三方库推荐：</p>
<p><a target="_blank" rel="noopener" href="https://godoc.org/github.com/gammazero/workerpool">gammazero/workerpool</a>：gammazero/workerpool 可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</p>
<p><a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/ivpusic/grpool?utm_source=godoc">ivpusic/grpool</a>：grpool 创建 Pool 的时候需要提供 Worker 的数量和等待执行的任务的最大数量，任务的提交是直接往 Channel 放入任务。</p>
<p><a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/dpaks/goworkers?utm_source=godoc">dpaks/goworkers</a>：dpaks/goworkers 提供了更便利的 Submit 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool 的方法。它的任务的执行结果需要在 ResultChan 和 ErrChan 中去获取，没有提供阻塞的方法，但是它可以在初始化的时候设置 Worker 的数量和任务数。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a><strong>Context</strong></h2><p>Context的出现主要为了解决goroutine的控制以及goroutine间的上下文信息传递（如认证信息、环境信息等）。</p>
<h3 id="Context基本用法"><a href="#Context基本用法" class="headerlink" title="Context基本用法"></a><strong>Context基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Deadline：</strong>Deadline 方法会返回这个 Context 被取消的截止日期。如果没有设置截止日期，ok 的值是 false。后续每次调用这个对象的 Deadline 方法时，都会返回和第一次调用相同的结果。</p>
<p><strong>Done：</strong>Done 方法返回一个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没被取消，可能会返回 nil。后续的 Done 调用总是返回相同的结果。当 Done 被 close 的时候，你可以通过 ctx.Err 获取错误信息。 </p>
<p><strong>Err：</strong>如果 Done 没有被 close，Err 方法返回 nil；如果 Done 被 close，Err 方法会返回 Done 被 close 的原因。</p>
<p><strong>Value：</strong>返回此 ctx 中和指定的 key 相关联的 value。</p>
<p><strong>Context 中实现了 2 个常用的生成顶层 Context 的方法：</strong></p>
<p><strong>context.Background()：</strong>返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。一般用在主函数、初始化、测试以及创建根 Context 的时候。</p>
<p><strong>context.TODO()：</strong>返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。当你不清楚是否该用 Context，或者目前还不知道要传递一些什么上下文信息的时候，就可以使用这个方法。</p>
<p><strong>在使用 Context 的时候，有一些约定俗成的规则：</strong></p>
<ul>
<li>一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。</li>
<li>从来不把 nil 当做 Context 类型的参数值，可以使用 context.Background() 创建一个空的上下文对象，也不要使用 nil。</li>
<li>Context 只用来临时做函数之间的上下文透传，不能持久化 Context 或者把 Context 长久保存。把 Context 持久化到数据库、本地文件或者全局变量、缓存中都是错误的用法。</li>
<li>key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。</li>
<li>使用 WithValue 时，key 的类型应该是自己定义的类型。常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。</li>
</ul>
<p>我们一般使用Context时，会采用<strong>WithValue、WithCancel、WithTimeout 和 WithDeadline</strong>：</p>
<h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a><strong>WithValue</strong></h4><p>WithValue 基于 parent Context 生成一个新的 Context，保存了一个 key-value 键值对。它常常用来传递上下文，Context实现了链式查找，如果当前context不包含所查找的key，会像parent Context中去查找。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx = context.TODO()</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;0004&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(ctx.Value(<span class="string">&quot;key1&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>example：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key <span class="keyword">string</span>=<span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">//附加值</span></span><br><span class="line">	valueCtx:=context.WithValue(ctx,key,<span class="string">&quot;【监控1】&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;可以了，通知监控停止&quot;</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="comment">//取出值</span></span><br><span class="line">			fmt.Println(ctx.Value(key),<span class="string">&quot;监控退出，停止了...&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//取出值</span></span><br><span class="line">			fmt.Println(ctx.Value(key),<span class="string">&quot;goroutine监控中...&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="WithCanel-withDeadline-withTimeout"><a href="#WithCanel-withDeadline-withTimeout" class="headerlink" title="WithCanel\withDeadline\withTimeout"></a><strong>WithCanel\withDeadline\withTimeout</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>

<p>WitchCancel传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。 <code>WithDeadline</code>函数，和<code>WithCancel</code>差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。</p>
<p><code>WithTimeout</code>和<code>WithDeadline</code>基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。</p>
<p>WithCancel方法实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)<span class="comment">// 把c朝上传播</span></span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cancel 是向下传递的，如果一个 WithCancel 生成的 Context 被 cancel 时，如果它的子 Context（也有可能是孙，或者更低，依赖子的类型）也是 cancelCtx 类型的，就会被 cancel，但是不会向上传递。parent Context 不会因为子 Context 被 cancel 而 cancel。</p>
<p>WithCancel示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控1】&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控2】&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控3】&quot;</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;可以了，通知监控停止&quot;</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name,<span class="string">&quot;监控退出，停止了...&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name,<span class="string">&quot;goroutine监控中...&quot;</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#并发" >
    <span class="tag-code">并发</span>
  </a>

  <a href="/tags#Golang" >
    <span class="tag-code">Golang</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/07/11/Go%E5%B9%B6%E5%8F%91-goroutine%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/">
        <span class="nav-arrow">← </span>
        
          Go并发-goroutine并发模型
        
      </a>
    
    
      <a class="nav-right" href="/2022/07/11/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/">
        
          架构设计-有趣的设计模式
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WaitGroup"><span class="toc-nav-text">WaitGroup</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-nav-text">基本用法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">内部实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Cond"><span class="toc-nav-text">Cond</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-nav-text">基本用法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Once"><span class="toc-nav-text">Once</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-2"><span class="toc-nav-text">基本用法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-1"><span class="toc-nav-text">内部实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#map"><span class="toc-nav-text">map</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%87%87%E7%94%A8%E8%AF%BB%E5%86%99%E9%94%81%E6%9D%A5%E4%BF%9D%E6%8A%A4map"><span class="toc-nav-text">采用读写锁来保护map</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%86%E7%89%87%E5%8A%A0%E9%94%81"><span class="toc-nav-text">分片加锁</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sync-Map"><span class="toc-nav-text">sync.Map</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#sync-Map%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-nav-text">sync.Map的基本使用</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#sync-Map%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">sync.Map的实现</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Pool"><span class="toc-nav-text">Pool</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sync-Pool"><span class="toc-nav-text">sync.Pool</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#sync-Pool%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">sync.Pool内部实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%85%B3%E4%BA%8EGC"><span class="toc-nav-text">关于GC</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Get%E6%96%B9%E6%B3%95"><span class="toc-nav-text">Get方法</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Put%E6%96%B9%E6%B3%95"><span class="toc-nav-text">Put方法</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-nav-text">连接池</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#http-client-%E6%B1%A0"><span class="toc-nav-text">http client 池</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-nav-text">TCP 连接池</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-nav-text">数据库连接池</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Worker-Pool"><span class="toc-nav-text">Worker Pool</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Context"><span class="toc-nav-text">Context</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Context%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-nav-text">Context基本用法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#WithValue"><span class="toc-nav-text">WithValue</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#WithCanel-withDeadline-withTimeout"><span class="toc-nav-text">WithCanel\withDeadline\withTimeout</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/07/11/Go并发-常见并发原语/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>