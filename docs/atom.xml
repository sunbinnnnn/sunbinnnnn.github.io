<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neil&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-27T15:04:46.681Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>NeilSun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>eBPF</title>
    <link href="http://example.com/2023/05/22/ebpf/"/>
    <id>http://example.com/2023/05/22/ebpf/</id>
    <published>2023-05-22T11:01:22.000Z</published>
    <updated>2023-05-27T15:04:46.681Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对eBPF相关进行总结。</p><span id="more"></span><h1 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h1><h2 id="1-eBPF是什么，为何对于如今的操作系统如此重要"><a href="#1-eBPF是什么，为何对于如今的操作系统如此重要" class="headerlink" title="1.eBPF是什么，为何对于如今的操作系统如此重要"></a>1.eBPF是什么，为何对于如今的操作系统如此重要</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1.概述"></a>1.1.概述</h3><p>eBPF是一种革命性的内核技术，允许开发者编写一些内核代码（例如重写内核函数），并动态加载到内核中，改变Kernel的行为。</p><p>通过eBPF可以缩短内核调用链路，改变System Call方式，并监控内核调用链路，比较常见的eBPF使用场景：</p><ul><li>构建高性能网络</li><li>跟踪内核调用链</li><li>阻止不安全的内核调用（网络DDOS）</li></ul><p>eBPF彻底改变了内核开发方式，内核至此诞生了无数可能性。</p><h3 id="1-2-BPF、eBPF"><a href="#1-2-BPF、eBPF" class="headerlink" title="1.2.BPF、eBPF"></a>1.2.BPF、eBPF</h3><p>一句话：<strong>BPF（cBPF）只是一个包过滤器（tcpdump就是基于这玩意写的），只有两个32位的寄存器；而eBPF是基于事件的内核调用修改器，有10个64位寄存器</strong>，支持JIT-Compilation、方便的用户态 &lt;-&gt; 内核态通信、maps支持、方便的helper func…</p><h3 id="1-3-Kernel"><a href="#1-3-Kernel" class="headerlink" title="1.3.Kernel"></a>1.3.Kernel</h3><p>用户应用一般存在于User space，通过高级语言调用System Call。</p><p><img src="/images/image-20230512155031730.png" alt="image-20230512155031730"></p><p>exmaple（一个echo可以包含100多个系统调用）：</p><p><img src="/images/image-20230512155241487.png" alt="image-20230512155241487"></p><p>因为Linux代码的复杂性，且Linus Torvalds的执着与Linux release数量日益增长，如果想增加额外的code来实现对System Call进行中断，观测“Open files、Network IO”等，几乎是不可能的。</p><p><img src="/images/image-20230512155648348.png" alt="image-20230512155648348"></p><h3 id="1-4-Kernel-Modules"><a href="#1-4-Kernel-Modules" class="headerlink" title="1.4.Kernel Modules"></a>1.4.Kernel Modules</h3><p>上文提到，向Kernel中提交代码是非常复杂且艰巨的，所以，Linus大佬也没把路给封死，另一种修改Kernel的方式是通过内核模块（Kernel Modules）。</p><p>Kernel Modules可以按需加载或卸载，并且独立于官方Linux kernel release发布，不需要merge在upstream branch上。</p><p>但是，Kernel Module还是有一定的危险性，原因很简单，不稳定的Kernel Module和内核程序一起运行，可能会导致Kernel crash，另外，由于Kernel Modules的作者来源不一定得到验证，无法确保是否安全（Kernel Modules运行在Kernel space，可以访问机器上所有东西）。所以大家对Kernel Modules的使用一直是非常谨慎的。</p><p>eBPF提供了一种非常不同的方式来确保安全性：<a href="https://docs.kernel.org/bpf/verifier.html">eBPF verifier</a>，其只允许安全的eBPF程序（不会造成Kernel crash或者死锁）运行，也不对数据安全有所妥协。</p><h3 id="1-5-Dynamic-Loading-of-eBPF-Programs"><a href="#1-5-Dynamic-Loading-of-eBPF-Programs" class="headerlink" title="1.5.Dynamic Loading of eBPF Programs"></a>1.5.Dynamic Loading of eBPF Programs</h3><p>eBPF能够被Kernel动态加载，一旦eBPF attch到一个指定的event，会直接被event trigge到，不论这个发起这个event的进程是否在之前已经启动了，这样不需要重启机器就可以直接使用eBPF程序。</p><p>这促使eBPF可以形成具备超强的安全、观测工具集，它可以观测机器上发生的所有事，如果跑着容器里，和跑在host一样，能观测到容器里发生的所有事，史上最强CNI：Cilium就是这么诞生的。</p><p>另外，很重要的一点：引入内核功能再也不需要挨Linus大佬批了。</p><p><img src="/images/image-20230512171104918.png" alt="image-20230512171104918"></p><h3 id="1-6-High-Perofrmance-of-eBPF-Programs"><a href="#1-6-High-Perofrmance-of-eBPF-Programs" class="headerlink" title="1.6.High Perofrmance of eBPF Programs"></a>1.6.High Perofrmance of eBPF Programs</h3><p>eBPF程序添加检测的过程是相当高效的，当一个eBPF程序被加载并即时编译（JIT-compiled）后，程序会直接运行CPU机器指令。另外，在接受每个事件的时候，用户态到内核态的拷贝也是不存在的(hook在copy前)，所以几乎没有开销。</p><p>以基于eBPF的高性能内核包过滤器：XDP（eXpress Data Path）为例，传统的包过滤都是在服务进程侧进行过滤（例如iptables），其经过了内核态解包，copy到用户态，性能会很差：</p><img src="/images/netstack.png" alt="img" style="zoom: 50%;" /><p>而XDP将eBPF的event hook放在网卡驱动侧，在分配skb之前就可以直接对包进行过滤，通过XDP进行包过滤、转发，其性能是ipvs的4.3倍（iptables更不用说了）。</p><img src="/images/netstackebpf.png" style="zoom:50%;" /><h3 id="1-7-eBPF-in-Cloud-Native-Environments"><a href="#1-7-eBPF-in-Cloud-Native-Environments" class="headerlink" title="1.7.eBPF in Cloud Native Environments"></a>1.7.eBPF in Cloud Native Environments</h3><p>如今，多数用户选择以云原生的方式运行eBPF程序，比如容器、K8S或者公有云的Serverless服务（AWS Lambda）等等；</p><p>好处显而易见，节点上的容器share同一个kernel，例如，在K8S中，所有的Pods共享同一个kernel，所以我们只需要起一个容器，就可以观测节点上所有workloads：</p><p><img src="/images/image-20230512174830637.png" alt="image-20230512174830637"></p><p>利用节点上所有进程的观测能力，以及eBPF程序的动态编译能力，一些eBPF-based的工具可以在集群中发挥superpower：</p><ul><li>应用程序不需要做任何改动、配置，就可以接入eBPF工具集。</li><li>当eBPF程序被动态加载时，不需要重启节点或应用，就可以对已经运行的应用进行观测。</li></ul><p>我们知道，一般在K8S里，我们可以通过给container挂sidecar来对网络流量、进程进行过滤、追踪、转发，实现service mesh、logging等功能。这种方式相较于直接在代码中调用对应的SDK来说，更为方便，对代码无侵入性，但是，sidecar其实存在很多缺陷：</p><ul><li><p>当为Pod插入Sidecar时，Pod需要重启。</p></li><li><p>往往需要修改应用的yaml，才可以插入sidecar。例如，我们一般通过添加annontation的方式来触发injector来修改某个workload的yaml，插入sidecar，整个过程是自动的，但如果这个workload（比如deployment），漏加了annontation，或者没有加某个label，这个sidecar就不会注入，从而无法观测这个应用了。</p></li><li><p>当一个Pod中存在多个Container时，由于彼此达到Readiness的时间点是无法预测的，sidecar的注入会可能导致容器启动速度下降，甚至会导致竞争情况。</p></li><li><p>当网络功能（例如service mash）以sidecar的方式注入时，整条网络路径非常冗长，会导致出现抖动、丢包的情况：</p><p><img src="/images/image-20230512193453205.png" alt="image-20230512193453205"></p></li></ul><p>幸运的是，我们可以通过eBPF来解决sidecar模式的诸多问题，原因还是在于eBPF可以观测节点上发生的所有事件，不论是否有sidecar的注入，依赖eBPF，可以解决一系列因sidecar带来的不稳定与安全问题。</p><h2 id="2-eBPF’s-“Hello-World”"><a href="#2-eBPF’s-“Hello-World”" class="headerlink" title="2.eBPF’s “Hello World”"></a>2.eBPF’s “Hello World”</h2><h3 id="2-1-Run-first-eBPF-Program"><a href="#2-1-Run-first-eBPF-Program" class="headerlink" title="2.1. Run first eBPF Program"></a>2.1. Run first eBPF Program</h3><p>eBPF如此强大，我们从一个简单的例子来编写eBPF应用。</p><p>有很多lib库和框架可以帮助我们编写一个eBPF应用，例如<a href="https://github.com/iovisor/bcc">BCC Python framework</a>，提供了相当简单的方式去编写eBPF程序。</p><p>首先，我们需要安装BCC框架，可以参考官方文档：<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md%E3%80%82">https://github.com/iovisor/bcc/blob/master/INSTALL.md。</a></p><p>以下是一个“Hello World”的demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">program = <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">int hello(void *ctx) &#123;</span></span><br><span class="line"><span class="string">    bpf_trace_printk(&quot;Hello, World!\\n&quot;);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">b = BPF(text=program)</span><br><span class="line">syscall = b.get_syscall_fnname(<span class="string">&quot;execve&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=syscall, fn_name=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">b.trace_print()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码包含两部分：</p><p>1.eBPF内核态程序</p><p>2.eBPF用户态程序</p><p><img src="/images/image-20230518190719115.png" alt="image-20230518190719115"></p><p>eBPF有一组<code>helper function</code>来与内核进行交互，在demo中，包含一个<code>helper function</code>: <code>bpf_trace_printk()</code>，用来输出一行信息到trace_pipe（/sys/kernel/debug/tracing/trace_pipe）文件中。eBPF代码本身是通过C来编写的，理论上需要进行编译才可以运行（实际上单独编写一个eBPF程序也需要编译），但当通过BCC框架来开发时，不需要额外进行编译操作，只需要声明一个BPF object：</p><p><code>b = BPF(text=program)</code></p><p>eBPF程序还需要attach到一个event上，在demo中attach到了<code>execve</code>这个syscall上，当任何一个可执行程序被执行时，这个syscall都会被调用，接着就会trigger eBPF程序。一般来说，syscall会根据系统架构的不同，而带一些特定的前缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;sys_&quot;,</span><br><span class="line">&quot;__x64_sys_&quot;,</span><br><span class="line">&quot;__x32_compat_sys_&quot;,</span><br><span class="line">&quot;__ia32_compat_sys_&quot;,</span><br><span class="line">&quot;__arm64_sys_&quot;,</span><br><span class="line">&quot;__s390x_sys_&quot;,</span><br><span class="line">&quot;__s390_sys_&quot;,</span><br></pre></td></tr></table></figure><p>BCC框架提供了get_syscall_fnname的函数来获取对应的真实syscall名称，所以我们就不需要考虑系统架构了：</p><p><code>syscall = b.get_syscall_fnname(&quot;execve&quot;)</code></p><p>接下来，我们通过需要通过内核的<a href="https://docs.kernel.org/trace/kprobes.html">kprobes</a>（在05年的时候被加入Kernel，通过这个功能可以允许开发者在几乎所有的指令上增加trap）功能来attach到一个syscall的events上:</p><p><code>b.attach_kprobe(event=syscall, fn_name=&quot;hello&quot;)</code></p><p>最后，通过一个死循环来hang住程序，并获取trace_pipe中的内容，就可以开始监听内核调用了。</p><p>执行下（很多都是vsocde server执行的程序）：</p><p><img src="/images/image-20230518193303378.png" alt="image-20230518193303378"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tips:</span><br><span class="line">如果不是通过root运行，可能会没有权限，eBPF必须的三个内核capabilitied分别为：</span><br><span class="line">CAP_BPF(https:&#x2F;&#x2F;mdaverde.com&#x2F;posts&#x2F;cap-bpf&#x2F;), CAP_PERFMON, CAP_NET_ADMIN</span><br></pre></td></tr></table></figure><p>在输出结果中，除了“Hello World”外，还有一些额外的event上下文信息，包括调用程序，process ID等。</p><p>但这个demo其实有很多问题，除了几乎不能做除了观测以外的其他事，最重要的是，这个demo无法获取eBPF程序本身的信息，当多个“Hello-World”同时运行时，并不知道是“谁”往trace_pipe中塞了内容，所以，BPF maps登场了。</p><h3 id="2-2-BPF-maps"><a href="#2-2-BPF-maps" class="headerlink" title="2.2.BPF maps"></a>2.2.BPF maps</h3><p><strong>map</strong>是用于eBPF程序和用户态程序之间交互的数据结构（在绝大多数场景，BPF maps和eBPF maps是一个东西），比较典型的用法是：</p><p>1.eBPF程序加载用户态程序配置</p><p>2.eBPF程序间传递状态</p><p>3.eBPF将结果传递到用户态程序</p><p>在Kernel中定义了很多<a href="https://elixir.bootlin.com/linux/v5.15.86/source/include/uapi/linux/bpf.h#L878">BPF maps类型</a>，可以在<a href="https://docs.kernel.org/bpf/map_bloom_filter.html">kernel文档</a>中找到他们的说明。一般来说，maps是以KV的形式存储的，但同样可以被扩展为hash表、perf、ring buffers或者数组。</p><p>被扩展成数组的map，由一个4字节的key构成；而hash表类型的map可以存在任何类型的key。一些map类型也被扩展成一些周知的类型，例如先入先出队列，先入后出栈，最长匹配队列，或者Bloom filters。</p><p>有一些常用的BPF maps存在一些特定的对象，例如：</p><p><a href="https://lwn.net/Articles/731133/">sockmaps</a>和<a href="https://docs.kernel.org/bpf/map_devmap.html">devmaps</a>存放了sockets和网络设备相关的信息，可以给网络功能相关的eBPF程序所使用，用来重定向流量；</p><p>数组类型的map存放了eBPF程序的index，可以用于和其他eBPF程序交互；</p><p>一些map类型还会分散在不同的内存块上，由不同的CPU来读写，一般用于并行场景，使用这种map时，需要考虑并行锁的问题（Spin lock）。</p><p>接下来，我们通过一个例子来使用一个hash表类型的BPF map，通过BCC框架，我们可以很简单地去扩展一个hash表。</p><h4 id="2-2-3-Hash-Table-Map"><a href="#2-2-3-Hash-Table-Map" class="headerlink" title="2.2.3.Hash Table Map"></a>2.2.3.Hash Table Map</h4><p>在“Hello World”的基础上，我们将hello函数进行扩展，定义出一个hash表来存放user ID和对应的user调用<code>execve</code>的次数。</p><p>BPF程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BPF_HASH(counter_table); <span class="comment">// BPF_HASH是用来定义hash table的宏</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line">    u64 uid;</span><br><span class="line">    u64 counter = <span class="number">0</span>;</span><br><span class="line">    u64 *p;</span><br><span class="line">    <span class="comment">// bpf_get_current_uid_gid是一个helper func，用来定位被kprobe event trigger到的user ID, user ID的前32位是group ID，我们通过32为掩码过滤</span></span><br><span class="line">    uid = bpf_get_current_uid_gid() &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    p = counter_table.lookup(&amp;uid); <span class="comment">// 查询hash表，找到对应key为uid的value，返回的p是指向value的指针</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123; <span class="comment">// 之前已经记过数</span></span><br><span class="line">        counter = *p;</span><br><span class="line">    &#125;</span><br><span class="line">    counter ++;</span><br><span class="line">    counter_table.update(&amp;uid, &amp;counter); <span class="comment">// 更新hash表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们仔细观察这段“C”代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = counter_table.lookup(&amp;uid);</span><br><span class="line">counter_table.update(&amp;uid, &amp;counter);</span><br></pre></td></tr></table></figure><p>熟悉C语言的同学可能会发现，C语言是不能这样定义结构体方法的，C语言不能在struct中直接定义出方法体，需要通过函数指针，来指向某个方法（C++支持class，倒是可以）。这里其实可以理解成是BCC的语法糖，在BCC编译这段C代码时，会通过一些macros将代码转化为标准C语言，来简化编码过程（点个赞）。</p><p>接下来，我们将用户态程序补完：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load BPF program</span></span><br><span class="line">b = BPF(text=program)</span><br><span class="line">syscall = b.get_syscall_fnname(<span class="string">&quot;execve&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=syscall, fn_name=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>: <span class="comment"># 死循传，每2秒输出一次</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> b[<span class="string">&quot;counter_table&quot;</span>].items(): <span class="comment"># 从BPF object中获取couter_table的map，输出uid和counter</span></span><br><span class="line">        s += <span class="string">f&quot;ID <span class="subst">&#123;k.value&#125;</span>: <span class="subst">&#123;v.value&#125;</span>\t&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>跑一下：</p><p><img src="/images/image-20230519145005788.png" alt="image-20230519145005788"></p><p>我用ID为1000的用户执行了2次”ls”命令，可以看到，ID 1000用户被记录下了2次<code>execve</code>的系统调用。</p><p>在这个例子里，我们使用了int类型作为hash表的key，所以当key小于4字节时，会转换为arrary，而hash表可以支持任何形式的key。hash表在k-v场景里很好用，但用户态程序必须要轮训hash表才可以获取数据。</p><p>Kernel支持perfbuf（per-CPU环形缓存区），来将数据从内核态传到用户态，在eBPF中可以采用它，同样包括它的升级版：BPF ring buffer（非per-CPU，解决并行下不一致问题，需要内核版本5.8以上），其解决了perfbuf内存效率低下以及事件顺序不一致的问题。</p><h4 id="2-3-4-Perf-and-Ring-Buffer-Maps"><a href="#2-3-4-Perf-and-Ring-Buffer-Maps" class="headerlink" title="2.3.4.Perf and Ring Buffer Maps"></a>2.3.4.Perf and Ring Buffer Maps</h4><p>关于Ring Buffer（如果你已经知道什么是Ring Buffer，可以跳过）：</p><p><em>Ring Buffer和BPF的概念无关，你可以将Ring Buffer想象成由将一块内存按一定的逻辑构成的一个环（由于计算机内存地址是线性的，需要特别的算法设计才可以从逻辑上实现），这个有一个独立的写指针和一个读指针。数据的长度会包含在数据的header中，程序会从写指针的位置（最初的位置无关紧要）将数据写入Ring Buffer（包含数据长度），接着，写指针移动x位（x为数据长度）。</em></p><p><em>而读取时，程序在读指针的位置读取数据，根据写入时包含的数据长度，移动x位</em>。</p><p><em>当读指针追上写指针时，代表数据读完了；如果写操作使写指针追上了读指针，则数据会被丢弃，且将丢弃计数器（drop counter）自增，通过读操作和丢弃计数器就能知道自上次成功读取数据后，是否有数据被丢弃</em>。</p><p><em>如果写入速率和读取速率一致，那不需要调整缓冲区大小，否则，为了不让数据被丢弃（一般来说，业务会处理位阻塞），我们需要动态调整缓冲区大小。</em></p><img src="/images/v2-846878d6005f23f9f15afde8fe0ae028_b.gif" alt="动图" style="zoom:50%;" /><p>下面我们以<code>Perf Buffer</code>为例，来将“hello world”进行一版改进，不再将<code>execve</code>写入trace文件，而通过<code>Perf Buffer</code>来传递。</p><p>BPF程序代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BPF_PERF_OUTPUT(output); <span class="comment">// BPF Perf Buffer的macro，用于定义从Kernel Space往User Space传递信息的map, map的key为output</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span> <span class="comment">// 定义存储信息的结构体</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">char</span> command[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">12</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123;&#125;; </span><br><span class="line">   <span class="keyword">char</span> message[<span class="number">12</span>] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">   data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>; <span class="comment">// bpf_get_current_pid_tgid()是一个helper func，前32位用存储进程的ID，后32位存储进行group ID，将前32位右移</span></span><br><span class="line">   data.uid = bpf_get_current_uid_gid() &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">   </span><br><span class="line">   bpf_get_current_comm(&amp;data.command, <span class="keyword">sizeof</span>(data.command)); <span class="comment">// 获取command或执行程序的helper func，通过地址传递给data.command</span></span><br><span class="line">   bpf_probe_read_kernel(&amp;data.message, <span class="keyword">sizeof</span>(data.message), message); <span class="comment">// 在这里例子里，在内核中的message“Hello Wrold”，被传递到data结构体中</span></span><br><span class="line"> </span><br><span class="line">   output.perf_submit(ctx, &amp;data, <span class="keyword">sizeof</span>(data)); <span class="comment">//将data塞到map中</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户态Python代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load BPF program</span></span><br><span class="line">b = BPF(text=program)</span><br><span class="line">syscall = b.get_syscall_fnname(<span class="string">&quot;execve&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=syscall, fn_name=<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_event</span>(<span class="params">cpu, data, size</span>):</span>  <span class="comment"># print_event是一个回调函数，用于在屏幕上打印一行输出</span></span><br><span class="line">   data = b[<span class="string">&quot;output&quot;</span>].event(data) <span class="comment"># BCC做了高度抽象，将在BPF map中可以直接提取output,以及out中的data结构体</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;data.pid&#125;</span> <span class="subst">&#123;data.uid&#125;</span> <span class="subst">&#123;data.command.decode()&#125;</span> <span class="subst">&#123;data.message.decode()&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line">b[<span class="string">&quot;output&quot;</span>].open_perf_buffer(print_event) <span class="comment"># 打开perf buffer，通过print_event回调函数结构read的信息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:   <span class="comment"># 死循环，开始执行perf poll</span></span><br><span class="line">   b.perf_buffer_poll()</span><br></pre></td></tr></table></figure><p>跑一下：</p><p><img src="/images/image-20230522111340994.png" alt="image-20230522111340994"></p><p>在这个例子中，我们通过了名为”output”的ring map来将数据从Kernel传到User Space，这个ring map只能给这个程序本身用，这和案例一中采用trace文件时完全不同的，在<code>/sys/kernel/debug/tracing/trace_pipe</code>文件中，无法找到对应的上下文信息：</p><p><img src="/images/image-20230522111612212.png" alt="image-20230522111612212"></p><p>Tips：Ring Buffer相较于Perf Buffer具备更小的内存占用，以及由于采用多核共享内存，解决了per-CPU的数据一致性问题。通过BCC实现Ring Buffer版本的Hello World和Perf Buffer其实区别不大，你可以根据<a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#5-bpf_ringbuf_output">BCC接口文档</a>自己尝试将Perf Buffer换成Ring Buffer </p><h4 id="2-3-5-Function-Callls"><a href="#2-3-5-Function-Callls" class="headerlink" title="2.3.5.Function Callls"></a>2.3.5.Function Callls</h4><p>从上面几个例子可以看到，在BPF程序中，我们调用了很多Kernel的helper function，从程序编写的风格上说，我们应该将自己的公共代码逻辑也包装为函数。当在BPF程序的早期，BPF程序是不允许调用除了helper function以外其他函数的（进栈限制），这就给编码带来了很多不便，所以，早期采用了一种workaround的方式来处理。（总是定义内联函数）“Always inline“：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inlinevoid <span class="title">my_function</span><span class="params">(<span class="keyword">void</span> *ctx, <span class="keyword">int</span> val)</span></span></span><br></pre></td></tr></table></figure><p>内联函数是C语言中可以定义的一种特殊函数，一般来说，函数被编译后的执行方式是“函数初始位置（堆） - &gt; 执行函数（进栈） -&gt; 返回初始位置（出栈，返回堆）”。当使用内联函数时，编译器会将函数代码指令直接复制到堆中。</p><p><img src="/images/image-20230522124958075.png" alt="image-20230522124958075"></p><p>实际上，由于编译器的优化，一些内联函数会被强制编译为栈函数，而一些栈函数也会被强制编译为内联函数（所以有些Kernel function没法被kprobe attatch），这会导致我们在使用内联上存在一定的问题。</p><p>在Kernel 4.16（LLVM 6.0）后，内核取消了对函数栈调用的限制，不需要通过“Always inline”的方式来workaround了，这个特性被称为“BPF function calls”或者“BPF subprograms”（BPF子程序）。但目前BCC框架并不支持类型BPF function calls的功能，取而代之的将复杂能力分解的方式：tail calls。</p><h4 id="2-3-6-Tail-Calls"><a href="#2-3-6-Tail-Calls" class="headerlink" title="2.3.6.Tail Calls"></a>2.3.6.Tail Calls</h4><p>Tail Calls（尾调用）能够调用或者执行其他eBPF程序并且替换执行上下文信息，与<code>execve()</code>这个系统调用给常规进程使用类似。换句话说，执行程序在tail call完成前不会返回。</p><p><em>Tips: <a href="https://www.baeldung.com/cs/tail-vs-non-tail-recursion">Tail Calls</a>不是eBPF独有的概念，因为我们在其他地方一般会说另一个词：Tail Recursion（尾递归）。其提出的主要解决的问题是防止函数被递归调用时，反复向栈中添加栈帧（frames），最终导致堆栈溢出。而使用尾递归时，由于递归函数是当前当前堆栈中最后一条待执行语句，当这个调用返回后，当前栈帧中将无事可做，也就没有保留栈帧的必要了，于是就可以直接覆盖当前的栈帧，而不是添加栈帧，这样大大缩减了栈空间的大小，使得实际运行效率变高。在eBPF中，堆栈大小被限制在了512 bytes，所以Tail Calls可以解决很多问题</em>。</p><p>Tail Calls使用<code>bpf_tail_call()</code>这个helper function来定义，函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">bpf_tail_call</span><span class="params">(<span class="keyword">void</span> *ctx, structbpf_map *prog_array_map, u32 index)</span></span></span><br></pre></td></tr></table></figure><p>函数中的三个参数的意义如下：</p><p>1.<code>ctx</code>：eBPF函数调用者和eBPF程序直接的上下文信息。</p><p>2.<code>prog_arryry_map</code>：<code>BPF_MAP_TYPE_PROG_ARRAY</code>类型的eBPF map，维护eBPF程序的一组文件描述符。</p><p>3.<code>index</code>：<code>index</code>表示哪一组eBPF程序需要被调用。</p><p>Tail call用法比较有意思，eBPF通过tail call调用成功后，不会返回原来的eBPF程序，因为tail call会重用调用方函数的栈帧。但是在失败的时候还是会返回，比如指定的程序不在map里，此时原函数还是能继续执行。</p><p>对于用户态程序来说，还是和之前一样，将eBPF程序加载到Kernel，并且创建程序的array map。</p><p>下面我们来尝试写一个tail call的例子。在例子中，eBPF程序attach到一个tracepoint，来监听所有的系统调用，并通过tail calls将特定opcode的syscall以特定的信息输出，其他的输出通用信息。</p><p>当使用BCC框架时，可以采用一行简单的方式来定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog_array_map.call(ctx, index)</span><br></pre></td></tr></table></figure><p>在编译时，BCC会将这行重写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_tail_call(ctx, prog_array_map, index)</span><br></pre></td></tr></table></figure><p>BPF程序代码如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BPF_PROG_ARRAY(syscall, <span class="number">300</span>); <span class="comment">// BCC提供BPF_PROG_ARRAY的macro，可以相对方便地定义一个BPF_MAP_TYPE_PROG_ARRAY的map（linux中总共有300种syscall，这个基本够了）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">(struct bpf_raw_tracepoint_args *ctx)</span> </span>&#123; <span class="comment">// hello函数的参数不是某个具体的系统调用，而是raw_tracepoint，下面的用户态程序选择sys_enter的raw tracepoint时，所有的系统调用都会被ctx接收</span></span><br><span class="line">    <span class="keyword">int</span> opcode = ctx-&gt;args[<span class="number">1</span>];  <span class="comment">// 提取bpf_raw_tracepoint_args struct中的opcod</span></span><br><span class="line">    syscall.call(ctx, opcode); <span class="comment">// 这里通过tail call在program array中，找到将符合opcode的程序，并调用. 这里在编译的时候会被BCC重写为bpf_tail_call()</span></span><br><span class="line">    bpf_trace_printk(<span class="string">&quot;Another syscall: %d&quot;</span>, opcode); <span class="comment">// tail call失败的case，如果tail call成功了，这里不会执行，表示opcode没有hit</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_exec</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123; <span class="comment">// hello_exec()是加载到syscall array map中的一个程序，当opcode为 execve()syscall时，它将被tail call调用</span></span><br><span class="line">    bpf_trace_printk(<span class="string">&quot;Executing a program&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_timer</span><span class="params">(struct bpf_raw_tracepoint_args *ctx)</span> </span>&#123; <span class="comment">// hello_timeer也是一个加载到syscall array map中的一个程序，用于处理其他opcode的情况</span></span><br><span class="line">    <span class="keyword">int</span> opcode = ctx-&gt;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">222</span>:</span><br><span class="line">            bpf_trace_printk(<span class="string">&quot;Creating a timer&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">226</span>:</span><br><span class="line">            bpf_trace_printk(<span class="string">&quot;Deleting a timer&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            bpf_trace_printk(<span class="string">&quot;Some other timer operation&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ignore_opcode</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123; <span class="comment">// 为了过滤不想输出的opcode</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户态Python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">b = BPF(text=program)</span><br><span class="line">b.attach_raw_tracepoint(tp=<span class="string">&quot;sys_enter&quot;</span>, fn_name=<span class="string">&quot;hello&quot;</span>) <span class="comment"># 使用sys_enter的tracepoint取代kprobe，以观察所有的sys_enter</span></span><br><span class="line"></span><br><span class="line">ignore_fn = b.load_func(<span class="string">&quot;ignore_opcode&quot;</span>, BPF.RAW_TRACEPOINT) <span class="comment"># b.load_func()会返回tail call程序的文件描述符，需要注意的是，taill calls函数需要和父程序使用同样的程序类型，在这里是BPF.RAW_TRACEPOINT，不能使用kprobe</span></span><br><span class="line">exec_fn = b.load_func(<span class="string">&quot;hello_exec&quot;</span>, BPF.RAW_TRACEPOINT)</span><br><span class="line">timer_fn = b.load_func(<span class="string">&quot;hello_timer&quot;</span>, BPF.RAW_TRACEPOINT)</span><br><span class="line"></span><br><span class="line">prog_array = b.get_table(<span class="string">&quot;syscall&quot;</span>) <span class="comment"># 用户态程序在syscall map中加入元素，将对应tail call程序的文件描述符和opcode一一映射</span></span><br><span class="line">prog_array[ct.c_int(<span class="number">59</span>)] = ct.c_int(exec_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">222</span>)] = ct.c_int(timer_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">223</span>)] = ct.c_int(timer_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">224</span>)] = ct.c_int(timer_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">225</span>)] = ct.c_int(timer_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">226</span>)] = ct.c_int(timer_fn.fd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore some syscalls that come up a lot</span></span><br><span class="line">prog_array[ct.c_int(<span class="number">21</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">22</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">25</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">29</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">56</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">57</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">63</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">64</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">66</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">72</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">73</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">79</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">98</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">101</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">115</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">131</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">134</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">135</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">139</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">172</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">233</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">291</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">212</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">260</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">94</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line">prog_array[ct.c_int(<span class="number">221</span>)] = ct.c_int(ignore_fn.fd)</span><br><span class="line"></span><br><span class="line">b.trace_print() <span class="comment"># 打印trace信息</span></span><br></pre></td></tr></table></figure><p>跑一下：</p><p><img src="/images/image-20230522155022177.png" alt="image-20230522155022177"></p><p>需要注意的是，Tail Calls在Kernel版本4.2后被支持，在5.10之前和BPF function call是不兼容的，在eBPF subprogram中调用tail calls依赖JIT编译（x86 5.10, arm 6.0）。</p><h2 id="3-深入解析eBPF程序"><a href="#3-深入解析eBPF程序" class="headerlink" title="3.深入解析eBPF程序"></a>3.深入解析eBPF程序</h2><p>在实际大型项目中，除了通过BCC框架，我们仍然需要编写相对复杂的原生eBPF程序。本章中，我们会使用完整的C代码来编写“Hello World”。</p><p>一个eBPF程序实际上是一组eBPF字节码指令，一般会通过高级语言编写（当然你可以直接写字节码～），最终编译为eBPF字节码。eBPF程序用的最多的高级语言是C，也有一些eBPF程序用Rust编写，因为Rust编译器也支持eBPF字节码：</p><p><img src="/images/image-20230522160351303.png" alt="image-20230522160351303"></p><p>字节码最终会跑在kernel的eBPF虚拟机中。</p><h3 id="3-1-The-eBPF-Virtual-Machine"><a href="#3-1-The-eBPF-Virtual-Machine" class="headerlink" title="3.1.The eBPF Virtual Machine"></a>3.1.The eBPF Virtual Machine</h3><p>eBPF虚拟机和其他虚拟机一样，是通过软件实现的一个计算机。在这个“计算机”里，能够运行eBPF的字节码指令，这些字节码指令最终会转化为在CPU上跑的原生机器指令。</p><p>在eBPF的早期实现中，eBPF字节码会直接被Kernel解析，一旦eBPF程序开始运行，Kernel会检查eBPF字节码并将其转换为机器码，然后再执行。目前，处于性能和安全性考虑，Kernel的字节码解释器已经被JIT（Just In Time）编译所取代，这意味着在程序被加载到内核时，只会被转换一次（即编译）。</p><p>eBPF字节码包含一组指令，这些指令会运行在eBPF（虚拟）寄存器（eBPF registers）上。eBPF指令集和寄存器模型与通用CPU架构相匹配，这样编译机器码的过程相对比较简单。</p><h4 id="3-1-1-eBPF-Registers"><a href="#3-1-1-eBPF-Registers" class="headerlink" title="3.1.1.eBPF Registers"></a>3.1.1.eBPF Registers</h4><p>eBPF虚拟机有10个一般用途的寄存器（0～9），还有一个10号寄存器，用来充当栈帧指针（只能读，不能写）。当BPF程序运行时，值会被存储到这些寄存器汇总以持续记录状态。</p><p>和CPU寄存器不同，这些寄存器是通过软件方式实现的，可以在<a href="https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h">Kernel代码</a>中找到。</p><p>eBPF程序运行前，上下文参数会被加载到Register 1，返回值则会存储到Register 0。</p><p>在调用eBPF代码中函数前，函数的参数会存储到Register1到5中（如果低于5个参数，则其他寄存器不会使用）。</p><h4 id="3-1-2-eBPF-Instructions"><a href="#3-1-2-eBPF-Instructions" class="headerlink" title="3.1.2.eBPF Instructions"></a>3.1.2.eBPF Instructions</h4><p>在 Kernel 的ebpf的<a href="https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L71">header代码</a>中定义了一个名为<code>bpf_insn</code>的结构体，来描述eBPF指令（Instrcutions）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct bpf_insn &#123;</span><br><span class="line">__u8code;&#x2F;* opcode *&#x2F;</span><br><span class="line">__u8dst_reg:4;&#x2F;* dest register *&#x2F;</span><br><span class="line">__u8src_reg:4;&#x2F;* source register *&#x2F;</span><br><span class="line">__s16off;&#x2F;* signed offset *&#x2F;</span><br><span class="line">__s32imm;&#x2F;* signed immediate constant *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bpf_insn</code>结构体的操作码（opcode）分为这几类：</p><p>1.将值加载到寄存器</p><p>2.将值从寄存器存储到内存</p><p>3.进行算术操作</p><p>4.当条件满足时，跳跃到不同的寄存器</p><p>接下来，我们来尝试编写一个具体的例子。</p><h4 id="3-1-3-“Hello-World”-for-a-Network-Interface"><a href="#3-1-3-“Hello-World”-for-a-Network-Interface" class="headerlink" title="3.1.3.“Hello World” for a Network Interface"></a>3.1.3.“Hello World” for a Network Interface</h4><p>之前的例子，我们通过eBPF来观测系统调用相关的情况，这次，我们来观测下网络数据包相关的情况。</p><p>数据包处理是eBPF应用最多的场景，eBPF可以对每个经过网卡的数据包进行过滤、解析，甚至修改数据包的内容。</p><p>下面我们来编写eBPF程序代码，在这个例子中，我们只对数据包计数，二不会对数据包进行任何修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span> <span class="comment">// 引用bpf头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 定义自增计数器全局变量</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;xdp&quot;</span>) <span class="comment">// SEC 是一个 macro，用于定义eBPF程序类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123; <span class="comment">// 这是eBPF程序的主体，eBPF的程序名和函数名一致，即hello</span></span><br><span class="line">    bpf_printk(<span class="string">&quot;Hello World %d&quot;</span>, counter); <span class="comment">// 这里使用了bpf_printk()的helper function，来打印信息，和之前的bpf_trace_printk()一样，而后者是BCC框架提供的</span></span><br><span class="line">    counter++; </span><br><span class="line">    <span class="keyword">return</span> XDP_PASS; <span class="comment">// XDP_PASS是向Kernel指明，该数据包字节交给Kernel，以一般数据的方式处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>; <span class="comment">// eBPF程序license声明，当调用的helper function是GPL license时，必须在你的代码中声明GPL license，否则会无法使用</span></span><br></pre></td></tr></table></figure><p>这里例子中，我们将eBPF程序attach到了XDP hook point上，你可以理解为，一旦数据包通过网卡，XDP event就会被触发。</p><p><em>Tips：有些网卡可以直接运行XDP程序，这使得数据包在到达CPU之前就可以被处理，对于性能的提升会非常大。</em></p><p>OK，那接下来，我们把这段代码编译一下。</p><h4 id="3-1-4-Compiling-an-eBPF-Object-File"><a href="#3-1-4-Compiling-an-eBPF-Object-File" class="headerlink" title="3.1.4.Compiling an eBPF Object File"></a>3.1.4.Compiling an eBPF Object File</h4><p>eBPF源码需要编译为机器码（eBPF字节码）才能在eBPF虚拟机上运行。我们可以通过clang来进行编译，Makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TARGETS = hello hello-func</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGETS)</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGETS)</span>: %: %.bpf.o </span><br><span class="line"></span><br><span class="line"><span class="section">%.bpf.o: %.bpf.c</span></span><br><span class="line">clang \</span><br><span class="line">    -target bpf \</span><br><span class="line">-I/usr/<span class="keyword">include</span>/<span class="variable">$(<span class="built_in">shell</span> uname -m)</span>-linux-gnu \</span><br><span class="line">-g \</span><br><span class="line">    -O2 -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">- rm *.bpf.o</span><br><span class="line">- rm -f /sys/fs/bpf/hello </span><br><span class="line">- rm -f /sys/fs/bpf/hello-func</span><br></pre></td></tr></table></figure><p>可能需要装一些依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y apt-transport-https ca-certificates curl clang llvm jq</span><br><span class="line">apt-get install -y libelf-dev libpcap-dev libbfd-dev binutils-dev build-essential make </span><br><span class="line">apt-get install -y linux-tools-common linux-tools-5.15.0-41-generic bpfcc-tools</span><br><span class="line">apt install -y libbpf-dev</span><br></pre></td></tr></table></figure><p>执行编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make hello-net.bpf.o</span><br></pre></td></tr></table></figure><h4 id="3-1-5-Inspecting-an-eBPF-Object-File"><a href="#3-1-5-Inspecting-an-eBPF-Object-File" class="headerlink" title="3.1.5.Inspecting an eBPF Object File"></a>3.1.5.Inspecting an eBPF Object File</h4><p>我们可以通过<code>file</code>命令来看下对象文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file hello-net.bpf.o </span></span><br><span class="line">hello-net.bpf.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), with debug_info, not stripped</span><br></pre></td></tr></table></figure><p>可以看到，eBPF的对象文件是一个ELF（Excutable and Linkable Format）文件，包含eBPF标识码，对应64位LSB（Least significant bit）架构。</p><p>我们可以还可以通过<code>llvm-objdmp</code>命令来看更详细反编译信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># llvm-objdump -S hello-net.bpf.o </span></span><br><span class="line"></span><br><span class="line">hello-net.bpf.o:        file format elf64-bpf</span><br><span class="line"></span><br><span class="line">Disassembly of section xdp:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;hello&gt;:</span><br><span class="line">; int hello(struct xdp_md *ctx) &#123;</span><br><span class="line">       0:       b7 01 00 00 00 00 00 00 r1 = 0</span><br><span class="line">;     bpf_printk(<span class="string">&quot;Hello World %d&quot;</span>, counter);</span><br><span class="line">       1:       73 1a fe ff 00 00 00 00 *(u8 *)(r10 - 2) = r1</span><br><span class="line">       2:       b7 01 00 00 25 64 00 00 r1 = 25637</span><br><span class="line">       3:       6b 1a <span class="built_in">fc</span> ff 00 00 00 00 *(u16 *)(r10 - 4) = r1</span><br><span class="line">       4:       b7 01 00 00 72 6c 64 20 r1 = 543452274</span><br><span class="line">       5:       63 1a f8 ff 00 00 00 00 *(u32 *)(r10 - 8) = r1</span><br><span class="line">       6:       18 01 00 00 48 65 6c 6c 00 00 00 00 6f 20 57 6f r1 = 8022916924116329800 ll</span><br><span class="line">       8:       7b 1a f0 ff 00 00 00 00 *(u64 *)(r10 - 16) = r1</span><br><span class="line">       9:       18 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r6 = 0 ll</span><br><span class="line">      11:       61 63 00 00 00 00 00 00 r3 = *(u32 *)(r6 + 0)</span><br><span class="line">      12:       bf a1 00 00 00 00 00 00 r1 = r10</span><br><span class="line">      13:       07 01 00 00 f0 ff ff ff r1 += -16</span><br><span class="line">;     bpf_printk(<span class="string">&quot;Hello World %d&quot;</span>, counter);</span><br><span class="line">      14:       b7 02 00 00 0f 00 00 00 r2 = 15</span><br><span class="line">      15:       85 00 00 00 06 00 00 00 call 6</span><br><span class="line">;     counter++; </span><br><span class="line">      16:       61 61 00 00 00 00 00 00 r1 = *(u32 *)(r6 + 0)</span><br><span class="line">      17:       07 01 00 00 01 00 00 00 r1 += 1</span><br><span class="line">      18:       63 16 00 00 00 00 00 00 *(u32 *)(r6 + 0) = r1</span><br><span class="line">;     <span class="built_in">return</span> XDP_PASS;</span><br><span class="line">      19:       b7 00 00 00 02 00 00 00 r0 = 2</span><br><span class="line">      20:       95 00 00 00 00 00 00 00 <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>基本上是一些寄存器的指令操作，通过opcode，设置值到对应的寄存器，例如这里的<code>0xb7</code>，这里不展示讨论了，有兴趣的同学可以参考下eBPF指令集：<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt%E3%80%82">https://www.kernel.org/doc/Documentation/networking/filter.txt。</a></p><h4 id="3-1-6-Loading-the-Program-into-the-Kernel"><a href="#3-1-6-Loading-the-Program-into-the-Kernel" class="headerlink" title="3.1.6.Loading the Program into the Kernel"></a>3.1.6.Loading the Program into the Kernel</h4><p>我们可以通过<code>bpftool</code>工具来将程序加载到Kernel中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bpftool prog load hello-net.bpf.o /sys/fs/bpf/hello</span></span><br></pre></td></tr></table></figure><p>通过<code>bpftool</code>工具可以列出所有加载到Kernel中的eBPF程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># bpftool prog list</span><br><span class="line">...</span><br><span class="line">14: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2023-05-24T02:46:54+0000  uid 0</span><br><span class="line">        xlated 64B  jited 96B  memlock 4096B</span><br><span class="line">27: xdp  name hello  tag 4ae0216d65106432  gpl</span><br><span class="line">        loaded_at 2023-05-24T10:39:28+0000  uid 0</span><br><span class="line">        xlated 168B  jited 200B  memlock 4096B  map_ids 3</span><br><span class="line">        btf_id 117</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要对eBPF相关进行总结。&lt;/p&gt;</summary>
    
    
    
    
    <category term="system" scheme="http://example.com/tags/system/"/>
    
    <category term="kernel" scheme="http://example.com/tags/kernel/"/>
    
    <category term="network" scheme="http://example.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Go并发-并发原语踩坑</title>
    <link href="http://example.com/2022/07/12/Go%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2022/07/12/Go%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E8%B8%A9%E5%9D%91/</id>
    <published>2022-07-12T02:38:23.000Z</published>
    <updated>2022-11-28T09:22:46.480Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Golang中常用并发原语的一些使用踩坑点。</p><span id="more"></span><h2 id="RWMutex-的-3-个踩坑点"><a href="#RWMutex-的-3-个踩坑点" class="headerlink" title="RWMutex 的 3 个踩坑点"></a>RWMutex 的 3 个踩坑点</h2><h3 id="1：不可复制"><a href="#1：不可复制" class="headerlink" title="1：不可复制"></a><strong>1：不可复制</strong></h3><p>不能复制的原因和互斥锁一样。一旦读写锁被使用，它的字段就会记录它当前的一些状态。这个时候你去复制这把锁，就会把它的状态也给复制过来。但是，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁。</p><h3 id="2：重入导致死锁"><a href="#2：重入导致死锁" class="headerlink" title="2：重入导致死锁"></a><strong>2：重入导致死锁</strong></h3><p>读写锁因为重入（或递归调用）导致死锁（deadlock）的情况更多。</p><p>死锁三种情况：</p><ul><li>第一种情况：读写锁内部基于互斥锁实现对 writer 的并发访问，而互斥锁本身是有重入问题的，所以，writer 重入调用 Lock 的时候，就会出现死锁的现象。</li><li>第二种情况：我们知道，有活跃 reader 的时候，writer 会等待，如果我们在 reader 的读操作时调用 writer 的写操作（它会调用 Lock 方法），那么，这个 reader 和 writer 就会形成互相依赖的死锁状态。Reader 想等待 writer 完成后再释放锁，而 writer 需要这个 reader 释放锁之后，才能不阻塞地继续执行。这是一个读写锁常见的死锁场景。</li><li>第三种情况：当一个 writer 请求锁的时候，如果已经有一些活跃的 reader，它会等待这些活跃的 reader 完成，才有可能获取到锁，但是，如果之后活跃的 reader 再依赖新的 reader 的话，这些新的 reader 就会等待 writer 释放锁之后才能继续执行，这就形成了一个环形依赖： writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer,稍微等待，然后制造一个调用Lock的场景</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">        mu.Lock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Lock&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Unlock&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        factorial(&amp;mu, <span class="number">10</span>) <span class="comment">// 计算10的阶乘, 10!</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用计算阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(m *sync.RWMutex, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> &#123; <span class="comment">// 阶乘退出条件 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;RLock&quot;</span>)</span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;RUnlock&quot;</span>)</span><br><span class="line">        m.RUnlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> factorial(m, n<span class="number">-1</span>) * n <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>factoria 方法是一个递归计算阶乘的方法，我们用它来模拟 reader。为了更容易地制造出死锁场景，在这里加上了 sleep 的调用，延缓逻辑的执行。这个方法会调用读锁（第 27 行），在第 33 行递归地调用此方法，每次调用都会产生一次读锁的调用，所以可以不断地产生读锁的调用，而且必须等到新请求的读锁释放，这个读锁才能释放。</p><p>同时，我们使用另一个 goroutine 去调用 Lock 方法，来实现 writer，这个 writer 会等待 200 毫秒后才会调用 Lock，这样在调用 Lock 的时候，factoria 方法还在执行中不断调用 RLock。这两个 goroutine 互相持有锁并等待，谁也不会退让一步，满足了“writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer”的死锁条件，所以就导致了死锁的产生。</p><h3 id="3：释放未加锁的-RWMutex"><a href="#3：释放未加锁的-RWMutex" class="headerlink" title="3：释放未加锁的 RWMutex"></a><strong>3：释放未加锁的 RWMutex</strong></h3><p>和互斥锁一样，Lock 和 Unlock 的调用总是成对出现的，RLock 和 RUnlock 的调用也必须成对出现。Lock 和 RLock 多余的调用会导致锁没有被释放，可能会出现死锁，而 Unlock 和 RUnlock 多余的调用会导致 panic。在生产环境中出现 panic 是大忌，你总不希望半夜爬起来处理生产环境程序崩溃的问题吧？所以，在使用读写锁的时候，一定要注意，不遗漏不多余。</p><h2 id="WaitGroup的三个踩坑点"><a href="#WaitGroup的三个踩坑点" class="headerlink" title="WaitGroup的三个踩坑点"></a>WaitGroup的三个踩坑点</h2><h3 id="1-计数器设置为负值"><a href="#1-计数器设置为负值" class="headerlink" title="1.计数器设置为负值"></a><strong>1.计数器设置为负值</strong></h3><p>WaitGroup 的计数器的值必须大于等于 0。我们在更改这个计数值的时候，WaitGroup 会先做检查，如果计数值被设置为负数，就会导致 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    wg.Done()</span><br><span class="line"></span><br><span class="line">    wg.Done() <span class="comment">// panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不期望的-Add-时机"><a href="#2-不期望的-Add-时机" class="headerlink" title="2.不期望的 Add 时机"></a><strong>2.不期望的 Add 时机</strong></h3><p>在使用 WaitGroup 的时候，你一定要遵循的原则就是，<strong>等所有的 Add 方法调用之后再调用 Wait</strong>，否则就可能导致 panic 或者不期望的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">go</span> dosomething(<span class="number">100</span>, &amp;wg) <span class="comment">// 启动第一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> dosomething(<span class="number">110</span>, &amp;wg) <span class="comment">// 启动第二个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> dosomething(<span class="number">120</span>, &amp;wg) <span class="comment">// 启动第三个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> dosomething(<span class="number">130</span>, &amp;wg) <span class="comment">// 启动第四个goroutine</span></span><br><span class="line"></span><br><span class="line">    wg.Wait() <span class="comment">// 主goroutine等待完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">(millisecs time.Duration, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    duration := millisecs * time.Millisecond</span><br><span class="line">    time.Sleep(duration) <span class="comment">// 故意sleep一段时间</span></span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>) <span class="comment">// 在goroutine中执行Add，Add在Wait前调用</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;后台执行, duration:&quot;</span>, duration)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-前一个-Wait-还没结束就重用-WaitGroup"><a href="#2-前一个-Wait-还没结束就重用-WaitGroup" class="headerlink" title="2.前一个 Wait 还没结束就重用 WaitGroup"></a><strong>2.前一个 Wait 还没结束就重用 WaitGroup</strong></h3><p>如果我们在 WaitGroup 的计数值还没有恢复到零值的时候就重用，就会导致程序 panic。</p><p>WaitGroup 虽然可以重用，但是是有一个前提的，那就是必须等到上一轮的 Wait 完成之后，才能重用 WaitGroup 执行下一轮的 Add/Wait，如果你在 Wait 还没执行完的时候就调用下一轮 Add 方法，就有可能出现 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Millisecond)</span><br><span class="line">        wg.Done() <span class="comment">// 计数器减1</span></span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 计数值加1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait() <span class="comment">// 主goroutine等待，有可能和第7行并发执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cond踩坑点"><a href="#Cond踩坑点" class="headerlink" title="Cond踩坑点"></a>Cond踩坑点</h2><h3 id="Wait未加锁"><a href="#Wait未加锁" class="headerlink" title="Wait未加锁"></a><strong>Wait未加锁</strong></h3><p>cond.Wait 方法的实现是，把当前调用者加入到 notify 队列之中后会释放锁（如果不释放锁，其他 Wait 的调用者就没有机会加入到 notify 队列中了），然后一直等待；等调用者被唤醒之后，又会去争抢这把锁。如果调用 Wait 之前不加锁的话，就有可能 Unlock 一个未加锁的 Locker。所以切记，调用 cond.Wait 方法之前一定要加锁。</p><h2 id="Once的两个踩坑点"><a href="#Once的两个踩坑点" class="headerlink" title="Once的两个踩坑点"></a>Once的两个踩坑点</h2><h3 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1.死锁"></a><strong>1.死锁</strong></h3><p>Do 方法仅会执行一次 f，但是如果 f 中再次调用这个 Once 的 Do 方法的话，就会导致死锁的情况出现。这还不是无限递归的情况，而是的的确确的 Lock 的递归调用导致的死锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;初始化&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-未实际完成初始化"><a href="#2-未实际完成初始化" class="headerlink" title="2.未实际完成初始化"></a><strong>2.未实际完成初始化</strong></h3><p>如果 f 方法执行的时候 panic，或者 f 执行初始化资源的时候失败了，这个时候，Once 还是会认为初次执行已经成功了，即使再次调用 Do 方法，也不会再次执行 f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    <span class="keyword">var</span> googleConn net.Conn <span class="comment">// 到Google网站的一个连接</span></span><br><span class="line"></span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 建立到google.com的连接，有可能因为网络的原因，googleConn并没有建立成功，此时它的值为nil</span></span><br><span class="line">        googleConn, _ = net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;google.com:80&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 发送http请求</span></span><br><span class="line">    googleConn.Write([]<span class="keyword">byte</span>(<span class="string">&quot;GET / HTTP/1.1\r\nHost: google.com\r\n Accept: */*\r\n\r\n&quot;</span>))</span><br><span class="line">    io.Copy(os.Stdout, googleConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前Go官方建议通过自行扩展的方式，来实现，示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once 是一个扩展的sync.Once类型，提供了一个Done方法</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done 返回此Once是否执行过</span></span><br><span class="line"><span class="comment">// 如果执行过则返回true</span></span><br><span class="line"><span class="comment">// 如果没有执行过或者正在执行，返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.LoadUint32((*<span class="keyword">uint32</span>)(unsafe.Pointer(&amp;o.Once))) == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> flag Once</span><br><span class="line">    fmt.Println(flag.Done()) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    flag.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(flag.Done()) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-Pool的两个踩坑点"><a href="#sync-Pool的两个踩坑点" class="headerlink" title="sync.Pool的两个踩坑点"></a>sync.Pool的两个踩坑点</h2><h3 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1.内存泄漏"></a><strong>1.内存泄漏</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffers = sync.Pool&#123;</span><br><span class="line">  New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBuffer</span><span class="params">()</span> *<span class="title">bytes</span>.<span class="title">Buffer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> buffers.Get().(*bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutBuffer</span><span class="params">(buf *bytes.Buffer)</span></span> &#123;</span><br><span class="line"> <span class="comment">// if buf.Cap() &gt; 1&lt;&lt;16 &#123; // 判定是否为大buffer，防止Pool未回收对象，导致内存泄漏</span></span><br><span class="line"> <span class="comment">//retrun</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line">  buf.Reset()</span><br><span class="line">  buffers.Put(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用buffer pool但不对buf的大小做判断。</p><p>取出来的 bytes.Buffer 在使用的时候，我们可以往这个元素中增加大量的 byte 数据，这会导致底层的 byte slice 的容量可能会变得很大。这个时候，即使 Reset 再放回到池子中，这些 byte slice 的容量不会改变，所占的空间依然很大。而且，因为 Pool 回收的机制，这些大的 Buffer 可能不被回收，而是会一直占用很大的空间，这属于内存泄漏的问题。</p><h3 id="2-内存浪费"><a href="#2-内存浪费" class="headerlink" title="2.内存浪费"></a><strong>2.内存浪费</strong></h3><p>除了内存泄漏以外，还有一种浪费的情况，就是池子中的 buffer 都比较大，但在实际使用的时候，很多时候只需要一个小的 buffer，这也是一种浪费现象。</p><p>要做到物尽其用，尽可能不浪费的话，我们可以将 buffer 池分成几层。首先，小于 512 byte 的元素的 buffer 占一个池子；其次，小于 1K byte 大小的元素占一个池子；再次，小于 4K byte 大小的元素占一个池子。这样分成几个池子以后，就可以根据需要，到所需大小的池子中获取 buffer 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">bufioReaderPool   sync.Pool</span><br><span class="line">bufioWriter2kPool sync.Pool</span><br><span class="line">bufioWriter4kPool sync.Pool</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyBufPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">32</span>*<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;b</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufioWriterPool</span><span class="params">(size <span class="keyword">int</span>)</span> *<span class="title">sync</span>.<span class="title">Pool</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> size &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> &lt;&lt; <span class="number">10</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;bufioWriter2kPool</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> &lt;&lt; <span class="number">10</span>:</span><br><span class="line"><span class="keyword">return</span> &amp;bufioWriter4kPool</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Channel踩坑点"><a href="#Channel踩坑点" class="headerlink" title="Channel踩坑点"></a>Channel踩坑点</h2><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a><strong>panic</strong></h3><p>使用 Channel 最常见的错误是 panic 和 goroutine 泄漏。首先，我们来总结下会 panic 的情况，总共有 3 种：</p><ul><li><strong>close 为 nil 的 chan。</strong></li><li><strong>send 已经 close 的 chan。</strong></li><li><strong>close 已经 close 的 chan。</strong></li></ul><p>除了这三种外，当所有goroutine处于send/recv阻塞时，也会出现死锁（deadlock）panic。</p><h3 id="goroutine泄露"><a href="#goroutine泄露" class="headerlink" title="goroutine泄露"></a><strong>goroutine泄露</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(timeout time.Duration)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟处理耗时的业务</span></span><br><span class="line">        time.Sleep((timeout + time.Second))</span><br><span class="line">        ch &lt;- <span class="literal">true</span> <span class="comment">// block</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;exit goroutine&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> result := &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，process 函数会启动一个 goroutine，去处理需要长时间处理的业务，处理完之后，会发送 true 到 chan 中，目的是通知其它等待的 goroutine，可以继续处理了。</p><p>我们来看一下第 10 行到第 15 行，主 goroutine 接收到任务处理完成的通知，或者超时后就返回了。</p><p>如果发生超时，process 函数就返回了，这就会导致 unbuffered 的 chan 从来就没有被读取。</p><p>unbuffered chan 必须等 reader 和 writer 都准备好了才能交流，否则就会阻塞。超时导致未读，结果就是子 goroutine 就阻塞在第 7 行永远结束不了，进而导致 goroutine 泄漏。</p><p>解决这个 Bug 的办法很简单，就是<strong>将 unbuffered chan 改成容量为 1 的 chan</strong>，这样第 7 行就不会被阻塞了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍Golang中常用并发原语的一些使用踩坑点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Redis云原生设计</title>
    <link href="http://example.com/2022/07/11/Redis%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/07/11/Redis%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-07-11T09:05:04.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    
    
    
    
    <category term="分布式中间件" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>架构设计-有趣的设计模式</title>
    <link href="http://example.com/2022/07/11/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/"/>
    <id>http://example.com/2022/07/11/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/</id>
    <published>2022-07-11T07:57:23.000Z</published>
    <updated>2022-11-28T09:22:46.482Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Go并发-常见并发原语</title>
    <link href="http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/"/>
    <id>http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/</id>
    <published>2022-07-11T07:56:06.000Z</published>
    <updated>2022-11-28T09:22:46.480Z</updated>
    
    <content type="html"><![CDATA[<p>接上文：<a href="https://blog.neilcloud.net/2022/05/12/Go%E5%B9%B6%E5%8F%91/"><strong>Go并发 - 并发原语Mutex、RWMutex</strong></a></p><span id="more"></span><p>上文提到了关于Golang的两个基础并发原语Mutex、RWMutex，接下来我们来介绍下Golang中常见的几个并发原语和并发场景：</p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a><strong>WaitGroup</strong></h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>Add，用来设置 WaitGroup 的计数值。</li><li>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)。</li><li>Wait，调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li></ul><p><strong>example:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全的计数器</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对计数值加一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前的计数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sleep 1秒，然后计数值加1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c *Counter, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    c.Incr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>) <span class="comment">// WaitGroup的值设置为10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// 启动10个goroutine执行加1任务</span></span><br><span class="line">        <span class="keyword">go</span> worker(&amp;counter, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查点，等待goroutine都完成任务</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="comment">// 输出当前计数器的值</span></span><br><span class="line">    fmt.Println(counter.Count())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span></span><br><span class="line">    noCopy noCopy</span><br><span class="line">    <span class="comment">// 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数</span></span><br><span class="line">    <span class="comment">// 另外32bit是用作信号量的</span></span><br><span class="line">    <span class="comment">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法</span></span><br><span class="line">    <span class="comment">// 总之，会找到对齐的那64bit作为state，其余的32bit做信号量</span></span><br><span class="line">    state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span></span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>noCopy 的辅助字段，主要就是<strong>辅助 vet 工具检查是否通过 copy 赋值（实际工程中也能使用这个技巧）</strong>这个 WaitGroup 实例。</li><li>state1，一个具有复合意义的字段，包含 WaitGroup 的计数、阻塞在检查点的 waiter 数和信号量。因为对 64 位整数的原子操作要求整数的地址是 64 位对齐的，所以针对 64 位和 32 位环境的 state 字段的组成是不一样的。</li></ul><p><strong>Add方法逻辑：</strong>Add 方法主要操作的是 state 的计数部分。你可以为计数值增加一个 delta 值，内部通过原子操作把这个值加到计数值上。需要注意的是，这个 delta 也可以是个负数，相当于为计数值减去一个值，Done 方法内部其实就是通过 Add(-1) 实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    <span class="comment">// 高32bit是计数值v，所以把delta左移32，增加到计数上</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// 当前计数值</span></span><br><span class="line">    w := <span class="keyword">uint32</span>(state) <span class="comment">// waiter count</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果计数值v为0并且waiter的数量w不为0，那么state的值就是waiter的数量</span></span><br><span class="line">    <span class="comment">// 将waiter的数量设置为0，因为计数值v也是0,所以它们俩的组合*statep直接设置为0即可。此时需要并唤醒所有的waiter</span></span><br><span class="line">    *statep = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Done方法实际就是计数器减1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wait 方法的实现逻辑：</strong>不断检查 state 的值。如果其中的计数值变为了 0，那么说明所有的任务已完成，调用者不必再等待，直接返回。如果计数值大于 0，说明此时还有任务没完成，那么调用者就变成了等待者，需要加入 waiter 队列，并且阻塞住自己。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    statep, semap := wg.state()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(statep)</span><br><span class="line">        v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>) <span class="comment">// 当前计数值</span></span><br><span class="line">        w := <span class="keyword">uint32</span>(state) <span class="comment">// waiter的数量</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果计数值为0, 调用这个方法的goroutine不必再等待，继续执行它后面的逻辑即可</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则把waiter数量加1。期间可能有并发调用Wait的情况，所以最外层使用了一个for循环</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞休眠等待</span></span><br><span class="line">            runtime_Semacquire(semap)</span><br><span class="line">            <span class="comment">// 被唤醒，不再阻塞，返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a><strong>Cond</strong></h2><p>Cond并不常用，一般用在需要在唤醒一个或者所有的等待者做一些检查操作的时候（等待/通知（wait/notify）机制）。</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">NeWCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>Signal ：</strong>允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。在其他编程语言中，比如 Java 语言中，Signal 方法也被叫做 notify 方法。调用 Signal 方法时，不强求你一定要持有 c.L 的锁。</p><p><strong>Broadcast：</strong>允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语言中，比如 Java 语言中，Broadcast 方法也被叫做 notifyAll 方法。同样地，调用 Broadcast 方法时，也不强求你一定持有 c.L 的锁。</p><p><strong>Wait：</strong>会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。</p><p>Cond包含一个Mutex对象作为参数，在使用时需要进行初始化操作。</p><p><strong>example：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> ready <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Int63n(<span class="number">10</span>)) * time.Second)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁更改等待条件</span></span><br><span class="line">            c.L.Lock()</span><br><span class="line">            ready++</span><br><span class="line">            c.L.Unlock()</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">&quot;等待者#%d 已准备就绪\n&quot;</span>, i)</span><br><span class="line">            <span class="comment">// 广播唤醒所有的等待者</span></span><br><span class="line">            c.Broadcast()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> ready != <span class="number">10</span> &#123;</span><br><span class="line">        c.Wait()</span><br><span class="line">        log.Println(<span class="string">&quot;等待者唤醒一次&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的goroutine是否就绪</span></span><br><span class="line">    log.Println(<span class="string">&quot;所有等待者都准备就绪&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a><strong>Once</strong></h2><p>Once使用比较简单，一般在进行单例对象（如数据库链接、配置对象等）初始化时使用。</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p>当我们需要初始化单例对象时，可以通过定义package级别的变量或者在init、main函数开始执行的时候执行一个初始化函数，这些方式都是线程安全的，但很多时候我们需要进行<strong>延迟初始化</strong>。</p><p><strong>Once包含方法：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个初始化函数</span></span><br><span class="line">    f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;in f1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    once.Do(f1) <span class="comment">// 打印出 in f1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个初始化函数</span></span><br><span class="line">    f2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;in f2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    once.Do(f2) <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当且仅当第一次调用 Do 方法的时候参数 f 才会执行，即使第二次、第三次、第 n 次调用时 f 参数的值不一样，也不会被执行，比如下面的例子，虽然 f1 和 f2 是不同的函数，但是第二个函数 f2 就不会执行。</p><p><strong>典型使用场景：</strong></p><p>cache初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span> *<span class="title">Cache</span></span> &#123; <span class="comment">// 获取默认的Cache</span></span><br><span class="line">    defaultOnce.Do(initDefaultCache) <span class="comment">// 初始化cache</span></span><br><span class="line">    <span class="keyword">return</span> defaultCache</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个全局的cache变量，使用Once初始化，所以也定义了一个Once变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    defaultOnce  sync.Once</span><br><span class="line">    defaultCache *Cache</span><br><span class="line">  )</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDefaultCache</span><span class="params">()</span></span> &#123; <span class="comment">//初始化cache,也就是Once.Do使用的f函数</span></span><br><span class="line">    ......</span><br><span class="line">    defaultCache = c</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它一些Once初始化的变量，比如defaultDir</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    defaultDirOnce sync.Once</span><br><span class="line">    defaultDir     <span class="keyword">string</span></span><br><span class="line">    defaultDirErr  error</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试用例初始化资源：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试window系统调用时区相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForceAusFromTZIForTesting</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ResetLocalOnceForTest()</span><br><span class="line">        <span class="comment">// 使用Once执行一次初始化</span></span><br><span class="line">    localOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; initLocalFromTZI(&amp;aus) &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">    m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">        o.doSlow(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="comment">// 双检查</span></span><br><span class="line">    <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Once 实现要<strong>使用一个互斥锁，这样初始化的时候如果有并发的 goroutine，就会进入doSlow 方法。</strong>互斥锁的机制保证只有一个 goroutine 进行初始化，同时利用双检查的机制（double-checking），再次判断 o.done 是否为 0，如果为 0，则是第一次执行，执行完毕后，就将 o.done 设置为 1，然后释放锁。</p><p>使用互斥锁主要是为了当参数f执行很慢时，后续调用Do方法的goroutine虽然看到 done 已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源，因为 f 还没有执行完。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h2><p>map在Go中是非线程安全的数据结构，在多个goroutine同时访问一个map对象时，程序会panic。</p><p>我们一般需要通过加锁的方式来实现一个线程安全的map。</p><h3 id="采用读写锁来保护map"><a href="#采用读写锁来保护map" class="headerlink" title="采用读写锁来保护map"></a><strong>采用读写锁来保护map</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMap <span class="keyword">struct</span> &#123; <span class="comment">// 一个读写锁保护的线程安全的map</span></span><br><span class="line">    sync.RWMutex <span class="comment">// 读写锁保护下面的map字段</span></span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建一个RWMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRWMap</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">RWMap</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;RWMap&#123;</span><br><span class="line">        m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, n),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123; <span class="comment">//从map中读取一个值</span></span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="keyword">defer</span> m.RUnlock()</span><br><span class="line">    v, existed := m.m[k] <span class="comment">// 在锁的保护下从map中读取</span></span><br><span class="line">    <span class="keyword">return</span> v, existed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Set</span><span class="params">(k <span class="keyword">int</span>, v <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 设置一个键值对</span></span><br><span class="line">    m.Lock()              <span class="comment">// 锁保护</span></span><br><span class="line">    <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">    m.m[k] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Delete</span><span class="params">(k <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//删除一个键</span></span><br><span class="line">    m.Lock()                   <span class="comment">// 锁保护</span></span><br><span class="line">    <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">    <span class="built_in">delete</span>(m.m, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// map的长度</span></span><br><span class="line">    m.RLock()   <span class="comment">// 锁保护</span></span><br><span class="line">    <span class="keyword">defer</span> m.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(m.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMap)</span> <span class="title">Each</span><span class="params">(f <span class="keyword">func</span>(k, v <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> &#123; <span class="comment">// 遍历map</span></span><br><span class="line">    m.RLock()             <span class="comment">//遍历期间一直持有读锁</span></span><br><span class="line">    <span class="keyword">defer</span> m.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分片加锁"><a href="#分片加锁" class="headerlink" title="分片加锁"></a><strong>分片加锁</strong></h3><p>采用RWMutex可以解决map线程不安全的问题，但在大量并发读写的情况下，性能较差，这里可以采用分片加锁的方式来实现细粒度加锁（<a href="https://github.com/orcaman/concurrent-map%EF%BC%89%EF%BC%9A">https://github.com/orcaman/concurrent-map）：</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SHARD_COUNT = <span class="number">32</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 分成SHARD_COUNT个分片的map</span></span><br><span class="line"><span class="keyword">type</span> ConcurrentMap []*ConcurrentMapShared</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过RWMutex保护的线程安全的分片，包含一个map</span></span><br><span class="line"><span class="keyword">type</span> ConcurrentMapShared <span class="keyword">struct</span> &#123;</span><br><span class="line">    items        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    sync.RWMutex <span class="comment">// Read Write mutex, guards access to internal map.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建并发map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">ConcurrentMap</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(ConcurrentMap, SHARD_COUNT)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SHARD_COUNT; i++ &#123;</span><br><span class="line">      m[i] = &amp;ConcurrentMapShared&#123;items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key计算分片索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">GetShard</span><span class="params">(key <span class="keyword">string</span>)</span> *<span class="title">ConcurrentMapShared</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m[<span class="keyword">uint</span>(fnv32(key))%<span class="keyword">uint</span>(SHARD_COUNT)]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据key计算出对应的分片</span></span><br><span class="line">    shard := m.GetShard(key)</span><br><span class="line">    shard.Lock() <span class="comment">//对这个分片加锁，执行业务操作</span></span><br><span class="line">    shard.items[key] = value</span><br><span class="line">    shard.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据key计算出对应的分片</span></span><br><span class="line">    shard := m.GetShard(key)</span><br><span class="line">    shard.RLock()</span><br><span class="line">    <span class="comment">// 从这个分片读取key的值</span></span><br><span class="line">    val, ok := shard.items[key]</span><br><span class="line">    shard.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a><strong>sync.Map</strong></h3><p>sync.Map是Go的官方库中的实现，在使用上与标准的map类型有所区别，一般在以下场景下，sync.Map的性能会优于map+RWMutex：</p><ul><li>只会增长的缓存系统中，一个 key 只写入一次而被读很多次。</li><li>多个 goroutine 为不相交的键集读、写和重写键值对。</li></ul><h4 id="sync-Map的基本使用"><a href="#sync-Map的基本使用" class="headerlink" title="sync.Map的基本使用"></a><strong>sync.Map的基本使用</strong></h4><p>Store：用来设置一个键值对，或者更新一个键值对的。</p><p>Load：用来读取一个 key 对应的值。</p><p>Delete：用来删除一个key</p><p>sync.map 还有一些 LoadAndDelete、LoadOrStore、Range 等辅助方法，但是没有 Len 这样查询 sync.Map 的包含项目数量的方法，并且官方也不准备提供。如果你想得到 sync.Map 的项目数量的话，你可能不得不通过 Range 逐个计数。</p><h4 id="sync-Map的实现"><a href="#sync-Map的实现" class="headerlink" title="sync.Map的实现"></a><strong>sync.Map的实现</strong></h4><p>sync.Map主要的实现逻辑如下：</p><ul><li>空间换时间。通过冗余的两个数据结构（只读的 read 字段、可写的 dirty），来减少加锁对性能的影响。对只读字段（read）的操作不需要加锁。</li><li>优先从 read 字段读取、更新、删除，因为对 read 字段的读取不需要锁。</li><li>动态调整。miss 次数多了之后，将 dirty 数据提升为 read，避免总是从 dirty 中加锁读取。</li><li>double-checking。加锁之后先还要再检查 read 字段，确定真的不存在才操作 dirty 字段。</li><li>延迟删除。删除一个键值只是打标记，只有在提升 dirty 字段为 read 字段的时候才清理删除的数据。</li></ul><p><strong>Map数据结构：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Map struct &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    &#x2F;&#x2F; 基本上你可以把它看成一个安全的只读的map</span><br><span class="line">    &#x2F;&#x2F; 它包含的元素其实也是通过原子操作更新的，但是已删除的entry就需要加锁操作了</span><br><span class="line">    read atomic.Value &#x2F;&#x2F; readOnly</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 包含需要加锁才能访问的元素</span><br><span class="line">    &#x2F;&#x2F; 包括所有在read字段中但未被expunged（删除）的元素以及新加的元素</span><br><span class="line">    dirty map[interface&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录从read中读取miss的次数，一旦miss数和dirty长度一样了，就会把dirty提升为read，并把dirty置空</span><br><span class="line">    misses int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type readOnly struct &#123;</span><br><span class="line">    m       map[interface&#123;&#125;]*entry</span><br><span class="line">    amended bool &#x2F;&#x2F; 当dirty中包含read没有的数据时为true，比如新增一条数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; expunged是用来标识此项已经删掉的指针</span><br><span class="line">&#x2F;&#x2F; 当map中的一个项目被删除了，只是把它的值标记为expunged，以后才有机会真正删除此项</span><br><span class="line">var expunged &#x3D; unsafe.Pointer(new(interface&#123;&#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; entry代表一个值</span><br><span class="line">type entry struct &#123;</span><br><span class="line">    p unsafe.Pointer &#x2F;&#x2F; *interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Store方法：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="comment">// 如果read字段包含这个项，说明是更新，cas更新项目的值即可</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read中不存在，或者cas更新失败，就需要加锁访问dirty了</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123; <span class="comment">// 双检查，看看read是否已经存在了</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 此项目先前已经被删除了，通过将它的值设置为nil，标记为unexpunged</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value) <span class="comment">// 更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123; <span class="comment">// 如果dirty中有此项</span></span><br><span class="line">        e.storeLocked(&amp;value) <span class="comment">// 直接更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就是一个新的key</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123; <span class="comment">//如果dirty为nil</span></span><br><span class="line">            <span class="comment">// 需要创建dirty对象，并且标记read的amended为true,</span></span><br><span class="line">            <span class="comment">// 说明有元素它不包含而dirty包含</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value) <span class="comment">//将新值增加到dirty对象中</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123; <span class="comment">// 如果dirty字段已经存在，不需要创建了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly) <span class="comment">// 获取read字段</span></span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123; <span class="comment">// 遍历read字段</span></span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123; <span class="comment">// 把非punged的键值对复制到dirty中</span></span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Store 既可以是新增元素，也可以是更新元素。如果运气好的话，更新的是已存在的未被删除的元素，直接更新即可，不会用到锁。如果运气不好，需要更新（重用）删除的对象、更新还未提升的 dirty 中的对象，或者新增加元素的时候就会使用到了锁，这个时候，性能就会下降。</p><p>所以从这一点来看，sync.Map 适合那些只会增长的缓存系统（k8s operator的workpool就可以使用），可以进行更新，但是不要删除，并且不要频繁地增加新元素。</p><p><strong>Load方法：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先从read处理</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// 如果不存在并且dirty不为nil(有新的元素)</span></span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// 双检查，看看read中现在是否存在此key</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;<span class="comment">//依然不存在，并且dirty不为nil</span></span><br><span class="line">            e, ok = m.dirty[key]<span class="comment">// 从dirty中读取</span></span><br><span class="line">            <span class="comment">// 不管dirty中存不存在，miss数都加1</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load() <span class="comment">//返回读取的对象，e既可能是从read中获得的，也可能是从dirty中获得的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.misses++ <span class="comment">// misses计数加一</span></span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123; <span class="comment">// 如果没达到阈值(dirty字段的长度),返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;) <span class="comment">//把dirty字段的内存提升为read字段</span></span><br><span class="line">    m.dirty = <span class="literal">nil</span> <span class="comment">// 清空dirty</span></span><br><span class="line">    m.misses = <span class="number">0</span>  <span class="comment">// misses数重置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果幸运的话，我们从 read 中读取到了这个 key 对应的值，那么就不需要加锁了，性能会非常好。但是，如果请求的 key 不存在或者是新加的，就需要加锁从 dirty 中读取。所以，读取不存在的 key 会因为加锁而导致性能下降，读取还没有提升的新值的情况下也会因为加锁性能下降。</p><p>其中，missLocked 增加 miss 的时候，如果 miss 数等于 dirty 长度，会将 dirty 提升为 read，并将 dirty 置空。</p><p><strong>Delete方法：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// 双检查</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// 这一行长坤在1.15中实现的时候忘记加上了，导致在特殊的场景下有些key总是没有被回收</span></span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            <span class="comment">// miss数加1</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delete 方法也是先从 read 操作开始，因为不需要锁。</p><p>如果 read 中不存在，那么就需要从 dirty 中寻找这个项目。最终，如果项目存在就删除（将它的值标记为 nil）。如果项目不为 nil 或者没有被标记为 expunged，那么还可以把它的值返回。</p><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a><strong>Pool</strong></h2><p>Pool指代一类建立池化对象的并发数据结构，由于Go自带垃圾回收机制，当需要保留一些创建耗时的对象（例如数据库链接等）时，我们一般会采用Pool的数据结构来存放。</p><p>Go标准库中提供了一个通用的Pool数据结构，sync.Pool。</p><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a><strong>sync.Pool</strong></h3><p>sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象，需要注意的是sync.Pool 不可在使用之后再复制使用。</p><p><strong>sync.Pool提供了三个对外的方法：</strong></p><p><strong>New：</strong></p><p>Pool struct 包含一个 New 字段，这个字段的类型是函数 func() interface{}。当调用 Pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。如果你没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。</p><p><strong>Get：</strong></p><p>如果调用这个方法，就会从 Pool取走一个元素，这也就意味着，这个元素会从 Pool 中移除，返回给调用者。不过，<strong>除了返回值是正常实例化的元素，Get 方法的返回值还可能会是一个 nil（Pool.New 字段没有设置，又没有空闲元素可以返回）</strong>，所以在使用的时候，可能需要判断。</p><p><strong>Put</strong></p><p>这个方法用于将一个元素返还给 Pool，Pool 会把这个元素保存到池中，并且可以复用。但<strong>如果 Put 一个 nil 值，Pool 就会忽略这个值。</strong></p><p><strong>典型使用场景，buffer池：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffers = sync.Pool&#123;</span><br><span class="line">  New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBuffer</span><span class="params">()</span> *<span class="title">bytes</span>.<span class="title">Buffer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> buffers.Get().(*bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutBuffer</span><span class="params">(buf *bytes.Buffer)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> buf.Cap() &gt; <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123; <span class="comment">// 判定是否为大buffer，防止Pool未回收对象，导致内存泄漏</span></span><br><span class="line">retrun</span><br><span class="line">  &#125;</span><br><span class="line">  buf.Reset()</span><br><span class="line">  buffers.Put(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sync-Pool内部实现"><a href="#sync-Pool内部实现" class="headerlink" title="sync.Pool内部实现"></a><strong>sync.Pool内部实现</strong></h4><h5 id="关于GC"><a href="#关于GC" class="headerlink" title="关于GC"></a><strong>关于GC</strong></h5><p>Go 1.1.3之前，sync.Pool实现有2大问题：</p><ol><li><p><strong>每次 GC 都会回收创建的对象。</strong></p><p>如果缓存元素数量太多，就会导致 STW 耗时变长；缓存元素都被回收后，会导致 Get 命中率下降，Get 方法不得不新创建很多对象。</p></li><li><p><strong>底层实现使用了 Mutex，对这个锁并发请求竞争激烈的时候，会导致性能的下降。</strong></p></li></ol><p>当前版本sync.Pool的数据结构如下：</p><img src="/images/1-sync.Pool数据结构.png" alt="1-sync.Pool数据结构" style="zoom: 67%;" /><p>Pool 最重要的两个字段是 local 和 victim，因为它们两个主要用来存储空闲的元素。</p><p>每次垃圾回收的时候，Pool 会把 victim 中的对象移除，然后把 local 的数据给 victim，这样的话，local 就会被清空，而 victim 就像一个垃圾分拣站，里面的东西可能会被当做垃圾丢弃了，但是里面有用的东西也可能被捡回来重新使用。</p><p><strong>victim 中的元素如果被 Get 取走，那么这个元素就很幸运，因为它又“活”过来了</strong>。但是，如果这个时候 Get 的并发不是很大，元素没有被 Get 取走，那么就会被移除掉，因为没有别人引用它的话，就会被垃圾回收掉。</p><p><strong>GC时sync.Pool的处理逻辑：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 丢弃当前victim, STW所以不用加锁</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">        p.victim = <span class="literal">nil</span></span><br><span class="line">        p.victimSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将local复制给victim, 并将原local置为nil</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">        p.victim = p.local</span><br><span class="line">        p.victimSize = p.localSize</span><br><span class="line">        p.local = <span class="literal">nil</span></span><br><span class="line">        p.localSize = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，因为所有当前主要的空闲可用的元素都存放在 local 字段中，<strong>请求元素时也是优先从 local 字段中查找可用的元素。</strong>local 字段包含一个 poolLocalInternal 字段，并提供 CPU 缓存对齐，从而避免 false sharing。</p><p>而 poolLocalInternal 也包含两个字段：private 和 shared。</p><ul><li>private：代表一个缓存的元素，而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，所以不会有并发的问题。</li><li>shared：可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相当于只有一个本地的 P 作为生产者（Producer），多个 P 作为消费者（Consumer），它是使用一个 local-free 的 queue 列表实现的。</li></ul><h5 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a><strong>Get方法</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// 把当前goroutine固定在当前的P上</span></span><br><span class="line">    l, pid := p.pin()</span><br><span class="line">    x := l.private <span class="comment">// 优先从local的private字段取，快速</span></span><br><span class="line">    l.private = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 从当前的local.shared弹出一个，注意是从head读取并移除</span></span><br><span class="line">        x, _ = l.shared.popHead()</span><br><span class="line">        <span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">// 如果没有，则去偷一个</span></span><br><span class="line">            x = p.getSlow(pid) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_procUnpin() <span class="comment">// pin方法会将此goroutine固定在当前的P上，免查找元素期间被其它的P执行</span></span><br><span class="line">    <span class="comment">// 如果没有获取到，尝试使用New函数生成一个新的</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">        x = p.New()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，从本地的 private 字段中获取可用元素，因为没有锁，获取元素的过程会非常快，如果没有获取到，就尝试从本地的 shared 获取一个，如果还没有，会使用 getSlow 方法去其它的 shared 中“偷”一个。最后，如果没有获取到，就尝试使用 New 函数创建一个新的。</p><p>这里的重点是 getSlow 方法，我们来分析下。看名字也就知道了，它的耗时可能比较长。它首先要遍历所有的 local，尝试从它们的 shared 弹出一个元素。如果还没找到一个，那么，就开始对 victim 下手了。</p><p>在 vintim 中查询可用元素的逻辑还是一样的，先从对应的 victim 的 private 查找，如果查不到，就再从其它 victim 的 shared 中查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line">    size := atomic.LoadUintptr(&amp;p.localSize)</span><br><span class="line">    locals := p.local                       </span><br><span class="line">    <span class="comment">// 从其它proc中尝试偷取一个元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">        l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果其它proc也没有可用元素，那么尝试从vintim中获取</span></span><br><span class="line">    size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    locals = p.victim</span><br><span class="line">    l := indexLocal(locals, pid)</span><br><span class="line">    <span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123; <span class="comment">// 同样的逻辑，先从vintim中的local private获取</span></span><br><span class="line">        l.private = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123; <span class="comment">// 从vintim其它proc尝试偷取</span></span><br><span class="line">        l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line">        <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果victim中都没有，则把这个victim标记为空，以后的查找可以快速跳过了</span></span><br><span class="line">    atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a><strong>Put方法</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123; <span class="comment">// nil值直接丢弃</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l, _ := p.pin()</span><br><span class="line">    <span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123; <span class="comment">// 如果本地private没有值，直接设置这个值即可</span></span><br><span class="line">        l.private = x</span><br><span class="line">        x = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x != <span class="literal">nil</span> &#123; <span class="comment">// 否则加入到本地队列中</span></span><br><span class="line">        l.shared.pushHead(x)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_procUnpin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Put 的逻辑相对简单，优先设置本地 private，如果 private 字段已经有值了，那么就把此元素 push 到本地队列中。</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a><strong>连接池</strong></h3><p>由于sync.Pool 会无通知地在某个时候就把连接移除垃圾回收掉了，而我们需要长久保持这个连接时，一般会使用其它方法来池化连接。</p><h4 id="http-client-池"><a href="#http-client-池" class="headerlink" title="http client 池"></a><strong>http client 池</strong></h4><p>标准库的 http.Client 是一个 http client 的库，可以用它来访问 web 服务器。为了提高性能，这个 Client 的实现也是通过池的方法来缓存一定数量的连接，以便后续重用这些连接。</p><h4 id="TCP-连接池"><a href="#TCP-连接池" class="headerlink" title="TCP 连接池"></a><strong>TCP 连接池</strong></h4><p>最常用的一个 TCP 连接池是 fatih 开发的<a href="https://github.com/fatih/pool">fatih/pool</a>，虽然这个项目已经被 fatih 归档（Archived），不再维护了，但是因为它相当稳定了，我们可以开箱即用。即使你有一些特殊的需求，也可以 fork 它，然后自己再做修改。</p><p>它通过把 net.Conn 包装成 PoolConn，实现了拦截 net.Conn 的 Close 方法，避免了真正地关闭底层连接，而是把这个连接放回到池中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type PoolConn struct &#123;</span><br><span class="line">    net.Conn</span><br><span class="line">    mu       sync.RWMutex</span><br><span class="line">    c        *channelPool</span><br><span class="line">    unusable bool</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;拦截Close</span><br><span class="line">func (p *PoolConn) Close() error &#123;</span><br><span class="line">    p.mu.RLock()</span><br><span class="line">    defer p.mu.RUnlock()</span><br><span class="line">  </span><br><span class="line">    if p.unusable &#123;</span><br><span class="line">      if p.Conn !&#x3D; nil &#123;</span><br><span class="line">        return p.Conn.Close()</span><br><span class="line">      &#125;</span><br><span class="line">      return nil</span><br><span class="line">    &#125;</span><br><span class="line">    return p.c.put(p.Conn)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a><strong>数据库连接池</strong></h4><p>标准库 sql.DB 还提供了一个通用的数据库的连接池，通过 MaxOpenConns 和 MaxIdleConns 控制最大的连接数和最大的 idle 的连接数。默认的 MaxIdleConns 是 2，这个数对于数据库相关的应用来说太小了，我们一般都会调整它。</p><h3 id="Worker-Pool"><a href="#Worker-Pool" class="headerlink" title="Worker Pool"></a><strong>Worker Pool</strong></h3><p>大量的goroutine会导致无效的调度和垃圾回收，为了防止goroutine溢出等情况，有时候我们需要创建Worker Pool来控制goroutine的数量。</p><p>常用的Worker Pool三方库推荐：</p><p><a href="https://godoc.org/github.com/gammazero/workerpool">gammazero/workerpool</a>：gammazero/workerpool 可以无限制地提交任务，提供了更便利的 Submit 和 SubmitWait 方法提交任务，还可以提供当前的 worker 数和任务数以及关闭 Pool 的功能。</p><p><a href="https://pkg.go.dev/github.com/ivpusic/grpool?utm_source=godoc">ivpusic/grpool</a>：grpool 创建 Pool 的时候需要提供 Worker 的数量和等待执行的任务的最大数量，任务的提交是直接往 Channel 放入任务。</p><p><a href="https://pkg.go.dev/github.com/dpaks/goworkers?utm_source=godoc">dpaks/goworkers</a>：dpaks/goworkers 提供了更便利的 Submit 方法提交任务以及 Worker 数、任务数等查询方法、关闭 Pool 的方法。它的任务的执行结果需要在 ResultChan 和 ErrChan 中去获取，没有提供阻塞的方法，但是它可以在初始化的时候设置 Worker 的数量和任务数。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a><strong>Context</strong></h2><p>Context的出现主要为了解决goroutine的控制以及goroutine间的上下文信息传递（如认证信息、环境信息等）。</p><h3 id="Context基本用法"><a href="#Context基本用法" class="headerlink" title="Context基本用法"></a><strong>Context基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Deadline：</strong>Deadline 方法会返回这个 Context 被取消的截止日期。如果没有设置截止日期，ok 的值是 false。后续每次调用这个对象的 Deadline 方法时，都会返回和第一次调用相同的结果。</p><p><strong>Done：</strong>Done 方法返回一个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没被取消，可能会返回 nil。后续的 Done 调用总是返回相同的结果。当 Done 被 close 的时候，你可以通过 ctx.Err 获取错误信息。 </p><p><strong>Err：</strong>如果 Done 没有被 close，Err 方法返回 nil；如果 Done 被 close，Err 方法会返回 Done 被 close 的原因。</p><p><strong>Value：</strong>返回此 ctx 中和指定的 key 相关联的 value。</p><p><strong>Context 中实现了 2 个常用的生成顶层 Context 的方法：</strong></p><p><strong>context.Background()：</strong>返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。一般用在主函数、初始化、测试以及创建根 Context 的时候。</p><p><strong>context.TODO()：</strong>返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。当你不清楚是否该用 Context，或者目前还不知道要传递一些什么上下文信息的时候，就可以使用这个方法。</p><p><strong>在使用 Context 的时候，有一些约定俗成的规则：</strong></p><ul><li>一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。</li><li>从来不把 nil 当做 Context 类型的参数值，可以使用 context.Background() 创建一个空的上下文对象，也不要使用 nil。</li><li>Context 只用来临时做函数之间的上下文透传，不能持久化 Context 或者把 Context 长久保存。把 Context 持久化到数据库、本地文件或者全局变量、缓存中都是错误的用法。</li><li>key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。</li><li>使用 WithValue 时，key 的类型应该是自己定义的类型。常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。</li></ul><p>我们一般使用Context时，会采用<strong>WithValue、WithCancel、WithTimeout 和 WithDeadline</strong>：</p><h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a><strong>WithValue</strong></h4><p>WithValue 基于 parent Context 生成一个新的 Context，保存了一个 key-value 键值对。它常常用来传递上下文，Context实现了链式查找，如果当前context不包含所查找的key，会像parent Context中去查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctx = context.TODO()</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">ctx = context.WithValue(ctx, <span class="string">&quot;key4&quot;</span>, <span class="string">&quot;0004&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(ctx.Value(<span class="string">&quot;key1&quot;</span>))</span><br></pre></td></tr></table></figure><p><strong>example：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key <span class="keyword">string</span>=<span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">//附加值</span></span><br><span class="line">valueCtx:=context.WithValue(ctx,key,<span class="string">&quot;【监控1】&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;可以了，通知监控停止&quot;</span>)</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//取出值</span></span><br><span class="line">fmt.Println(ctx.Value(key),<span class="string">&quot;监控退出，停止了...&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//取出值</span></span><br><span class="line">fmt.Println(ctx.Value(key),<span class="string">&quot;goroutine监控中...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WithCanel-withDeadline-withTimeout"><a href="#WithCanel-withDeadline-withTimeout" class="headerlink" title="WithCanel\withDeadline\withTimeout"></a><strong>WithCanel\withDeadline\withTimeout</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>WitchCancel传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。 <code>WithDeadline</code>函数，和<code>WithCancel</code>差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。</p><p><code>WithTimeout</code>和<code>WithDeadline</code>基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。</p><p>WithCancel方法实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)<span class="comment">// 把c朝上传播</span></span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cancel 是向下传递的，如果一个 WithCancel 生成的 Context 被 cancel 时，如果它的子 Context（也有可能是孙，或者更低，依赖子的类型）也是 cancelCtx 类型的，就会被 cancel，但是不会向上传递。parent Context 不会因为子 Context 被 cancel 而 cancel。</p><p>WithCancel示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控1】&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控2】&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控3】&quot;</span>)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;可以了，通知监控停止&quot;</span>)</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(name,<span class="string">&quot;监控退出，停止了...&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(name,<span class="string">&quot;goroutine监控中...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;接上文：&lt;a href=&quot;https://blog.neilcloud.net/2022/05/12/Go%E5%B9%B6%E5%8F%91/&quot;&gt;&lt;strong&gt;Go并发 - 并发原语Mutex、RWMutex&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go并发-goroutine并发模型</title>
    <link href="http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-goroutine%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-goroutine%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-07-11T07:55:11.000Z</published>
    <updated>2022-11-28T09:22:46.480Z</updated>
    
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go并发-channel</title>
    <link href="http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-channel/"/>
    <id>http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-channel/</id>
    <published>2022-07-11T07:33:14.000Z</published>
    <updated>2022-11-28T09:22:46.480Z</updated>
    
    <content type="html"><![CDATA[<p>Channel作为Golang内建的first-clas类型，可以说是每位Go开发者都会用到的技术，也是Go的核心之一，下面我们就围绕Channel来看看他的神奇之处。</p><span id="more"></span><p>之前我们提到了Golang的一些并发原语：</p><p><a href="https://blog.neilcloud.net/2022/05/12/Go%E5%B9%B6%E5%8F%91/">Go并发 - 并发原语Mutex、RWMutex</a></p><p><a href="https://blog.neilcloud.net/2022/07/11/Go%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/">Go并发-常见并发原语</a></p><p>而这些使用Channel几乎都可以实现，但在合适的场景下使用正确的并发原语，仍然至关重要。</p><h2 id="Channel的应用场景"><a href="#Channel的应用场景" class="headerlink" title="Channel的应用场景"></a>Channel的应用场景</h2><p>Channel的一个核心思想是：</p><blockquote><p>Don’t communicate by sharing memory, share memory by communicating.</p><p>Go Proverbs by Rob Pike</p></blockquote><p>可以看出在Golang的设计中，Channel主要被用于goroutine之间的通信，而实际上，Channel的扩展应用场景非常之多，典型的几种应用场景：</p><ul><li><strong>数据交流：</strong>当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。</li><li><strong>数据传递：</strong>一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。</li><li><strong>信号通知：</strong>一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。</li><li><strong>任务编排：</strong>可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。</li><li><strong>锁：</strong>利用 Channel 也可以实现互斥锁的机制。</li></ul><h2 id="Channel的基本用法"><a href="#Channel的基本用法" class="headerlink" title="Channel的基本用法"></a>Channel的基本用法</h2><p>Channel的使用频率一般比较高，Go开发者一般对此掌握得比较充分，本文基本用法部分只取一些典型用法，不做详细介绍。</p><p><strong>Channel的类型：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> <span class="keyword">string</span>          <span class="comment">// 可以发送接收string</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;      <span class="comment">// 只能发送struct&#123;&#125;, &lt;-符号靠左</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>           <span class="comment">// 只能从chan接收int</span></span><br></pre></td></tr></table></figure><p><strong>channel的初始化：</strong></p><p>首先，channel是可以不进行初始化的，未初始化的channel零值未nil，可以通过<code>make</code>关键字来初始化channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">9527</span>) <span class="comment">// 初始化元素为int类型，容量为9527的channel</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 初始化元素为int类型，容量为0的unbuffered chan</span></span><br></pre></td></tr></table></figure><p><strong>接收数据：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;-ch <span class="comment">// 把接收的一条数据赋值给变量x</span></span><br><span class="line">foo(&lt;-ch) <span class="comment">// 把接收的一个的数据作为参数传给函数</span></span><br><span class="line">&lt;-ch <span class="comment">// 丢弃接收的一条数据</span></span><br></pre></td></tr></table></figure><p>接收数据时，<strong>可以返回两个值</strong>。</p><p>第一个值是返回的 chan 中的元素，</p><p>第二个值是 bool 类型，代表是否成功地从 chan 中读取到一个值，如果第二个参数是 false，chan 已经被 close 而且 chan 中没有缓存的数据，这个时候，第一个值是零值。所以，如果从 chan 读取到一个零值，可能是 sender 真正发送的零值，也可能是 closed 的并且没有缓存元素产生的零值。</p><p><strong>内建函数：</strong></p><p>内建函数close、cap、len等都可以操作channel。</p><p>close：关闭channel</p><p>cap：返回channel的容量</p><p>len：返回channel中缓存的还未被取走的元素数量</p><p>select case clause：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-range：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">   fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空chan：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ch &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Channel的内部实现"><a href="#Channel的内部实现" class="headerlink" title="Channel的内部实现"></a>Channel的内部实现</h2><h3 id="Channel类型的数据结构（runtime-hchan）"><a href="#Channel类型的数据结构（runtime-hchan）" class="headerlink" title="Channel类型的数据结构（runtime.hchan）"></a><strong>Channel类型的数据结构（<a href="https://github.com/golang/go/blob/master/src/runtime/chan.go#L32">runtime.hchan</a>）</strong></h3><img src="/images/81304c1f1845d21c66195798b6ba48dd-165776877259212.jpg" alt="img" style="zoom:67%;" /><ul><li><strong>qcount：</strong>代表 chan 中已经接收但还没被取走的元素的个数。内建函数 len 可以返回这个字段的值。</li><li><strong>dataqsiz：</strong>队列的大小。chan 使用一个循环队列来存放元素，循环队列很适合这种生产者 - 消费者的场景。</li><li><strong>buf：</strong>存放元素的循环队列的 buffer。</li><li><strong>elemtype 和 elemsize：</strong>chan 中元素的类型和 size。因为 chan 一旦声明，它的元素类型是固定的，即普通类型或者指针类型，所以元素大小也是固定的。</li><li><strong>sendx：</strong>处理发送数据的指针在 buf 中的位置。一旦接收了新的数据，指针就会加上 elemsize，移向下一个位置。buf 的总大小是 elemsize 的整数倍，而且 buf 是一个循环列表。</li><li><strong>recvx：</strong>处理接收请求时的指针在 buf 中的位置。一旦取出数据，此指针会移动到下一个位置。</li><li><strong>recvq：</strong>chan 是多生产者多消费者的模式，如果消费者因为没有数据可读而被阻塞了，就会被加入到 recvq 队列中。</li><li><strong>sendq：</strong>如果生产者因为 buf 满了而阻塞，会被加入到 sendq 队列中。</li></ul><h3 id="Channel的初始化"><a href="#Channel的初始化" class="headerlink" title="Channel的初始化"></a><strong>Channel的初始化</strong></h3><p><code>makechan</code>会根据 chan 的容量的大小和元素的类型不同，初始化不同的存储空间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 略去检查代码</span></span><br><span class="line">        mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> c *hchan</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// chan的size或者元素的size是0，不必创建buf</span></span><br><span class="line">      c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">      c.buf = c.raceaddr()</span><br><span class="line">    <span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// 元素不是指针，分配一块连续的内存给hchan数据结构和buf</span></span><br><span class="line">      c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">            <span class="comment">// hchan数据结构后面紧接着就是buf</span></span><br><span class="line">      c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 元素包含指针，那么单独分配buf</span></span><br><span class="line">      c = <span class="built_in">new</span>(hchan)</span><br><span class="line">      c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 元素大小、类型、容量都记录下来</span></span><br><span class="line">    c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">    c.elemtype = elem</span><br><span class="line">    c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line">    lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="send"><a href="#send" class="headerlink" title="send"></a><strong>send</strong></h3><p>Go 在编译发送数据给 chan 的时候，会把 send 语句转换成 chansend1 函数，chansend1 函数会调用 chansend。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="comment">// 第一部分</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">      throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最开始，第一部分是进行判断：如果 chan 是 nil 的话，就把调用者 goroutine park（阻塞休眠）， 调用者就永远被阻塞住了，所以，第 11 行是不可能执行到的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二部分，如果chan没有被close,并且chan满了，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分的逻辑是当你往一个已经满了的 chan 实例发送数据时，并且想不阻塞当前调用，那么这里的逻辑是直接返回。chansend1 方法在调用 chansend 的时候设置了阻塞参数，所以不会执行到第二部分的分支里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三部分，chan已经被close的情景</span></span><br><span class="line">  lock(&amp;c.lock) <span class="comment">// 开始加锁</span></span><br><span class="line">  <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三部分显示的是，如果 chan 已经被 close 了，再往里面发送数据的话会 panic。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 第四部分，从接收队列中出队一个等待的receiver</span><br><span class="line">    if sg :&#x3D; c.recvq.dequeue(); sg !&#x3D; nil &#123;</span><br><span class="line">  &#x2F;&#x2F; </span><br><span class="line">  send(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四部分，如果等待队列中有等待的 receiver，那么这段代码就把它从队列中弹出，然后直接把数据交给它（通过 memmove(dst, src, t.size)），而不需要放入到 buf 中，速度可以更快一些。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 第五部分，buf还没满</span></span><br><span class="line">  <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">  qp := chanbuf(c, c.sendx)</span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    raceacquire(qp)</span><br><span class="line">    racerelease(qp)</span><br><span class="line">  &#125;</span><br><span class="line">  typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">  c.sendx++</span><br><span class="line">  <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">    c.sendx = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  c.qcount++</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五部分说明当前没有 receiver，需要把数据放入到 buf 中，放入之后，就成功返回了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 第六部分，buf满。</span><br><span class="line">    &#x2F;&#x2F; chansend1不会进入if块里，因为chansend1的block&#x3D;true</span><br><span class="line">    if !block &#123;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>第六部分是处理 buf 满的情况。如果 buf 满了，发送者的 goroutine 就会加入到发送者的等待队列中，直到被唤醒。这个时候，数据或者被取走了，或者 chan 被 close 了。</p><h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a><strong>recv</strong></h3><p>在处理从 chan 中接收数据时，Go 会把代码转换成 chanrecv1 函数，如果要返回两个返回值，会转换成 chanrecv2，chanrecv1 函数和 chanrecv2 会调用 chanrecv。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">  chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span> <span class="params">(received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  _, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 第一部分，chan为nil</span></span><br><span class="line">  <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">    throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>chanrecv1 和 chanrecv2 传入的 block 参数的值是 true，都是阻塞方式，所以我们分析 chanrecv 的实现的时候，不考虑 block=false 的情况。</p><p>第一部分是 chan 为 nil 的情况。和 send 一样，从 nil chan 中接收（读取、获取）数据时，调用者会被永远阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二部分, block&#x3D;false且c为空</span><br><span class="line">  if !block &amp;&amp; empty(c) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二部分block=false，不再chan recv的考虑范畴。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 加锁，返回时释放锁</span></span><br><span class="line">  lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 第三部分，c已经被close,且chan为空empty</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line">  <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">    typedmemclr(c.elemtype, ep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三部分是 chan 已经被 close 的情况。如果 chan 已经被 close 了，并且队列中没有缓存的元素，那么返回 true、false（select case能接收，但没有数据（零值））。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四部分，如果sendq队列中有等待发送的sender</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">  recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四部分是处理 buf 满的情况。这个时候，如果是 unbuffer 的 chan，就直接将 sender 的数据复制给 receiver，否则就从队列头部读取一个值，并把这个 sender 的值加入到队列尾部。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第五部分, 没有等待的sender, buf中有数据</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">  qp := chanbuf(c, c.recvx)</span><br><span class="line">  <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">    typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">  &#125;</span><br><span class="line">  typedmemclr(c.elemtype, qp)</span><br><span class="line">  c.recvx++</span><br><span class="line">  <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">    c.recvx = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  c.qcount--</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">  unlock(&amp;c.lock)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第六部分， buf中没有元素，阻塞</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>第五部分是处理没有等待的 sender 的情况。这个是和 chansend 共用一把大锁，所以不会有并发的问题。如果 buf 有元素，就取出一个元素给 receiver。</p><p>第六部分是处理 buf 中没有元素的情况。如果没有元素，那么当前的 receiver 就会被阻塞，直到它从 sender 中接收了数据，或者是 chan 被 close，才返回。</p><h3 id="close"><a href="#close" class="headerlink" title="close"></a><strong>close</strong></h3><p>通过 close 函数，可以把 chan 关闭，编译器会替换成 closechan 方法的调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123; <span class="comment">// chan为nil, panic</span></span><br><span class="line">      <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;<span class="comment">// chan已经closed, panic</span></span><br><span class="line">      unlock(&amp;c.lock)</span><br><span class="line">      <span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.closed = <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有的reader</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      sg := c.recvq.dequeue()</span><br><span class="line">      ......</span><br><span class="line">      gp := sg.g</span><br><span class="line">      ......</span><br><span class="line">      glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 释放所有的writer (它们会panic)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      sg := c.sendq.dequeue()</span><br><span class="line">      ......</span><br><span class="line">      gp := sg.g</span><br><span class="line">      ......</span><br><span class="line">      glist.push(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;c.lock)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">      gp := glist.pop()</span><br><span class="line">      gp.schedlink = <span class="number">0</span></span><br><span class="line">      goready(gp, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 chan 为 nil，close 会 panic；如果 chan 已经 closed，再次 close 也会 panic。否则的话，如果 chan 不为 nil，chan 也没有 closed，就把等待队列中的 sender（writer）和 receiver（reader）从队列中全部移除并唤醒。</p><p>Channel 并不是处理并发问题的“银弹”，有时候使用并发原语更简单，而且不容易出错。可以根据实际业务情况进行选择:</p><ul><li><strong>共享资源的并发访问使用传统并发原语；</strong></li><li><strong>复杂的任务编排和消息传递使用 Channel；</strong></li><li><strong>消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；</strong></li><li><strong>简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；</strong></li><li><strong>需要和 Select 语句结合，使用 Channel；</strong></li><li><strong>需要和超时配合时，使用 Channel 和 Context。</strong></li></ul><h3 id="不同状态的channel在recv、send和close操作下的情况"><a href="#不同状态的channel在recv、send和close操作下的情况" class="headerlink" title="不同状态的channel在recv、send和close操作下的情况"></a><strong>不同状态的channel在recv、send和close操作下的情况</strong></h3><p><img src="/images/channel2.png" alt="channel2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Channel作为Golang内建的first-clas类型，可以说是每位Go开发者都会用到的技术，也是Go的核心之一，下面我们就围绕Channel来看看他的神奇之处。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go并发 - 并发原语Mutex、RWMutex</title>
    <link href="http://example.com/2022/05/12/Go%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2022/05/12/Go%E5%B9%B6%E5%8F%91/</id>
    <published>2022-05-12T07:11:36.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    <content type="html"><![CDATA[<p>并发问题是在大型项目开发过程中不可绕过的问题，而Go以其对并发的性能优异而得名，那Golang对并发场景的优势以及对并发问题的解决原理是如何的呢？</p><span id="more"></span><p><strong>并发原语</strong></p><p>原语一般是指内核提供给核外调用的过程或者函数成为原语（primitive），原语在执行过程中不允许中断,而并发原语一般是指原语的并发实现。</p><p>Golang作为主打并发编程的语言，在其设计中，也存在一系列的并发原语来解决并发编程中资源访问、线程交互等并发问题。</p><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a><strong>Mutex</strong></h2><p>Mutex即Go中最基本的互斥锁（排他锁）实现，在并发编程中，我们常常需要保障一组内存空间（资源）在同一时间有且仅有一个对象在访问或操作，这一组内存空间（资源）一般被称为<strong>临界区</strong>。</p><p>使用互斥锁可以限制临界区内只能由一个线程访问。</p><h3 id="Mutex（Locker）接口包含方法"><a href="#Mutex（Locker）接口包含方法" class="headerlink" title="Mutex（Locker）接口包含方法"></a><strong>Mutex（Locker）接口包含方法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock：进入临界区时调用</p><p>Unlock：退出临界区时调用</p><h3 id="Mutex使用方法"><a href="#Mutex使用方法" class="headerlink" title="Mutex使用方法"></a><strong>Mutex使用方法</strong></h3><p>Mutex可以直接在代码中进行调用，而无需初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 互斥锁保护计数器</span></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="comment">// 计数器的值</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辅助变量，用来确认所有的goroutine都完成</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动10个gourontine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 累加10万次</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">                mu.Lock()</span><br><span class="line">                count++</span><br><span class="line">                mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多情况下，Mutex会与其他的struct同时出现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex <span class="comment">// 一般将Mutex放在需要控制的字段上面</span></span><br><span class="line">    Count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Counter)</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.mu.Unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.count &lt; <span class="number">1000</span> &#123;</span><br><span class="line">        f.count += <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    f.count++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex内部实现"><a href="#Mutex内部实现" class="headerlink" title="Mutex内部实现"></a><strong>Mutex内部实现</strong></h3><p>虽然其他语言同样有关于Mutex的实现，这里我们只关注Go的Mutex实现。</p><p>Mutex的架构演进过程：</p><p>初版（完全依赖CAS） -&gt;  给新人机会（新的goroutine也能有机会竞争锁） -&gt; 多给些机会（新来的和被唤醒的有更多的机会竞争锁） -&gt; 解决饥饿问题（解决竞争问题，不会让goroutine长久等待）</p><h4 id="初版"><a href="#初版" class="headerlink" title="初版"></a><strong>初版</strong></h4><p>完全依赖于CAS（compare-and-swap）。这里简单描述下CAS指令的过程，CAS指令将<strong>给定的值</strong>和<strong>内存地址中的值</strong>进行比较，如果是同一个值，就使用新值替换内存中地址中的值，<strong>如果同时有其他线程已经修改了这个值，CAS返回失败，返回false</strong>，不难看出，CAS是一个原子（atomic）操作。</p><p>初版实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CAS操作，当时还没有抽象出atomic包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(val *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire</span><span class="params">(*<span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease</span><span class="params">(*<span class="keyword">int32</span>)</span></span></span><br><span class="line"><span class="comment">// 互斥锁的结构，包含两个字段</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="keyword">int32</span> <span class="comment">// 锁是否被持有的标识</span></span><br><span class="line">    sema <span class="keyword">int32</span> <span class="comment">// 信号量专用，用以阻塞/唤醒goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证成功在val上增加delta的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xadd</span><span class="params">(val *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := *val</span><br><span class="line">        <span class="keyword">if</span> cas(val, v, v+delta) &#123;</span><br><span class="line">            <span class="keyword">return</span> v + delta</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreached&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">1</span>) == <span class="number">1</span> &#123; <span class="comment">//标识加1，如果等于1，成功获取到锁</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    semacquire(&amp;m.sema) <span class="comment">// 否则阻塞等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">-1</span>) == <span class="number">0</span> &#123; <span class="comment">// 将标识减去1，如果等于0，则没有其它等待者</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    semrelease(&amp;m.sema) <span class="comment">// 唤醒其它阻塞的goroutine</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>Mutex结构体包含两个字段：</p><p><strong>字段 key</strong>：是一个 flag，用来标识这个排外锁是否被某个 goroutine 所持有，如果 key 大于等于 1，说明这个排外锁已经被持有；</p><p><strong>字段 sema</strong>：是个信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒。</p><p>调用 Lock 请求锁的时候，通过 xadd 方法进行 CAS 操作（第 25行），xadd 方法通过循环执行 CAS 操作直到成功，保证对 key 加 1 的操作成功完成。如果比较幸运，锁没有被别的 goroutine 持有，那么，Lock 方法成功地将 key 设置为 1，这个 goroutine 就持有了这个锁；如果锁已经被别的 goroutine 持有了，那么，当前的 goroutine 会把 key 加 1，而且还会调用 semacquire 方法（第 28 行），使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。</p><p>持有锁的 goroutine 调用 Unlock 释放锁时，它会将 key 减 1（第 32行）。如果当前没有其它等待这个锁的 goroutine，这个方法就返回了。但是，如果还有等待此锁的其它 goroutine，那么，它会调用 semrelease 方法（第 35 行），利用信号量唤醒等待锁的其它 goroutine 中的一个。</p><p>这里需要注意的一点是：</p><p><u><strong>Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。</strong></u></p><p>这种设计比较简单，但如果其他goroutine提前释放了自己的锁，在临界区的goroutine可能不知道自己的锁已经释放了，会带来data race问题。在使用Mutex要遵循<u><strong>谁申请，谁释放</strong></u>的原则。</p><h4 id="给新人机会"><a href="#给新人机会" class="headerlink" title="给新人机会"></a><strong>给新人机会</strong></h4><p>Mutex发展的第二阶段，对Mutex进行了一次大的调整：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line"> state <span class="keyword">int32</span></span><br><span class="line"> sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里Mutex的第一个字段从<code>key</code>改为了<code>state</code>。</p><p>state是一个复合字段，一个字段包含多个意义，这样可以通过尽可能少的内存来实现互斥锁。这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，剩余的位数代表的是等待此锁的 goroutine 数。所以，state 这一个字段被分成了三部分，代表三个数据：</p><p>mutexWaiters（阻塞等待的waiter数量） – mutexWorken（唤醒标记） – mutexLocked（持有锁的标记）</p><p>主要实现逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Fast path: 幸运case，能够直接获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        awoke := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            old := m.state</span><br><span class="line">            <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态加锁</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift <span class="comment">//等待者数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> awoke &#123;</span><br><span class="line">                <span class="comment">// goroutine是被唤醒的，</span></span><br><span class="line">                <span class="comment">// 新状态清除唤醒标志</span></span><br><span class="line">                <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;<span class="comment">//设置新状态</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">// 锁原状态未加锁</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                runtime.Semacquire(&amp;m.sema) <span class="comment">// 请求信号量</span></span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先是通过 CAS 检测 state 字段中的标志（第 3 行），如果没有 goroutine 持有锁，也没有等待持有锁的 goroutine，那么，当前的 goroutine 就很幸运，可以直接获得锁。如果state不是零值，那就存在一定的竞争关系，此时当前goroutine会进行休眠，当锁被释放后被唤醒。</p><p>但当被唤醒时，并不能直接获取到锁，此时需要与waiter进行竞争（for 循环是不断尝试获取锁，如果获取不到，就通过 runtime.Semacquire(&amp;m.sema) 休眠，休眠醒来之后 awoke 置为 true，尝试争抢锁。），<strong>这点是与初版设计不一样的地方，这会给后来请求锁的goroutine一些机会，也让 CPU 中正在执行的 goroutine 有更多的机会获取到锁，在一定程度上提高了程序的性能。</strong></p><p>代码中的第 10 行将当前的 flag 设置为加锁状态，如果能成功地通过 CAS 把这个新值赋予 state（第 19 行和第 20 行），就代表抢夺锁的操作成功了。</p><p>由于涉及到对单个值的位操作，释放锁的逻辑也会相对复杂：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">        <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) <span class="comment">//去掉锁标志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">//本来就没有加锁</span></span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> &#123; <span class="comment">// 没有等待者，或者有唤醒的waiter，或者锁原来已加锁</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken <span class="comment">// 新状态，准备唤醒goroutine，并设置唤醒标志</span></span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime.Semrelease(&amp;m.sema)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第 3 行是尝试将持有锁的标识设置为未加锁的状态，这是通过减 1 而不是将标志位置零的方式实现。</p><p>第 4 到 6 行还会检测原来锁的状态是否已经未加锁的状态，如果是 Unlock 一个未加锁的 Mutex 会直接 panic。不过，即使将加锁置为未加锁的状态，这个方法也不能直接返回，还需要一些额外的操作，因为还可能有一些等待这个锁的 goroutine（有时候我也把它们称之为 waiter）需要通过信号量的方式唤醒它们中的一个。</p><p>所以接下来的逻辑有两种情况。</p><ul><li>第一种情况（无waiter竞争），如果没有其它的 waiter，说明对这个锁的竞争的 goroutine 只有一个，那就可以直接返回了；如果这个时候有唤醒的 goroutine，或者是又被别人加了锁，那么，无需我们操劳，其它 goroutine 自己干得都很好，当前的这个 goroutine 就可以放心返回了。</li><li>第二种情况（存在waiter），如果有等待者，并且没有唤醒的 waiter，那就需要唤醒一个等待的 waiter。在唤醒之前，需要将 waiter 数量减 1，并且将 mutexWoken 标志设置上，这样，Unlock 就可以返回了。</li></ul><h4 id="多给些机会"><a href="#多给些机会" class="headerlink" title="多给些机会"></a><strong>多给些机会</strong></h4><p>在这次的改动中，Golang工程师加入了<a href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/proc.go#L5580">自旋</a>（spin，通过循环不断尝试）的特性。</p><p>如果信赖的goroutine或者是被唤醒的 goroutine 首次获取不到锁，它们就会通过自旋的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Fast path: 幸运之路，正好获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        awoke := <span class="literal">false</span></span><br><span class="line">        iter := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123; <span class="comment">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁</span></span><br><span class="line">            old := m.state <span class="comment">// 先保存当前锁的状态</span></span><br><span class="line">            <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态设置加锁标志</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> &#123; <span class="comment">// 锁还没被释放</span></span><br><span class="line">                <span class="keyword">if</span> runtime_canSpin(iter) &#123; <span class="comment">// 还可以自旋</span></span><br><span class="line">                    <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                        awoke = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    runtime_doSpin()</span><br><span class="line">                    iter++</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">// 自旋，再次尝试请求锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> awoke &#123; <span class="comment">// 唤醒状态</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="built_in">panic</span>(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">// 旧状态锁已释放，新状态成功持有了锁，直接返回</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                runtime_Semacquire(&amp;m.sema) <span class="comment">// 阻塞等待</span></span><br><span class="line">                awoke = <span class="literal">true</span> <span class="comment">// 被唤醒</span></span><br><span class="line">                iter = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果可以 spin 的话，第 9 行的 for 循环会重新检查锁是否释放。对于临界区代码执行非常短的场景来说，这是一个非常好的优化。因为<strong>临界区的代码耗时很短，锁很快就能释放</strong>，而抢夺锁的 goroutine 不用通过休眠唤醒方式等待调度，直接 spin 几次，可能就获得了锁。</p><h4 id="解决饥饿问题"><a href="#解决饥饿问题" class="headerlink" title="解决饥饿问题"></a><strong>解决饥饿问题</strong></h4><p>在之前的几代Mutex优化中，考虑的主要是为“新来的goroutine”分配临界区的占有权，而在极端情况下，很可能出现<strong>等待中的goroutine一直获取不到锁的情况，出现饥饿问题</strong>。</p><p>最新的Mutex实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">    mutexWoken</span><br><span class="line">    mutexStarving <span class="comment">// 从state字段中分出一个饥饿标记</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Fast path: 幸运之路，一下就获取到了锁</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争</span></span><br><span class="line">    m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">    starving := <span class="literal">false</span> <span class="comment">// 此goroutine的饥饿标记</span></span><br><span class="line">    awoke := <span class="literal">false</span> <span class="comment">// 唤醒标记</span></span><br><span class="line">    iter := <span class="number">0</span> <span class="comment">// 自旋次数</span></span><br><span class="line">    old := m.state <span class="comment">// 当前的锁的状态</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 锁是非饥饿状态，锁还没被释放，尝试自旋</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state <span class="comment">// 再次获取锁的状态，之后会检查是否锁被释放了</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked <span class="comment">// 非饥饿状态，加锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">// waiter数量加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving <span class="comment">// 设置饥饿状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功设置新状态</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理饥饿状态</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果以前就在队列里面，加入到队列头</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 唤醒之后检查锁是否应该处于饥饿状态</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有点绕，加锁并且将waiter数减1</span></span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    delta -= mutexStarving <span class="comment">// 最后一个waiter或者已经不饥饿了，清除饥饿标记</span></span><br><span class="line">                &#125;</span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">        m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前的实现相比，当前的 Mutex 最重要的变化，就是增加饥饿模式。第 123行将饥饿模式的最大等待时间阈值设置成了 1 毫秒，这就意味着，一旦等待者等待的时间超过了这个阈值，Mutex 的处理就有可能进入饥饿模式。</p><h4 id="饥饿模式-vs-正常模式"><a href="#饥饿模式-vs-正常模式" class="headerlink" title="饥饿模式 vs 正常模式"></a><strong>饥饿模式 vs 正常模式</strong></h4><p>请求锁时调用的 Lock 方法中一开始是 fast path，这是一个幸运的场景，当前的 goroutine 幸运地获得了锁，没有竞争，直接返回，否则就进入了 lockSlow 方法。</p><p>在lockSlow方法下就会进行正常模式与饥饿模式的切换。</p><p>正常模式下，waiter 都是进入先入先出队列，被唤醒的 waiter 并不会直接持有锁，而是要和新来的 goroutine 进行竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</p><p>在饥饿模式下，Mutex 的拥有者将<strong>直接把锁交给队列最前面的 waiter</strong>。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin，它会乖乖地加入到等待队列的尾部。如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p><ul><li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li><li>此 waiter 的等待时间小于 1 毫秒。</li></ul><p>正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。</p><p>饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。</p><p>综上，则是Mutex整个发展过程，可以看出Mutex设计者的一个核心理念： 在<strong>Mutex的设计中，绝不容忍一个goroutine被落下，尽可能地让等待时间较长的goroutine更有机会获取到锁。</strong></p><h2 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a><strong>RWMutex</strong></h2><p>Mutex已经能够为我们保证临界区资源的并发安全，但相对得牺牲了并发性能，为此，我们需要引入“读写分离”的概念，把并发中的写和读单独抽出考虑。</p><h3 id="RWMutex接口包含方法"><a href="#RWMutex接口包含方法" class="headerlink" title="RWMutex接口包含方法"></a><strong>RWMutex接口包含方法</strong></h3><p><strong>Lock/Unlock</strong>：写操作时调用的方法。如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。</p><p><strong>RLock/RUnlock</strong>：读操作时调用的方法。如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。</p><p><strong>RLocker</strong>：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</p><h3 id="Mutex使用方法-1"><a href="#Mutex使用方法-1" class="headerlink" title="Mutex使用方法"></a><strong>Mutex使用方法</strong></h3><p>RWMutex和Mutex一样，零值是未加锁的状态，当使用时，可以嵌入到其他strcut中，不必显示初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// 10个reader</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                counter.Count() <span class="comment">// 计数器读操作</span></span><br><span class="line">                time.Sleep(time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 一个writer</span></span><br><span class="line">        counter.Incr() <span class="comment">// 计数器写操作</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个线程安全的计数器</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用写锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用读锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RWMutex内部实现"><a href="#RWMutex内部实现" class="headerlink" title="RWMutex内部实现"></a><strong>RWMutex内部实现</strong></h3><p>Golang中RWMutex是基于Mutex实现的。</p><p>readers-writers 问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。</p><p><strong>Read-preferring：</strong>读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。</p><p><strong>Write-preferring：</strong>写优先的设计意味着，如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。</p><p><strong>不指定优先级：</strong>这种设计比较简单，不区分 reader 和 writer 优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。</p><p><strong>Go中的RWmutex采用Write-preferring。</strong></p><p>RWMutex结构包含一个Mutex，和四个辅助字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  w           Mutex   <span class="comment">// 互斥锁解决多个writer的竞争</span></span><br><span class="line">  writerSem   <span class="keyword">uint32</span>  <span class="comment">// writer信号量</span></span><br><span class="line">  readerSem   <span class="keyword">uint32</span>  <span class="comment">// reader信号量</span></span><br><span class="line">  readerCount <span class="keyword">int32</span>   <span class="comment">// reader的数量</span></span><br><span class="line">  readerWait  <span class="keyword">int32</span>   <span class="comment">// writer等待完成的reader的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>字段 w：</strong>Mutex锁，为 writer 的竞争锁而设计。</p><p><strong>字段 readerCount：</strong>记录当前 reader 的数量（以及是否有 writer 竞争锁）。</p><p><strong>readerWait：</strong>记录 writer 请求锁时需要等待 read 完成的 reader 的数量</p><p><em><strong>writerSem 和 readerSem：</strong></em>都是为了阻塞设计的信号量。</p><h4 id="RLock-RUnlock-的实现"><a href="#RLock-RUnlock-的实现" class="headerlink" title="RLock/RUnlock 的实现"></a><strong>RLock/RUnlock 的实现</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rw.rUnlockSlow(r) <span class="comment">// 有等待的writer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个reader了，writer终于有机会获得锁了</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>readerCount字段的双重含义：</strong></p><ul><li>没有 writer 竞争或持有锁时，readerCount 和我们正常理解的 reader 的计数是一样的。</li><li>如果有 writer 竞争锁或者持有锁时，那么，readerCount 不仅仅承担着 reader 的计数功能，还能够标识当前是否有 writer 竞争或持有锁，在这种情况下，请求锁的 reader 的处理进入第 4 行，阻塞等待锁的释放。</li></ul><p>在RUnlock时，需要先检查是否存在writer竞争锁（readerCount为负值），在这种情况下，还会调用方rUnlockSlow方法等待所有的reader锁释放。</p><p><strong>当 writer 请求锁的时候，是无法改变既有的 reader 持有锁的现实的，也不会强制这些 reader 释放锁，它的优先权只是限定后来的 reader 不要和它抢。</strong></p><h4 id="Lock-的实现"><a href="#Lock-的实现" class="headerlink" title="Lock 的实现"></a><strong>Lock 的实现</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (rw *RWMutex) Lock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先解决其他writer竞争问题</span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    &#x2F;&#x2F; 反转readerCount，告诉reader有writer竞争锁</span><br><span class="line">    r :&#x3D; atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    &#x2F;&#x2F; 如果当前有reader持有锁，那么需要等待</span><br><span class="line">    if r !&#x3D; 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) !&#x3D; 0 &#123;</span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, false, 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(&gt;=0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。</p><p>如果 readerCount 不是 0，就说明当前有持有读锁的 reader，RWMutex 需要把这个当前 readerCount 赋值给 readerWait 字段保存下来（第 7 行）， 同时，这个 writer 进入阻塞等待状态（第 8 行）。</p><p>每当一个 reader 释放读锁的时候（调用 RUnlock 方法时），readerWait 字段就减 1，直到所有的活跃的 reader 都释放了读锁，才会唤醒这个 writer。</p><h4 id="Unlock-的实现"><a href="#Unlock-的实现" class="headerlink" title="Unlock 的实现"></a><strong>Unlock 的实现</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 告诉reader没有活跃的writer了</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒阻塞的reader们</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放内部的互斥锁</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 writer 释放锁的时候，它会再次反转 readerCount 字段。</p><p>当writer 要释放锁了，需要唤醒之后新来的 reader，不必再阻塞它们了（第7行）</p><p>Mutex在这里需要保障修改字段的互斥关系（实现代码中省略），在 Lock 方法中，是先获取内部互斥锁，才会修改的其他字段；而在 Unlock 方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并发问题是在大型项目开发过程中不可绕过的问题，而Go以其对并发的性能优异而得名，那Golang对并发场景的优势以及对并发问题的解决原理是如何的呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>openstack-helm离线部署</title>
    <link href="http://example.com/2022/04/19/openstack-helm%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2022/04/19/openstack-helm%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/</id>
    <published>2022-04-19T06:27:23.000Z</published>
    <updated>2022-11-28T09:22:46.482Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>节点名</th><th>角色</th></tr></thead><tbody><tr><td>knode1</td><td>融合节点</td></tr><tr><td>knode2</td><td>融合节点</td></tr><tr><td>knode3</td><td>融合节点</td></tr><tr><td>knode4</td><td>计算、存储节点</td></tr></tbody></table><blockquote><p>文章中引用的chart包是经过改造的，如需要，请联系笔者</p><p>Linux发行版为centos7，openstack版本为w版（nova组件为u版，u版以上无法完全适配centos7 3.10 kernel）</p></blockquote><h1 id="一-helm准备"><a href="#一-helm准备" class="headerlink" title="一.helm准备"></a>一.helm准备</h1><p>1.将helm二进制复制到<code>/usr/bin</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp binary&#x2F;helm &#x2F;usr&#x2F;bin&#x2F;helm</span><br><span class="line">chmod +x &#x2F;usr&#x2F;bin&#x2F;helm</span><br></pre></td></tr></table></figure><p>2.去除master节点的污点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes knode1 node-role.kubernetes.io&#x2F;master:NoSchedule-</span><br><span class="line">kubectl taint nodes knode2 node-role.kubernetes.io&#x2F;master:NoSchedule-</span><br><span class="line">kubectl taint nodes knode3 node-role.kubernetes.io&#x2F;master:NoSchedule-</span><br></pre></td></tr></table></figure><p>3.为节点添加label（3控制同时作为控制节点和计算节点，单独的node4作为单独计算节点，所有节点默认都是存储节点，控制节点作为进出口流量节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes knode1 ceph-control-plane&#x3D;enabled openstack-control-plane&#x3D;enabled  openvswitch&#x3D;enabled openstack-compute-node&#x3D;enabled ingress-node&#x3D;enabled</span><br><span class="line">kubectl label nodes knode2 ceph-control-plane&#x3D;enabled openstack-control-plane&#x3D;enabled  openvswitch&#x3D;enabled openstack-compute-node&#x3D;enabled ingress-node&#x3D;enabled</span><br><span class="line">kubectl label nodes knode3 ceph-control-plane&#x3D;enabled openstack-control-plane&#x3D;enabled  openvswitch&#x3D;enabled openstack-compute-node&#x3D;enabled ingress-node&#x3D;enabled</span><br><span class="line">kubectl label nodes knode4 openstack-compute-node&#x3D;enabled openvswitch&#x3D;enabled </span><br></pre></td></tr></table></figure><h1 id="二-安装rook-ceph"><a href="#二-安装rook-ceph" class="headerlink" title="二.安装rook-ceph"></a>二.安装rook-ceph</h1><p>1.安装rook-ceph-operator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm install --create-namespace --namespace rook-ceph rook-ceph .&#x2F;charts&#x2F;rook-ceph-0.0.1.tgz  --set image.tag&#x3D;v1.8.8</span><br><span class="line"># wait for operator start</span><br><span class="line">sleep 10</span><br></pre></td></tr></table></figure><p>2.创建ceph cluster、storageClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --create-namespace --namespace rook-ceph rook-ceph-cluster .&#x2F;charts&#x2F;rook-ceph-cluster-0.0.1.tgz --set cephClusterSpec.dashboard.enabled&#x3D;false</span><br></pre></td></tr></table></figure><blockquote><p>删除时，需要先执行<code>kubectl -n rook-ceph patch cephcluster rook-ceph --type merge -p &#39;&#123;&quot;spec&quot;:&#123;&quot;cleanupPolicy&quot;:&#123;&quot;confirmation&quot;:&quot;yes-really-destroy-data&quot;&#125;&#125;&#125;&#39;</code></p></blockquote><p>3.等待集群创建完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Ready -n rook-ceph cephcluster rook-ceph --timeout&#x3D;1800s</span><br><span class="line"> </span><br><span class="line"># 等待osd pod正常创建并启动</span><br><span class="line">sleep 180</span><br><span class="line"></span><br><span class="line">kubectl get pod -n rook-ceph # 确认所有pod都处于Running或Complete状态，确保4个osd成功创建（集群Ready后，OSD不一定完全启动），创建成功后才能进行下一步</span><br><span class="line"># 查看ceph集群状态,HEALTH_WARN或HEALTH_OK均可</span><br><span class="line">kubectl exec -it -n rook-ceph &#96;kubectl  get pod -n rook-ceph -owide|grep tools|awk &#39;&#123; print $1 &#125;&#39;&#96; -- ceph -s</span><br></pre></td></tr></table></figure><blockquote><p>1.ceph osd无法启动？</p><p>查看prepare osd job pod的日志，确认各节点有一块以上未使用的磁盘，operator轮询过程可能比较慢，可能需要等待5分钟以上才能创建出osd</p><p>2.新增节点osd未被添加？</p><p>rook operator会以周期频率检查新加入节点，如果长时间未被添加，手动重启rook operator pod，1分钟左右新节点会被加入</p></blockquote><h1 id="三-安装Registry、ChartMuseum"><a href="#三-安装Registry、ChartMuseum" class="headerlink" title="三.安装Registry、ChartMuseum"></a>三.安装Registry、ChartMuseum</h1><p>1.安装并配置docker-registry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm install docker-registry --create-namespace --namespace registry .&#x2F;charts&#x2F;docker-registry-2.1.0.tgz --set persistence.size&#x3D;60Gi</span><br><span class="line">kubectl get pod  -n registry |grep 1&#x2F;1 # 确认registry pod成功创建，成功后才能进行下一步</span><br></pre></td></tr></table></figure><p>2.设置私有仓库和设置dns地址（<strong>需要在所有节点执行</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># replace nameserver to kubedns, every nodes should do below</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;insecure-registries&quot; : [&quot;docker-registry.registry.svc.cluster.local&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">sleep 30</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Available -n registry deploy docker-registry --timeout&#x3D;120s</span><br></pre></td></tr></table></figure><blockquote><p>测试：</p><p>docker tag rook/ceph:v1.8.8 docker-registry.registry.svc.cluster.local/ceph:v1.8.8</p><p>docker push docker-registry.registry.svc.cluster.local/ceph:v1.8.8</p></blockquote><p>3.导入镜像到registry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 添加kubedns，所有节点都需要配置该nameserver，否则kubelet无法拉取镜像，node节点如果无法执行kubectl命令，则需要从master节点拷贝</span><br><span class="line">NAMESERVER&#x3D;&#96;kubectl get svc -n kube-system|awk &#39;&#123; print $3 &#125;&#39;|grep -v IP&#96;</span><br><span class="line">echo &quot;nameserver $NAMESERVER&quot; &gt; &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改Kubelet ImageGC配置，防止kubelet删除节点镜像</span><br><span class="line">echo &quot;imageGCHighThresholdPercent: 100&quot; &gt;&gt; &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml</span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">docker load -q &lt; images&#x2F;components&#x2F;all_components_images.tar.gz</span><br><span class="line">docker images | grep docker-registry.registry.svc.cluster.local | awk &#39;&#123;print &quot;docker push -q &quot;$1&quot;:&quot;$2&#125;&#39;|sh</span><br><span class="line"></span><br><span class="line"># 复原kubelet配置</span><br><span class="line">sed -i &#39;&#x2F;imageGCHighThresholdPercent&#x2F;d&#39;  &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml</span><br><span class="line">systemctl restart kubelet</span><br><span class="line">sleep 30</span><br></pre></td></tr></table></figure><p>4.安装并配置chartmuseum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm install chartmuseum --create-namespace --namespace registry .&#x2F;charts&#x2F;chartmuseum-3.7.0.tgz</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Available -n registry deploy chartmuseum --timeout&#x3D;120s</span><br><span class="line">helm repo add chartmuseum http:&#x2F;&#x2F;chartmuseum.registry.svc.cluster.local:8080&#x2F;</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure><p>5.安装并配置openstackclient</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 在所有控制节点安装</span><br><span class="line">yum install -y python3</span><br><span class="line">mkdir -p &#x2F;tmp&#x2F;pip_packs&#x2F;</span><br><span class="line">tar -zxf .&#x2F;pip_packs&#x2F;openstackclient_pip_packs.tar.gz -C &#x2F;tmp&#x2F;pip_packs&#x2F;</span><br><span class="line">sudo -H -E pip3 install  --no-index --find-links&#x3D;&#x2F;tmp&#x2F;pip_packs&#x2F; cmd2 python-openstackclient python-heatclient --ignore-installed</span><br><span class="line"></span><br><span class="line">sudo -H mkdir -p &#x2F;etc&#x2F;openstack</span><br><span class="line">sudo -H chown -R $(id -un): &#x2F;etc&#x2F;openstack</span><br><span class="line">FEATURE_GATE&#x3D;&quot;tls&quot;; if [[ $&#123;FEATURE_GATES&#x2F;&#x2F;,&#x2F; &#125; &#x3D;~ (^|[[:space:]])$&#123;FEATURE_GATE&#125;($|[[:space:]]) ]]; then</span><br><span class="line">  tee &#x2F;etc&#x2F;openstack&#x2F;clouds.yaml &lt;&lt; EOF</span><br><span class="line">  clouds:</span><br><span class="line">    openstack_helm:</span><br><span class="line">      region_name: RegionOne</span><br><span class="line">      identity_api_version: 3</span><br><span class="line">      volume_api_version: 3</span><br><span class="line">      cacert: &#x2F;etc&#x2F;openstack-helm&#x2F;certs&#x2F;ca&#x2F;ca.pem</span><br><span class="line">      auth:</span><br><span class="line">        username: &#39;admin&#39;</span><br><span class="line">        password: &#39;password&#39;</span><br><span class="line">        project_name: &#39;admin&#39;</span><br><span class="line">        project_domain_name: &#39;default&#39;</span><br><span class="line">        user_domain_name: &#39;default&#39;</span><br><span class="line">        auth_url: &#39;https:&#x2F;&#x2F;keystone-api.openstack.svc.cluster.local:5000&#x2F;v3&#39;</span><br><span class="line">EOF</span><br><span class="line">else</span><br><span class="line">  tee &#x2F;etc&#x2F;openstack&#x2F;clouds.yaml &lt;&lt; EOF</span><br><span class="line">  clouds:</span><br><span class="line">    openstack_helm:</span><br><span class="line">      region_name: RegionOne</span><br><span class="line">      identity_api_version: 3</span><br><span class="line">      volume_api_version: 3</span><br><span class="line">      auth:</span><br><span class="line">        username: &#39;admin&#39;</span><br><span class="line">        password: &#39;password&#39;</span><br><span class="line">        project_name: &#39;admin&#39;</span><br><span class="line">        project_domain_name: &#39;default&#39;</span><br><span class="line">        user_domain_name: &#39;default&#39;</span><br><span class="line">        auth_url: &#39;http:&#x2F;&#x2F;keystone-api.openstack.svc.cluster.local:5000&#x2F;v3&#39;</span><br><span class="line">EOF</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>6.导入charts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in &#96;ls .&#x2F;charts&#96;;do curl --data-binary &quot;@.&#x2F;charts&#x2F;$i&quot; http:&#x2F;&#x2F;chartmuseum.registry.svc.cluster.local:8080&#x2F;api&#x2F;charts;done</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure><h1 id="三-部署、配置平台中间件"><a href="#三-部署、配置平台中间件" class="headerlink" title="三.部署、配置平台中间件"></a>三.部署、配置平台中间件</h1><p>1.安装ingress-controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm install ingress-controller --namespace kube-system chartmuseum&#x2F;ingress-nginx</span><br><span class="line"># 等待pod启动</span><br><span class="line">[root@knode1 ~]# kubectl  get ds -n kube-system|grep ingress-controller-ingress-nginx-controller</span><br><span class="line">ingress-controller-ingress-nginx-controller   4         4         4       4            4           kubernetes.io&#x2F;os&#x3D;linux   37m</span><br></pre></td></tr></table></figure><p>2.部署mariadb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">helm install mariadb --create-namespace --namespace openstack chartmuseum&#x2F;mariadb --set volume.enabled&#x3D;true --set volume.class_name&#x3D;ceph-block --set volume.size&#x3D;10Gi --set pod.replicas.server&#x3D;3</span><br><span class="line"></span><br><span class="line"># 等待3个pod启动</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Ready -n openstack pods&#x2F;mariadb-server-2 --timeout 500s</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Ready -n openstack pods&#x2F;mariadb-server-1 --timeout 500s</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Ready -n openstack pods&#x2F;mariadb-server-0 --timeout 500s</span><br></pre></td></tr></table></figure><blockquote><p>Pod一直无法启动？</p><p>一般情况下是mariaDB集群时间采样与实际时间不符导致，需要检查以下两点：</p><p>1.ntp时间是否同步</p><p>2.是否之前部署过后进行了helm delete，如果是，需要手动删除openstack namespace下，mariaDB相关的configmap和pvc，删除后重新部署即可</p></blockquote><p>3.部署RabbitMQ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install rabbitmq chartmuseum&#x2F;rabbitmq \</span><br><span class="line">    --namespace&#x3D;openstack \</span><br><span class="line">    --set volume.enabled&#x3D;true \</span><br><span class="line">    --set pod.replicas.server&#x3D;2 \</span><br><span class="line">    --set volume.class_name&#x3D;ceph-block</span><br></pre></td></tr></table></figure><p>4.部署Memcached</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install memcached chartmuseum&#x2F;memcached \</span><br><span class="line">    --namespace&#x3D;openstack</span><br><span class="line"></span><br><span class="line"># 等待pod启动</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Available -n openstack deployment&#x2F;memcached-memcached --timeout&#x3D;300s</span><br></pre></td></tr></table></figure><h1 id="四-部署openstack相关组件"><a href="#四-部署openstack相关组件" class="headerlink" title="四.部署openstack相关组件"></a>四.部署openstack相关组件</h1><p>1.部署keystone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install keystone chartmuseum&#x2F;keystone     --namespace&#x3D;openstack     --set pod.replicas.api&#x3D;2 --timeout 1800s</span><br><span class="line"></span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Available -n openstack deploy&#x2F;keystone-api --timeout&#x3D;300s</span><br><span class="line"># 验证</span><br><span class="line">export OS_CLOUD&#x3D;openstack_helm</span><br><span class="line">openstack endpoint list</span><br></pre></td></tr></table></figure><p>2.部署glance</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install glance chartmuseum&#x2F;glance \</span><br><span class="line">  --namespace&#x3D;openstack --timeout 1800s</span><br><span class="line">  </span><br><span class="line"># 查看pod状态</span><br><span class="line">kubectl  get pod -n openstack|grep glance|grep -v Completed</span><br><span class="line"># 验证</span><br><span class="line">export OS_CLOUD&#x3D;openstack_helm</span><br><span class="line">openstack image create &quot;Cirros 0.3.5 64-bit&quot; --min-disk 1 --disk-format qcow2 --file .&#x2F;images&#x2F;cirros-0.3.5-x86_64-disk.img --container-format bare  --public</span><br><span class="line">openstack image list</span><br></pre></td></tr></table></figure><p>3.部署cinder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">CEPHKEY&#x3D;&#96;kubectl get secret -n rook-ceph rook-ceph-admin-keyring -ojsonpath&#x3D;&#39;&#123;.data.keyring&#125;&#39;|base64 -d|grep key|awk &#39;&#123; print $3 &#125;&#39;&#96;</span><br><span class="line">MON_LIST&#x3D;($(kubectl  get svc -n rook-ceph|grep mon|awk &#39;&#123; print $1 &#125;&#39;))</span><br><span class="line">cat &lt;&lt; EOF | sudo tee &#x2F;tmp&#x2F;cinder_ceph.yaml</span><br><span class="line">---</span><br><span class="line">conf:</span><br><span class="line">  ceph:</span><br><span class="line">    admin_keyring: $CEPHKEY</span><br><span class="line">  cinder:</span><br><span class="line">    DEFAULT:</span><br><span class="line">      enabled_backends: &quot;rook-ceph&quot;</span><br><span class="line">      backup_ceph_user: &quot;admin&quot;</span><br><span class="line">  backends:</span><br><span class="line">    rook-ceph:</span><br><span class="line">      volume_driver: cinder.volume.drivers.rbd.RBDDriver</span><br><span class="line">      volume_backend_name: rook-ceph</span><br><span class="line">      rbd_pool: cinder.volumes</span><br><span class="line">      rbd_flatten_volume_from_snapshot: False</span><br><span class="line">      report_discard_supported: True</span><br><span class="line">      rbd_max_clone_depth: 5</span><br><span class="line">      rbd_store_chunk_size: 4</span><br><span class="line">      rados_connect_timeout: -1</span><br><span class="line">      rbd_user: admin</span><br><span class="line">      rbd_secret_uuid: 3f0133e4-8384-4743-9473-fecacc095c74</span><br><span class="line">      image_volume_cache_enabled: True</span><br><span class="line">      image_volume_cache_max_size_gb: 200</span><br><span class="line">      image_volume_cache_max_count: 50</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;tmp&#x2F;ceph-ceph.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: ceph-etc</span><br><span class="line">  namespace: openstack</span><br><span class="line">data:</span><br><span class="line">  ceph.conf: |</span><br><span class="line">    [global]</span><br><span class="line">    mon_host &#x3D; $&#123;MON_LIST[0]&#125;.rook-ceph.svc.cluster.local:6789,$&#123;MON_LIST[1]&#125;.rook-ceph.svc.cluster.local:6789,$&#123;MON_LIST[2]&#125;.rook-ceph.svc.cluster.local:6789</span><br><span class="line"></span><br><span class="line">    [client.admin]</span><br><span class="line">    keyring &#x3D; &#x2F;etc&#x2F;ceph&#x2F;ceph.client.admin.keyring</span><br><span class="line">    caps mds &#x3D; &quot;allow *&quot;</span><br><span class="line">    caps mon &#x3D; &quot;allow *&quot;</span><br><span class="line">    caps osd &#x3D; &quot;allow *&quot;</span><br><span class="line">    caps mgr &#x3D; &quot;allow *&quot;</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line">kubectl apply -f &#x2F;tmp&#x2F;ceph-ceph.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">helm upgrade --install cinder chartmuseum&#x2F;cinder \</span><br><span class="line">  --namespace&#x3D;openstack \</span><br><span class="line">  --values&#x3D;&#x2F;tmp&#x2F;cinder_ceph.yaml --timeout 1800s</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Available -n openstack deploy&#x2F;cinder-api --timeout&#x3D;300s</span><br><span class="line"># 验证</span><br><span class="line">export OS_CLOUD&#x3D;openstack_helm</span><br><span class="line">openstack volume type list</span><br><span class="line">openstack volume type list --default</span><br></pre></td></tr></table></figure><p>4.部署openvswitch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install openvswitch chartmuseum&#x2F;openvswitch \</span><br><span class="line">  --namespace&#x3D;openstack</span><br><span class="line">sleep 180</span><br><span class="line"># 验证, 查看daemonSet正常启动</span><br><span class="line">[root@master1 ~]# kubectl  get ds -n openstack</span><br><span class="line">NAME                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR         AGE</span><br><span class="line">openvswitch-db         4         4         4       4            4           openvswitch&#x3D;enabled   2m19s</span><br><span class="line">openvswitch-vswitchd   4         4         4       4            4           openvswitch&#x3D;enabled   2m19s</span><br></pre></td></tr></table></figure><p>5.部署Libvirt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CEPHKEY&#x3D;&#96;kubectl get secret -n rook-ceph rook-ceph-admin-keyring -ojsonpath&#x3D;&#39;&#123;.data.keyring&#125;&#39;|base64 -d|grep key|awk &#39;&#123; print $3 &#125;&#39;&#96;</span><br><span class="line">cat &lt;&lt; EOF | sudo tee &#x2F;tmp&#x2F;libvirt_ceph.yaml</span><br><span class="line">---</span><br><span class="line">conf:</span><br><span class="line">  ceph:</span><br><span class="line">    enabled: true</span><br><span class="line">    admin_keyring: $CEPHKEY</span><br><span class="line">    cinder:</span><br><span class="line">      user: &quot;admin&quot;</span><br><span class="line">      keyring: $CEPHKEY</span><br><span class="line">      secret_uuid: 3f0133e4-8384-4743-9473-fecacc095c74</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line">helm upgrade --install libvirt chartmuseum&#x2F;libvirt \</span><br><span class="line">  --namespace&#x3D;openstack --values&#x3D;&#x2F;tmp&#x2F;libvirt_ceph.yaml --timeout 1800s</span><br></pre></td></tr></table></figure><blockquote><p>在没有安装neutron的情况下，libvirt是无法完全启动的，pod处于init状态，查看init日志，kubectl logs -n openstack libvirt-libvirt-default-7trpd -c init，可以看到Entrypoint WARNING: 2022/05/10 02:55:23 entrypoint.go:72: Resolving dependency Pod on same host with labels map[application:neutron component:neutron-ovs-agent] in namespace openstack failed: Found no pods matching labels: map[application:neutron component:neutron-ovs-agent]</p><p>稍后在neutron部署完成后，在验证libvirt是否正常启动</p></blockquote><p>6.部署nova、neutron（Compute Kit）</p><p><strong>需要注意neutron外部网卡的配置！！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 计算组件（Compute Kit）安装过程会比较久（大约20~40分钟），可以通过循环检测判定安装状态</span><br><span class="line">CEPHKEY&#x3D;&#96;kubectl get secret -n rook-ceph rook-ceph-admin-keyring -ojsonpath&#x3D;&#39;&#123;.data.keyring&#125;&#39;|base64 -d|grep key|awk &#39;&#123; print $3 &#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line"># VNCPROXY用到的VIP需要根据实际环境情况传入，脚本只在keepalive按照固定配置情况下生效！！</span><br><span class="line">APISERVER_VIP&#x3D;&#96;cat &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf |grep -A 1 virtual_ipaddress|grep -v virtual_ipaddress|awk &#39;&#123;print $1&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF | sudo tee &#x2F;tmp&#x2F;nova_ceph.yaml</span><br><span class="line">---</span><br><span class="line">pod:</span><br><span class="line">  replicas:</span><br><span class="line">    osapi: 2</span><br><span class="line">    conductor: 2</span><br><span class="line">    novncproxy: 3</span><br><span class="line">conf:</span><br><span class="line">  ceph:</span><br><span class="line">    enabled: true</span><br><span class="line">    admin_keyring: $CEPHKEY</span><br><span class="line">    cinder:</span><br><span class="line">      user: &quot;admin&quot;</span><br><span class="line">      keyring: $CEPHKEY</span><br><span class="line">      secret_uuid: 3f0133e4-8384-4743-9473-fecacc095c74</span><br><span class="line">  nova:</span><br><span class="line">    libvirt:</span><br><span class="line">      rbd_secret_uuid: 3f0133e4-8384-4743-9473-fecacc095c74</span><br><span class="line">      rbd_user: admin</span><br><span class="line">...</span><br><span class="line">EOF</span><br><span class="line">#NOTE: Deploy nova</span><br><span class="line">if [ &quot;x$(systemd-detect-virt)&quot; &#x3D;&#x3D; &quot;xnone&quot; ]; then</span><br><span class="line">  echo &#39;OSH is not being deployed in virtualized environment&#39;</span><br><span class="line">  helm upgrade --install nova chartmuseum&#x2F;nova \</span><br><span class="line">      --namespace&#x3D;openstack \</span><br><span class="line">      --values&#x3D;&#x2F;tmp&#x2F;nova_ceph.yaml \</span><br><span class="line">      --set bootstrap.wait_for_computes.enabled&#x3D;true \</span><br><span class="line">      --set conf.nova.vnc.novncproxy_base_url&#x3D;&quot;http:&#x2F;&#x2F;$&#123;APISERVER_VIP&#125;&#x2F;vnc_auto.html&quot;</span><br><span class="line">      --timeout 1800s</span><br><span class="line">else</span><br><span class="line">  echo &#39;OSH is being deployed in virtualized environment, using qemu for nova&#39;</span><br><span class="line">  helm upgrade --install nova chartmuseum&#x2F;nova \</span><br><span class="line">      --namespace&#x3D;openstack \</span><br><span class="line">      --values&#x3D;&#x2F;tmp&#x2F;nova_ceph.yaml \</span><br><span class="line">      --set bootstrap.wait_for_computes.enabled&#x3D;true \</span><br><span class="line">      --set conf.nova.libvirt.virt_type&#x3D;qemu \</span><br><span class="line">      --set conf.nova.libvirt.cpu_mode&#x3D;none \</span><br><span class="line">      --set conf.nova.vnc.novncproxy_base_url&#x3D;&quot;http:&#x2F;&#x2F;$&#123;APISERVER_VIP&#125;&#x2F;vnc_auto.html&quot; \</span><br><span class="line">      --timeout 1800s</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#NOTE: Deploy placement</span><br><span class="line">helm upgrade --install placement chartmuseum&#x2F;placement \</span><br><span class="line">    --namespace&#x3D;openstack --timeout 1800s</span><br><span class="line"></span><br><span class="line">#NOTE: Deploy neutron</span><br><span class="line"></span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;注意&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">PUBLIC_NET_NIC&#x3D;eth0 # 设置public网络的桥接网卡</span><br><span class="line"># 指定物理网卡或桥接网络，本例中只有一张网卡，同时作为private和public，注意，一张网卡时不能指定为eth0，eth0被桥接后不带地址！！</span><br><span class="line">PRIVATE_NET_NIC&#x3D;br-ex # 设置private业务网网卡</span><br><span class="line">GATEWAY&#x3D;10.10.1.1 # 设置外部网关</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;注意&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">tee &#x2F;tmp&#x2F;neutron.yaml &lt;&lt; EOF</span><br><span class="line">custom_share_l3_gateway: &quot;$GATEWAY&quot;</span><br><span class="line">network:</span><br><span class="line">  interface:</span><br><span class="line">    tunnel: br-ex</span><br><span class="line">pod:</span><br><span class="line">  replicas:</span><br><span class="line">    server: 2</span><br><span class="line">conf:</span><br><span class="line">  auto_bridge_add:</span><br><span class="line">    br-ex: $PUBLIC_NET_NIC</span><br><span class="line">  neutron:</span><br><span class="line">    DEFAULT:</span><br><span class="line">      l3_ha: False</span><br><span class="line">      max_l3_agents_per_router: 1</span><br><span class="line">      l3_ha_network_type: vxlan</span><br><span class="line">      dhcp_agents_per_network: 1</span><br><span class="line">  plugins:</span><br><span class="line">    ml2_conf:</span><br><span class="line">      ml2_type_flat:</span><br><span class="line">        flat_networks: public</span><br><span class="line">    openvswitch_agent:</span><br><span class="line">      agent:</span><br><span class="line">        tunnel_types: vxlan</span><br><span class="line">      ovs:</span><br><span class="line">        bridge_mappings: public:br-ex</span><br><span class="line">    linuxbridge_agent:</span><br><span class="line">      linux_bridge:</span><br><span class="line">        bridge_mappings: public:br-ex</span><br><span class="line">EOF</span><br><span class="line">helm upgrade --install neutron chartmuseum&#x2F;neutron \</span><br><span class="line">    --namespace&#x3D;openstack \</span><br><span class="line">    --values&#x3D;&#x2F;tmp&#x2F;neutron.yaml --timeout 1800s</span><br><span class="line"></span><br><span class="line">sleep 180s</span><br><span class="line"></span><br><span class="line">kubectl get pod -n openstack |grep ovs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 等待所有pod启动完成</span><br><span class="line">kubectl get pod -n openstack |grep -v Running |grep -v Completed</span><br><span class="line"></span><br><span class="line"># 验证</span><br><span class="line">export OS_CLOUD&#x3D;openstack_helm</span><br><span class="line">[root@knode1 ~]# openstack service list</span><br><span class="line"></span><br><span class="line">+----------------------------------+-----------+-----------+</span><br><span class="line">| ID                               | Name      | Type      |</span><br><span class="line">+----------------------------------+-----------+-----------+</span><br><span class="line">| 4b8e84c1b0964d858b9c64291c06e79e | cinder    | volumev3  |</span><br><span class="line">| 524d333166fe41359178ffbd4e6c216e | keystone  | identity  |</span><br><span class="line">| 53549bf12e134837a9fb8606a5c1a027 | placement | placement |</span><br><span class="line">| 68a103d3bfde490da4be9c66b09717cb | neutron   | network   |</span><br><span class="line">| 9362ca20a79b469aa76b874dc2e06c3b | glance    | image     |</span><br><span class="line">| c695d0d4ca5b463fbfb6b8e7379f459e | nova      | compute   |</span><br><span class="line">+----------------------------------+-----------+-----------+</span><br><span class="line">[root@knode1 ~]# openstack compute service list</span><br><span class="line">+----+----------------+---------------------------------+----------+---------+-------+----------------------------+</span><br><span class="line">| ID | Binary         | Host                            | Zone     | Status  | State | Updated At                 |</span><br><span class="line">+----+----------------+---------------------------------+----------+---------+-------+----------------------------+</span><br><span class="line">|  4 | nova-scheduler | nova-scheduler-69cbb6b779-59b28 | internal | enabled | up    | 2022-05-13T14:55:04.000000 |</span><br><span class="line">|  9 | nova-conductor | nova-conductor-6477bc8d6c-zbrw2 | internal | enabled | up    | 2022-05-13T14:54:57.000000 |</span><br><span class="line">| 12 | nova-conductor | nova-conductor-6477bc8d6c-rvwrq | internal | enabled | up    | 2022-05-13T14:55:02.000000 |</span><br><span class="line">| 18 | nova-compute   | knode1                          | nova     | enabled | up    | 2022-05-13T14:54:57.000000 |</span><br><span class="line">| 20 | nova-compute   | knode3                          | nova     | enabled | up    | 2022-05-13T14:55:02.000000 |</span><br><span class="line">| 21 | nova-compute   | knode2                          | nova     | enabled | up    | 2022-05-13T14:55:00.000000 |</span><br><span class="line">| 23 | nova-compute   | knode4                          | nova     | enabled | up    | 2022-05-13T14:55:00.000000 |</span><br><span class="line">+----+----------------+---------------------------------+----------+---------+-------+----------------------------+</span><br><span class="line">[root@knode1 ~]# openstack network agent list</span><br><span class="line">+--------------------------------------+--------------------+--------+-------------------+-------+-------+---------------------------+</span><br><span class="line">| ID                                   | Agent Type         | Host   | Availability Zone | Alive | State | Binary                    |</span><br><span class="line">+--------------------------------------+--------------------+--------+-------------------+-------+-------+---------------------------+</span><br><span class="line">| 0c2397e8-0afd-47a7-a554-b67b089e1adf | Metadata agent     | knode3 | None              | :-)   | UP    | neutron-metadata-agent    |</span><br><span class="line">| 327e1437-0963-4990-8009-3ecb259d3c80 | DHCP agent         | knode2 | nova              | :-)   | UP    | neutron-dhcp-agent        |</span><br><span class="line">| 3b554200-02ec-41d5-81da-ea05741337e6 | Metadata agent     | knode1 | None              | :-)   | UP    | neutron-metadata-agent    |</span><br><span class="line">| 55ed67d8-77dd-4192-8022-48f9c7e26969 | DHCP agent         | knode1 | nova              | :-)   | UP    | neutron-dhcp-agent        |</span><br><span class="line">| 624755f4-8031-4b5d-830f-6c2ec656b111 | Metadata agent     | knode2 | None              | :-)   | UP    | neutron-metadata-agent    |</span><br><span class="line">| 8e1f1825-7ab5-4589-8c43-81e2395c6fe8 | Open vSwitch agent | knode1 | None              | :-)   | UP    | neutron-openvswitch-agent |</span><br><span class="line">| 8f6af6dc-4eac-4a9f-8c46-b8ad1c3bd64e | Open vSwitch agent | knode3 | None              | :-)   | UP    | neutron-openvswitch-agent |</span><br><span class="line">| 9a1d6634-cb30-4011-92cb-9e07ae981d05 | L3 agent           | knode2 | nova              | :-)   | UP    | neutron-l3-agent          |</span><br><span class="line">| bf372b1f-4b01-4fa4-8309-9d6975bb8373 | L3 agent           | knode1 | nova              | :-)   | UP    | neutron-l3-agent          |</span><br><span class="line">| c8073699-e64f-4dea-b1f4-a82d2f97c46e | DHCP agent         | knode3 | nova              | :-)   | UP    | neutron-dhcp-agent        |</span><br><span class="line">| ce01381b-0843-4af8-bf10-d443dded980e | Open vSwitch agent | knode4 | None              | :-)   | UP    | neutron-openvswitch-agent |</span><br><span class="line">| d9f47dc5-22d5-4556-b1eb-7e9c8a0c7282 | L3 agent           | knode3 | nova              | :-)   | UP    | neutron-l3-agent          |</span><br><span class="line">| ee1d334d-88c3-45c1-83aa-c6bd08449d2d | Open vSwitch agent | knode2 | None              | :-)   | UP    | neutron-openvswitch-agent |</span><br><span class="line">+--------------------------------------+--------------------+--------+-------------------+-------+-------+---------------------------+</span><br><span class="line">[root@knode1 ~]# openstack hypervisor list</span><br><span class="line">+----+---------------------+-----------------+-------------+-------+</span><br><span class="line">| ID | Hypervisor Hostname | Hypervisor Type | Host IP     | State |</span><br><span class="line">+----+---------------------+-----------------+-------------+-------+</span><br><span class="line">|  2 | knode1              | QEMU            | 10.10.1.100 | up    |</span><br><span class="line">|  5 | knode3              | QEMU            | 10.10.1.120 | up    |</span><br><span class="line">|  8 | knode2              | QEMU            | 10.10.1.110 | up    |</span><br><span class="line">|  9 | knode4              | QEMU            | 10.10.1.130 | up    |</span><br><span class="line">+----+---------------------+-----------------+-------------+-------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 在所有节点添加默认路由，避免重启后丢失</span><br><span class="line">ip route | grep default || ip route add default via $GATEWAY dev br-ex</span><br><span class="line">echo &quot;ip route | grep default || ip route add default via $GATEWAY dev br-ex&quot; &gt;&gt; &#x2F;etc&#x2F;rc.local</span><br></pre></td></tr></table></figure><p>7.安装heat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install heat chartmuseum&#x2F;heat \</span><br><span class="line">  --namespace&#x3D;openstack</span><br><span class="line"></span><br><span class="line"># 验证</span><br><span class="line">export OS_CLOUD&#x3D;openstack_helm</span><br><span class="line">openstack service list</span><br><span class="line">openstack endpoint list</span><br><span class="line"></span><br><span class="line">openstack --os-interface public orchestration service list</span><br><span class="line">+------------------------------+-------------+--------------------------------------+-------------+--------+----------------------------+--------+</span><br><span class="line">| Hostname                     | Binary      | Engine ID                            | Host        | Topic  | Updated At                 | Status |</span><br><span class="line">+------------------------------+-------------+--------------------------------------+-------------+--------+----------------------------+--------+</span><br><span class="line">| heat-engine-5bc7886f47-vps7v | heat-engine | df962df7-3829-4bff-8c77-3df5b7cadd49 | heat-engine | engine | 2022-05-13T15:11:50.000000 | up     |</span><br><span class="line">| heat-engine-5bc7886f47-khr52 | heat-engine | 5358bba9-aa70-4bb2-be57-25138763dd16 | heat-engine | engine | 2022-05-13T15:11:51.000000 | up     |</span><br><span class="line">+------------------------------+-------------+--------------------------------------+-------------+--------+----------------------------+--------+</span><br></pre></td></tr></table></figure><p>8.安装horizon（可选）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --install horizon chartmuseum&#x2F;horizon \</span><br><span class="line">  --namespace&#x3D;openstack</span><br><span class="line"># 检查pod启动</span><br><span class="line">kubectl  get pod -n openstack -owide|grep -v Run|grep -v Com</span><br></pre></td></tr></table></figure><h1 id="五-注意事项"><a href="#五-注意事项" class="headerlink" title="五.注意事项"></a>五.注意事项</h1><p><strong>1.步骤中wait方式等待可能会不准确，即pod未就绪，但deploy状态已就绪，需要确认pod处于Running后，再进行对应验证操作，否则会失败</strong></p><p><strong>2.在placement安装过程中，nova相关组件可能会出现认证错误，在neutron完成安装并启动完成前可以忽视这些错误</strong></p><p><strong>3.在db sync过程中，可能由于DB锁未释放等问题，产生死锁，但是db-sync 或init pod crash，可以忽略，等待后会自动恢复</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;节点名&lt;/th&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;knode1&lt;/td&gt;
&lt;td&gt;融合节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;knode2&lt;/td&gt;
&lt;td&gt;融合节点&lt;/</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
    <category term="openstack" scheme="http://example.com/tags/openstack/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm部署生产k8s</title>
    <link href="http://example.com/2022/04/15/kubeadm%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7k8s/"/>
    <id>http://example.com/2022/04/15/kubeadm%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7k8s/</id>
    <published>2022-04-15T07:59:59.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-环境准备"><a href="#一-环境准备" class="headerlink" title="一.环境准备"></a>一.环境准备</h1><table><thead><tr><th>IP</th><th>主机名/类型</th><th>ApiServer端口号</th></tr></thead><tbody><tr><td>192.168.122.213</td><td>knode1</td><td>6443</td></tr><tr><td>192.168.122.74</td><td>knode2</td><td>6443</td></tr><tr><td>192.168.122.18</td><td>knode3</td><td>6443</td></tr><tr><td>192.168.122.150</td><td>VIP</td><td>7443</td></tr></tbody></table><p>1.基础参数配置（所有节点）</p><p>设置主机名：</p><p><code>hostnamectl set-hostname node1</code></p><p>生成密钥、免密登陆：</p><p><code>ssh-keygen</code>，<code>ssh-copy-id</code> </p><p>关闭防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>加载 <code>br_netfilter</code> 模块  ，设置桥接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe br_netfilter</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><p>2.安装并配置docker（所有节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker                   docker-client                   docker-client-latest                   docker-common                   docker-latest                   docker-latest-logrotate                   docker-logrotate                   docker-engine</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager     --add-repo     https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo mkdir &#x2F;etc&#x2F;docker</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="二-通过kubeadm部署融合生产环境（3节点）"><a href="#二-通过kubeadm部署融合生产环境（3节点）" class="headerlink" title="二.通过kubeadm部署融合生产环境（3节点）"></a>二.通过kubeadm部署融合生产环境（3节点）</h1><p>1.安装kubeadm（所有节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-\$basearch</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">exclude&#x3D;kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#39;s&#x2F;^SELINUX&#x3D;enforcing$&#x2F;SELINUX&#x3D;permissive&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes&#x3D;kubernetes</span><br><span class="line"></span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>2.初始化环境变量（所有节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">APISERVER_VIP&#x3D;192.168.122.150</span><br><span class="line"></span><br><span class="line">APISERVER_DEST_PORT&#x3D;7443</span><br><span class="line"></span><br><span class="line">APISERVER_SRC_PORT&#x3D;6443</span><br><span class="line"></span><br><span class="line">HOST1_ID&#x3D;knode1</span><br><span class="line"></span><br><span class="line">HOST1_ADDRESS&#x3D;192.168.122.213</span><br><span class="line"></span><br><span class="line">HOST2_ID&#x3D;knode2</span><br><span class="line"></span><br><span class="line">HOST2_ADDRESS&#x3D;192.168.122.74</span><br><span class="line"></span><br><span class="line">HOST3_ID&#x3D;knode3</span><br><span class="line"></span><br><span class="line">HOST3_ADDRESS&#x3D;192.168.122.18</span><br></pre></td></tr></table></figure><p>3.为kube-api配置负载均衡（keepalive+haproxy）（所有控制节点）</p><p>keepalive&amp; haproxy配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">########### keepalived ###########</span><br><span class="line">sudo yum install -y keepalived</span><br><span class="line">sudo cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script check_apiserver &#123;</span><br><span class="line">  script &quot;&#x2F;etc&#x2F;keepalived&#x2F;check_apiserver.sh&quot;</span><br><span class="line">  interval 3</span><br><span class="line">  weight -2</span><br><span class="line">  fall 10</span><br><span class="line">  rise 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 42</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        $&#123;APISERVER_VIP&#125; # VIP地址</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_apiserver</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;keepalived&#x2F;check_apiserver.sh</span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">errorExit() &#123;</span><br><span class="line">    echo &quot;*** $*&quot; 1&gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curl --silent --max-time 2 --insecure https:&#x2F;&#x2F;localhost:$&#123;APISERVER_DEST_PORT&#125;&#x2F; -o &#x2F;dev&#x2F;null || errorExit &quot;Error GET https:&#x2F;&#x2F;localhost:$&#123;APISERVER_DEST_PORT&#125;&#x2F;&quot;</span><br><span class="line">if ip addr | grep -q $&#123;APISERVER_VIP&#125;; then</span><br><span class="line">    curl --silent --max-time 2 --insecure https:&#x2F;&#x2F;$&#123;APISERVER_VIP&#125;:$&#123;APISERVER_DEST_PORT&#125;&#x2F; -o &#x2F;dev&#x2F;null || errorExit &quot;Error GET https:&#x2F;&#x2F;$&#123;APISERVER_VIP&#125;:$&#123;APISERVER_DEST_PORT&#125;&#x2F;&quot;</span><br><span class="line">fi</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">########### haproxy ###########</span><br><span class="line">sudo yum install -y haproxy</span><br><span class="line">sudo cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</span><br><span class="line"># &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># Global settings</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">global</span><br><span class="line">    log &#x2F;dev&#x2F;log local0</span><br><span class="line">    log &#x2F;dev&#x2F;log local1 notice</span><br><span class="line">    daemon</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># common defaults that all the &#39;listen&#39; and &#39;backend&#39; sections will</span><br><span class="line"># use if not designated in their block</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    log                     global</span><br><span class="line">    option                  httplog</span><br><span class="line">    option                  dontlognull</span><br><span class="line">    option http-server-close</span><br><span class="line">    option forwardfor       except 127.0.0.0&#x2F;8</span><br><span class="line">    option                  redispatch</span><br><span class="line">    retries                 1</span><br><span class="line">    timeout http-request    10s</span><br><span class="line">    timeout queue           20s</span><br><span class="line">    timeout connect         5s</span><br><span class="line">    timeout client          20s</span><br><span class="line">    timeout server          20s</span><br><span class="line">    timeout http-keep-alive 10s</span><br><span class="line">    timeout check           10s</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># apiserver frontend which proxys to the control plane nodes</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">frontend apiserver</span><br><span class="line">    bind *:$&#123;APISERVER_DEST_PORT&#125;</span><br><span class="line">    mode tcp</span><br><span class="line">    option tcplog</span><br><span class="line">    default_backend apiserver</span><br><span class="line"></span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># round robin balancing for apiserver</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">backend apiserver</span><br><span class="line">    option httpchk GET &#x2F;healthz</span><br><span class="line">    http-check expect status 200</span><br><span class="line">    mode tcp</span><br><span class="line">    option ssl-hello-chk</span><br><span class="line">    balance     roundrobin</span><br><span class="line">        server $&#123;HOST1_ID&#125; $&#123;HOST1_ADDRESS&#125;:$&#123;APISERVER_SRC_PORT&#125; check</span><br><span class="line">        server $&#123;HOST2_ID&#125; $&#123;HOST2_ADDRESS&#125;:$&#123;APISERVER_SRC_PORT&#125; check</span><br><span class="line">        server $&#123;HOST3_ID&#125; $&#123;HOST3_ADDRESS&#125;:$&#123;APISERVER_SRC_PORT&#125; check</span><br><span class="line">EOF</span><br><span class="line">systemctl enable haproxy --now</span><br><span class="line">systemctl enable keepalived --now</span><br></pre></td></tr></table></figure><p>4.初始化控制平面（第一个控制节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">########### init first control ###########</span><br><span class="line"></span><br><span class="line">sudo kubeadm init --control-plane-endpoint &quot;$&#123;APISERVER_VIP&#125;:$&#123;APISERVER_DEST_PORT&#125;&quot; --upload-certs  --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 --kubernetes-version 1.23.5</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure><p>5.安装flannel网络插件（vxlan）（第一个控制节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line">sudo cat &lt;&lt;EOF | sudo tee &#x2F;tmp&#x2F;flannel.yaml</span><br><span class="line">---</span><br><span class="line">apiVersion: policy&#x2F;v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: psp.flannel.unprivileged</span><br><span class="line">  annotations:</span><br><span class="line">    seccomp.security.alpha.kubernetes.io&#x2F;allowedProfileNames: docker&#x2F;default</span><br><span class="line">    seccomp.security.alpha.kubernetes.io&#x2F;defaultProfileName: docker&#x2F;default</span><br><span class="line">    apparmor.security.beta.kubernetes.io&#x2F;allowedProfileNames: runtime&#x2F;default</span><br><span class="line">    apparmor.security.beta.kubernetes.io&#x2F;defaultProfileName: runtime&#x2F;default</span><br><span class="line">spec:</span><br><span class="line">  privileged: false</span><br><span class="line">  volumes:</span><br><span class="line">  - configMap</span><br><span class="line">  - secret</span><br><span class="line">  - emptyDir</span><br><span class="line">  - hostPath</span><br><span class="line">  allowedHostPaths:</span><br><span class="line">  - pathPrefix: &quot;&#x2F;etc&#x2F;cni&#x2F;net.d&quot;</span><br><span class="line">  - pathPrefix: &quot;&#x2F;etc&#x2F;kube-flannel&quot;</span><br><span class="line">  - pathPrefix: &quot;&#x2F;run&#x2F;flannel&quot;</span><br><span class="line">  readOnlyRootFilesystem: false</span><br><span class="line">  # Users and groups</span><br><span class="line">  runAsUser:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  supplementalGroups:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  fsGroup:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  # Privilege Escalation</span><br><span class="line">  allowPrivilegeEscalation: false</span><br><span class="line">  defaultAllowPrivilegeEscalation: false</span><br><span class="line">  # Capabilities</span><br><span class="line">  allowedCapabilities: [&#39;NET_ADMIN&#39;, &#39;NET_RAW&#39;]</span><br><span class="line">  defaultAddCapabilities: []</span><br><span class="line">  requiredDropCapabilities: []</span><br><span class="line">  # Host namespaces</span><br><span class="line">  hostPID: false</span><br><span class="line">  hostIPC: false</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  hostPorts:</span><br><span class="line">  - min: 0</span><br><span class="line">    max: 65535</span><br><span class="line">  # SELinux</span><br><span class="line">  seLinux:</span><br><span class="line">    # SELinux is unused in CaaSP</span><br><span class="line">    rule: &#39;RunAsAny&#39;</span><br><span class="line">---</span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: flannel</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&#39;extensions&#39;]</span><br><span class="line">  resources: [&#39;podsecuritypolicies&#39;]</span><br><span class="line">  verbs: [&#39;use&#39;]</span><br><span class="line">  resourceNames: [&#39;psp.flannel.unprivileged&#39;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - pods</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - nodes&#x2F;status</span><br><span class="line">  verbs:</span><br><span class="line">  - patch</span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: flannel</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: flannel</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: flannel</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: flannel</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-flannel-cfg</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    tier: node</span><br><span class="line">    app: flannel</span><br><span class="line">data:</span><br><span class="line">  cni-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;cbr0&quot;,</span><br><span class="line">      &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span><br><span class="line">      &quot;plugins&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;flannel&quot;,</span><br><span class="line">          &quot;delegate&quot;: &#123;</span><br><span class="line">            &quot;hairpinMode&quot;: true,</span><br><span class="line">            &quot;isDefaultGateway&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">          &quot;capabilities&quot;: &#123;</span><br><span class="line">            &quot;portMappings&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0&#x2F;16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-flannel-ds</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    tier: node</span><br><span class="line">    app: flannel</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: flannel</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        tier: node</span><br><span class="line">        app: flannel</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: kubernetes.io&#x2F;os</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - linux</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      priorityClassName: system-node-critical</span><br><span class="line">      tolerations:</span><br><span class="line">      - operator: Exists</span><br><span class="line">        effect: NoSchedule</span><br><span class="line">      serviceAccountName: flannel</span><br><span class="line">      initContainers:</span><br><span class="line">      - name: install-cni-plugin</span><br><span class="line">       #image: flannelcni&#x2F;flannel-cni-plugin:v1.0.1 for ppc64le and mips64le (dockerhub limitations may apply)</span><br><span class="line">        image: rancher&#x2F;mirrored-flannelcni-flannel-cni-plugin:v1.0.1</span><br><span class="line">        command:</span><br><span class="line">        - cp</span><br><span class="line">        args:</span><br><span class="line">        - -f</span><br><span class="line">        - &#x2F;flannel</span><br><span class="line">        - &#x2F;opt&#x2F;cni&#x2F;bin&#x2F;flannel</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: cni-plugin</span><br><span class="line">          mountPath: &#x2F;opt&#x2F;cni&#x2F;bin</span><br><span class="line">      - name: install-cni</span><br><span class="line">       #image: flannelcni&#x2F;flannel:v0.17.0 for ppc64le and mips64le (dockerhub limitations may apply)</span><br><span class="line">        image: rancher&#x2F;mirrored-flannelcni-flannel:v0.17.0</span><br><span class="line">        command:</span><br><span class="line">        - cp</span><br><span class="line">        args:</span><br><span class="line">        - -f</span><br><span class="line">        - &#x2F;etc&#x2F;kube-flannel&#x2F;cni-conf.json</span><br><span class="line">        - &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;10-flannel.conflist</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: cni</span><br><span class="line">          mountPath: &#x2F;etc&#x2F;cni&#x2F;net.d</span><br><span class="line">        - name: flannel-cfg</span><br><span class="line">          mountPath: &#x2F;etc&#x2F;kube-flannel&#x2F;</span><br><span class="line">      containers:</span><br><span class="line">      - name: kube-flannel</span><br><span class="line">       #image: flannelcni&#x2F;flannel:v0.17.0 for ppc64le and mips64le (dockerhub limitations may apply)</span><br><span class="line">        image: rancher&#x2F;mirrored-flannelcni-flannel:v0.17.0</span><br><span class="line">        command:</span><br><span class="line">        - &#x2F;opt&#x2F;bin&#x2F;flanneld</span><br><span class="line">        args:</span><br><span class="line">        - --ip-masq</span><br><span class="line">        - --kube-subnet-mgr</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: &quot;100m&quot;</span><br><span class="line">            memory: &quot;50Mi&quot;</span><br><span class="line">          limits:</span><br><span class="line">            cpu: &quot;100m&quot;</span><br><span class="line">            memory: &quot;50Mi&quot;</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: false</span><br><span class="line">          capabilities:</span><br><span class="line">            add: [&quot;NET_ADMIN&quot;, &quot;NET_RAW&quot;]</span><br><span class="line">        env:</span><br><span class="line">        - name: POD_NAME</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: metadata.name</span><br><span class="line">        - name: POD_NAMESPACE</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: metadata.namespace</span><br><span class="line">        - name: EVENT_QUEUE_DEPTH</span><br><span class="line">          value: &quot;5000&quot;</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: run</span><br><span class="line">          mountPath: &#x2F;run&#x2F;flannel</span><br><span class="line">        - name: flannel-cfg</span><br><span class="line">          mountPath: &#x2F;etc&#x2F;kube-flannel&#x2F;</span><br><span class="line">        - name: xtables-lock</span><br><span class="line">          mountPath: &#x2F;run&#x2F;xtables.lock</span><br><span class="line">      volumes:</span><br><span class="line">      - name: run</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;run&#x2F;flannel</span><br><span class="line">      - name: cni-plugin</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;opt&#x2F;cni&#x2F;bin</span><br><span class="line">      - name: cni</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;etc&#x2F;cni&#x2F;net.d</span><br><span class="line">      - name: flannel-cfg</span><br><span class="line">        configMap:</span><br><span class="line">          name: kube-flannel-cfg</span><br><span class="line">      - name: xtables-lock</span><br><span class="line">        hostPath:</span><br><span class="line">          path: &#x2F;run&#x2F;xtables.lock</span><br><span class="line">          type: FileOrCreate</span><br><span class="line">EOF</span><br><span class="line">kubectl  apply -f &#x2F;tmp&#x2F;flannel.yaml</span><br></pre></td></tr></table></figure><p>6.添加额外的控制节点</p><p>查看第一个控制节点状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@knode1 ~]# kubectl get pod -n kube-system -w</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-64897985d-4hjxc          1&#x2F;1     Running   0          2m6s</span><br><span class="line">coredns-64897985d-9x4lz          1&#x2F;1     Running   0          2m6s</span><br><span class="line">etcd-knode1                      1&#x2F;1     Running   1          2m15s</span><br><span class="line">kube-apiserver-knode1            1&#x2F;1     Running   1          2m15s</span><br><span class="line">kube-controller-manager-knode1   1&#x2F;1     Running   0          2m14s</span><br><span class="line">kube-flannel-ds-v45xx            1&#x2F;1     Running   0          45s</span><br><span class="line">kube-proxy-b55jc                 1&#x2F;1     Running   0          2m6s</span><br><span class="line">kube-scheduler-knode1            1&#x2F;1     Running   1          2m15s</span><br></pre></td></tr></table></figure><p>获取密钥信息（在第一个控制节点执行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FIRSTCONTROLNODE&#x3D;192.168.122.213</span><br><span class="line">TOKEN&#x3D;&#96;kubeadm token create&#96;</span><br><span class="line">DISCOVERYTOKEHASH&#x3D;&#96;openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | \</span><br><span class="line">   openssl dgst -sha256 -hex | sed &#39;s&#x2F;^.* &#x2F;&#x2F;&#39;&#96;</span><br><span class="line">CERTKEY&#x3D;&#96;kubeadm init phase upload-certs --upload-certs --one-output|grep -v upload-certs&#96;</span><br></pre></td></tr></table></figure><p>加入额外控制节点（在需要加入的额外控制节点上执行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm join $&#123;FIRSTCONTROLNODE&#125;:6443 --token $&#123;TOKEN&#125; --discovery-token-ca-cert-hash sha256:$&#123;DISCOVERYTOKEHASH&#125; --control-plane --certificate-key $&#123;CERTKEY&#125;</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure><p>加入额外node节点（在需要加入的额外node节点上执行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubeadm join $&#123;FIRSTCONTROLNODE&#125;:6443 --token $&#123;TOKEN&#125; --discovery-token-ca-cert-hash sha256:$&#123;DISCOVERYTOKEHASH&#125;</span><br></pre></td></tr></table></figure><h1 id="三-验证"><a href="#三-验证" class="headerlink" title="三.验证"></a>三.验证</h1><p>在任意控制节点执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@knode1 ~]# kubectl  get nodes</span><br><span class="line">NAME     STATUS   ROLES                  AGE     VERSION</span><br><span class="line">knode1   Ready    control-plane,master   3m27s   v1.23.6</span><br><span class="line">knode2   Ready    control-plane,master   59s     v1.23.6</span><br><span class="line">knode3   Ready    control-plane,master   58s     v1.23.6</span><br><span class="line">knode4   Ready    &lt;none&gt;                 11s     v1.23.6</span><br></pre></td></tr></table></figure><h1 id="四-离线部署"><a href="#四-离线部署" class="headerlink" title="四.离线部署"></a>四.离线部署</h1><p>1.如果联机部署需要配置代理访问，包括镜像源和yum源代理，如果本地离线部署，需要提前准备好本地镜像仓库与本地yum源：</p><p>kubernetes yum源参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-$basearch</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">exclude&#x3D;kubelet kubeadm kubectl</span><br><span class="line">proxy&#x3D;http:&#x2F;&#x2F;knode1:8090</span><br></pre></td></tr></table></figure><p>下载离线镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list</span><br><span class="line">kubeadm config images pull</span><br><span class="line">docker pull rancher&#x2F;mirrored-flannelcni-flannel:v0.17.0</span><br><span class="line">docker pull rancher&#x2F;mirrored-flannelcni-flannel-cni-plugin:v1.0.1</span><br></pre></td></tr></table></figure><p>2.打包镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMAGES_LIST&#x3D;($(docker  images   | sed  &#39;1d&#39; | awk  &#39;&#123;print $1&quot;:&quot;$2&#125;&#39;))</span><br><span class="line">docker save $&#123;IMAGES_LIST[*]&#125;  -o  all-images.tar.gz</span><br></pre></td></tr></table></figure><p>3.在其他节点导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; all-images.tar.gz</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-环境准备&quot;&gt;&lt;a href=&quot;#一-环境准备&quot; class=&quot;headerlink&quot; title=&quot;一.环境准备&quot;&gt;&lt;/a&gt;一.环境准备&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;主机名/类型&lt;/th&gt;
&lt;th&gt;ApiS</summary>
      
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>一致性话题</title>
    <link href="http://example.com/2022/01/19/%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%9D%E9%A2%98/"/>
    <id>http://example.com/2022/01/19/%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%9D%E9%A2%98/</id>
    <published>2022-01-19T02:25:56.000Z</published>
    <updated>2022-11-28T09:22:46.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一致性概述"><a href="#一致性概述" class="headerlink" title="一致性概述"></a><strong>一致性概述</strong></h2><p>一致性问题是分布式中间件中必须考虑的问题之一，此篇中我们将对几种常见的一致性模型进行分析。</p><span id="more"></span><h2 id="一致性分类"><a href="#一致性分类" class="headerlink" title="一致性分类"></a>一致性分类</h2><h4 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h4><h4 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h4>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一致性概述&quot;&gt;&lt;a href=&quot;#一致性概述&quot; class=&quot;headerlink&quot; title=&quot;一致性概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;一致性概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;一致性问题是分布式中间件中必须考虑的问题之一，此篇中我们将对几种常见的一致性模型进行分析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式中间件" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>kubelet</title>
    <link href="http://example.com/2021/06/23/kubelet/"/>
    <id>http://example.com/2021/06/23/kubelet/</id>
    <published>2021-06-23T08:43:01.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://blog.neilcloud.net/2021/04/20/%E5%85%B3%E4%BA%8ECSI%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">CSI的文章</a>中，我们分析了K8S对存储卷的操作，这里除了CSI Controller对PVC的定义外，kubelet也起到了很大的作用，本文主要针对kubelet的实现逻辑进行分析</p><span id="more"></span><h2 id="Kubelet的工作原理"><a href="#Kubelet的工作原理" class="headerlink" title="Kubelet的工作原理"></a>Kubelet的工作原理</h2><p>kubelet工作在K8S的每个节点上，承担了与节点交互的角色，例如挂载volume卷，创建容器namespace等。</p><p>下图是kubelet工作原理的示意图：</p><img src="/images/914e097aed10b9ff39b509759f8b1d03.png" alt="img" style="zoom:67%;" /><p>可以看出，kubelet本身也是一个控制器，遵循k8s控制器的设计模式，</p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://blog.neilcloud.net/2021/04/20/%E5%85%B3%E4%BA%8ECSI%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/&quot;&gt;CSI的文章&lt;/a&gt;中，我们分析了K8S对存储卷的操作，这里除了CSI Controller对PVC的定义外，kubelet也起到了很大的作用，本文主要针对kubelet的实现逻辑进行分析&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>garbage-collector-controller</title>
    <link href="http://example.com/2021/06/15/garbage-collector-controller/"/>
    <id>http://example.com/2021/06/15/garbage-collector-controller/</id>
    <published>2021-06-15T02:44:16.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes在删除对象时，其对应的controller并不会真正去删除对象，删除对象工作是由GarbageCollectorController负责的。</p><span id="more"></span><p>当删除一个对象时，会根据删除策略来对资源进行回收处理。</p><h3 id="K8S中的删除策略"><a href="#K8S中的删除策略" class="headerlink" title="K8S中的删除策略"></a>K8S中的删除策略</h3><p>Orphan</p><p>Foreground</p><p>Background</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubernetes在删除对象时，其对应的controller并不会真正去删除对象，删除对象工作是由GarbageCollectorController负责的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>关于CSI，看这一篇就够了</title>
    <link href="http://example.com/2021/04/20/%E5%85%B3%E4%BA%8ECSI%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://example.com/2021/04/20/%E5%85%B3%E4%BA%8ECSI%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</id>
    <published>2021-04-20T08:37:27.000Z</published>
    <updated>2023-05-22T11:53:35.873Z</updated>
    
    <content type="html"><![CDATA[<p>在了解k8s的CSI plugin编写前，我们需要先了解下有关K8S的持久化存储机制。</p><span id="more"></span><h2 id="理解k8s持久化存储"><a href="#理解k8s持久化存储" class="headerlink" title="理解k8s持久化存储"></a>理解k8s持久化存储</h2><p>在k8s中，持久化存储采用PV和PVC进行绑定的的方式进行管理。</p><p><em>PV（PersistentVolume）：</em>存储卷对象映射，一般由管理员手动创建或通过存储插件（External Provisioner）创建。示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv0003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span> <span class="comment"># K8S支持两种volumeMode：Filesystem和Block</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 三种策略可选：Retain\Recycle\Delete，只有NFS和HostPath支持Recycle（纯调用rm -rf命令进行文件系统级别删除）</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">slow</span></span><br><span class="line">  <span class="attr">mountOptions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p><em>PVC（PersistentVolumeClaim）</em>：存储卷声明，一般由开发人员定义，对于支持Dynamic Provisioning的存储类型，通过对PVC的声明（可以在pod中完成），可以让PersistentVolumeController找到一块合适的PV与PVC进行bound操作。示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">fast</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure><p>这种绑定操作可以是<strong>静态的（Static Provisioning）</strong>，也可以是<strong>动态的（Dynamic Provisioning）</strong></p><p>首先说静态，通过静态方式进行时，由管理员创建PV，通过PersistentVolumeController，k8s可以完成PV和PVC的绑定，PersistentVolumeController(<code>pkg/controller/volume/persistentvolume/pv_controller.go</code>)存在一个控制循环，不断遍历所有可用状态的PV，尝试与PVC进行绑定（Bound）操作，绑定成功后，则为声明该PVC的Pod提供存储服务。</p><h3 id="PV和PVC绑定调度流程"><a href="#PV和PVC绑定调度流程" class="headerlink" title="PV和PVC绑定调度流程"></a>PV和PVC绑定调度流程</h3><p>当PVC被声明出来时（单独声明 or statefulSet），会被cache.Controller watch到，并开始执行<code>syncClaim</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *PersistentVolumeController)</span> <span class="title">syncClaim</span><span class="params">(claim *v1.PersistentVolumeClaim)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;synchronizing PersistentVolumeClaim[%s]: %s&quot;</span>, claimToClaimKey(claim), getClaimStatusForLogging(claim))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set correct &quot;migrated-to&quot; annotations on PVC and update in API server if</span></span><br><span class="line"><span class="comment">// necessary</span></span><br><span class="line">newClaim, err := ctrl.updateClaimMigrationAnnotations(claim)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Nothing was saved; we will fall back into the same</span></span><br><span class="line"><span class="comment">// condition in the next call to this method</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">claim = newClaim</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !metav1.HasAnnotation(claim.ObjectMeta, pvutil.AnnBindCompleted) &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.syncUnboundClaim(claim)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.syncBoundClaim(claim)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>pv.kubernetes.io/bind-completed</code> annotation来判断pvc是否已经完成bound操作，如果该PVC未进行bound操作，则调用<code>syncUnboundClaim</code>进行bound操作。</p><p>在进行<code>syncUnboundClaim</code>前，首先会确认PVC是否定义了<strong>延迟绑定</strong>策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsDelayBindingMode checks if claim is in delay binding mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsDelayBindingMode</span><span class="params">(claim *v1.PersistentVolumeClaim, classLister storagelisters.StorageClassLister)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">className := storagehelpers.GetPersistentVolumeClaimClass(claim)</span><br><span class="line"><span class="keyword">if</span> className == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class, err := classLister.Get(className)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> class.VolumeBindingMode == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;VolumeBindingMode not set for StorageClass %q&quot;</span>, className)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *class.VolumeBindingMode == storage.VolumeBindingWaitForFirstConsumer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟绑定主要用在Local PersistentVolume的情况下，当采用本地卷作为持久化卷时，如果PVC和PV即时绑定，则可能在pod启动的节点上找不到PV，mount过程会失败，而延迟绑定则将PVC和PV的绑定延后到Pod 调度器中，从而使Volume卷可以被正常挂载到Pod上。</p><p>之后执行PV查找过程，首先从<code>pvIndex</code>中按照<code>AccessModes</code>找到所有符合的PV：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allPossibleModes := pvIndex.allPossibleMatchingAccessModes(claim.Spec.AccessModes)</span><br></pre></td></tr></table></figure><p>例如PVC请求的PV的AccessMode是<code>ReadWriteOnce</code>，则包含<code>ReadWriteOnce</code>的PV都会被检索出。</p><p>之后通过调用<code>FindMatchingVolume</code>方法找到最合适的PV。</p><p>这里的逻辑是通过遍历符合AccessMode的所有PV，首先判定PV是否已经被其他PVC预绑定（pre-bound）或已经被绑定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> volume.Spec.ClaimRef != <span class="literal">nil</span> &amp;&amp; !IsVolumeBoundToClaim(volume, claim) &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsVolumeBoundToClaim</span><span class="params">(volume *v1.PersistentVolume, claim *v1.PersistentVolumeClaim)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> volume.Spec.ClaimRef == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> claim.Name != volume.Spec.ClaimRef.Name || claim.Namespace != volume.Spec.ClaimRef.Namespace &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> volume.Spec.ClaimRef.UID != <span class="string">&quot;&quot;</span> &amp;&amp; claim.UID != volume.Spec.ClaimRef.UID &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当开启了 延迟绑定后，PV将会被直接跳过，交给Pod调度器进行调度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &amp;&amp; delayBinding &#123;</span><br><span class="line">    <span class="comment">// PV controller does not bind this claim.</span></span><br><span class="line">    <span class="comment">// Scheduler will handle binding unbound volumes</span></span><br><span class="line">    <span class="comment">// Scheduler path will have node != nil</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会检查PV的状态是否处于 Available 、PVC中定义的labelSelector是否符合要求以及StorageClass是否符合（默认都为空，则为符合），不符合则跳过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> volume.Status.Phase != v1.VolumeAvailable &#123;</span><br><span class="line">    <span class="comment">// We ignore volumes in non-available phase, because volumes that</span></span><br><span class="line">    <span class="comment">// satisfies matching criteria will be updated to available, binding</span></span><br><span class="line">    <span class="comment">// them now has high chance of encountering unnecessary failures</span></span><br><span class="line">    <span class="comment">// due to API conflicts.</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> selector != <span class="literal">nil</span> &amp;&amp; !selector.Matches(labels.Set(volume.Labels)) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> storagehelpers.GetPersistentVolumeClass(volume) != requestedClass &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上都完毕后，从所有的符合条件的PV中找到符合PVC requestSize且最小的一个PV：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> smallestVolume == <span class="literal">nil</span> || smallestVolumeQty.Cmp(volumeQty) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    smallestVolume = volume</span><br><span class="line">    smallestVolumeQty = volumeQty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> smallestVolume != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a matching volume</span></span><br><span class="line">    <span class="keyword">return</span> smallestVolume, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是PV和PVC的调度绑定流程。</p><h3 id="Dynamic-Provisioning"><a href="#Dynamic-Provisioning" class="headerlink" title="Dynamic Provisioning"></a>Dynamic Provisioning</h3><p>这个过程在PersistentVolumeController中完成，而当Pod在实际使用Volume前，需要通过Attach以及Mount流程后，才能真正进行使用。</p><p>而实际的应用场景则是，在环境中可能没有提前创建好可供“bound”的PV，这时候<strong>Dynamic Provisioning</strong>就派上用场了。</p><p>使用Dynamic Provisioning方式很简单，通过定义StorageClass就可以完成。</p><p>以Rook-Ceph的RBD服务为例，可以创建如下格式的StorageClass，以提供块存储服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">provisioner:</span> <span class="string">ceph.rook.io/block</span></span><br><span class="line">  <span class="attr">parameters:</span></span><br><span class="line">    <span class="attr">pool:</span> <span class="string">replicapool</span></span><br><span class="line">    <span class="attr">clusterNamespace:</span> <span class="string">rook-ceph</span></span><br></pre></td></tr></table></figure><p>通过在PVC中声明storageClassName字段，就可以进行动态使用了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure><p>在PVController watch到动态PVC被声明后，首先会寻找该PVC对应的plugin和storageClass:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin, storageClass, err := ctrl.findProvisionablePlugin(claim)</span><br></pre></td></tr></table></figure><p>这个过程会通过PersistentVolumeController的findProvisionablePlugin方法来进行寻找in-tree plugin，而find过程的关键在于通过PVC声明的storageClassName寻找对应的in-tree Plugin：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a plugin for the class</span></span><br><span class="line"><span class="keyword">if</span> ctrl.csiMigratedPluginManager.IsMigrationEnabledForPlugin(class.Provisioner) &#123;</span><br><span class="line">    <span class="comment">// CSI migration scenario - do not depend on in-tree plugin</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, class, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">plugin, err := ctrl.volumePluginMgr.FindProvisionablePluginByName(class.Provisioner)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(class.Provisioner, <span class="string">&quot;kubernetes.io/&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// External provisioner is requested, do not report error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, class, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, class, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> plugin, class, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在1.14之后，PVController会先判断是否属于in-tree plugin到CSI的迁移(migration)场景，如果属于，则会将in-tree的plugin迁移到CSI，关于migration的产生背景，可以看下这篇介绍：<a href="https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/">https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/</a></p><p>简单来说，为了支持Plugin机制的广泛使用，K8S社区越来越倾向于减少in-tree的代码，而通过Plugin的机制来进行扩展，原先in-tree的Plugin也被通过migration的机制，逐渐往CSI上迁，从中也能看出K8S社区对扩展性的考量，未来K8S极有可能成为Plugin的“媒介”系统（目前还未采用Plugin机制的，仅有kube-scheduler，而随着K8S社区的不断演进，kube-scheduler的默认调度器也会和CSI、CNI一样，支持自定义调度插件）。</p><p>继续往下分析，PVController会通过scheduleOperation来传入PV的Operation方法作为闭包，scheduleOperation的作用主要是通过grm（goroutinemap）的读写锁来判定，是否有Operation已经在运行中，运行中的作业会被预先加入goroutinemap中，用以判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutinemap</span></span><br><span class="line"><span class="keyword">type</span> goRoutineMap <span class="keyword">struct</span> &#123;</span><br><span class="line">operations                <span class="keyword">map</span>[<span class="keyword">string</span>]operation</span><br><span class="line">exponentialBackOffOnError <span class="keyword">bool</span></span><br><span class="line">cond                      *sync.Cond</span><br><span class="line">lock                      sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Attach-amp-Mount"><a href="#Attach-amp-Mount" class="headerlink" title="Attach &amp; Mount"></a>Attach &amp; Mount</h3><p>在实际挂载时，通过ADController调用CSI的Attach操作，并在kubelet中调用Mount操作，完成存储卷和Pod的挂载过程。</p><p>在ADController中，首先会构建出PV对应的VolumeSpec，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSpecFromPersistentVolume creates an Spec from an v1.PersistentVolume</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSpecFromPersistentVolume</span><span class="params">(pv *v1.PersistentVolume, readOnly <span class="keyword">bool</span>)</span> *<span class="title">Spec</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Spec&#123;</span><br><span class="line">PersistentVolume: pv,</span><br><span class="line">ReadOnly:         readOnly,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后根据VolumeSpec寻找到plugin， 通过调用operation_executor，完成Attach操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oe *operationExecutor)</span> <span class="title">AttachVolume</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">volumeToAttach VolumeToAttach,</span></span></span><br><span class="line"><span class="function"><span class="params">actualStateOfWorld ActualStateOfWorldAttacherUpdater)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">generatedOperations :=</span><br><span class="line">oe.operationGenerator.GenerateAttachVolumeFunc(volumeToAttach, actualStateOfWorld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> util.IsMultiAttachAllowed(volumeToAttach.VolumeSpec) &#123;</span><br><span class="line"><span class="keyword">return</span> oe.pendingOperations.Run(</span><br><span class="line">volumeToAttach.VolumeName, <span class="string">&quot;&quot;</span> <span class="comment">/* podName */</span>, volumeToAttach.NodeName, generatedOperations)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oe.pendingOperations.Run(</span><br><span class="line">volumeToAttach.VolumeName, <span class="string">&quot;&quot;</span> <span class="comment">/* podName */</span>, <span class="string">&quot;&quot;</span> <span class="comment">/* nodeName */</span>, generatedOperations)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Mount操作则在kubelet中进行，在kubelet中会生成VolumeManager对象。</p><p>关于VolumeManager的处理逻辑会在kubelet的详细介绍文章中介绍。</p><h2 id="编写CSI"><a href="#编写CSI" class="headerlink" title="编写CSI"></a>编写CSI</h2><p>在理解了K8S处理持久化卷的机制后，我们就可以来尝试编写CSI了。</p><p>首先CSI不是in-tree模式的存储插件，一般通过daemonSet的方式部署在节点上。</p><p>CSI插件体系的设计思想，<strong>就是把 Provision 阶段，以及 Kubernetes 里的一部分存储管理功能，从主干代码里剥离出来，做成了几个单独的组件。</strong></p><p>CSI设计思想示意图：</p><img src="/images/d4bdc7035f1286e7a423da851eee89ad.png" alt="img" style="zoom: 67%;" /><p>可以看出，CSI可以大体分为两部分（上图External Components和Custum Components部分），其中左半部分是k8S所提供的控制面服务，而右侧则是CSI开发者需要关注的部分。</p><p>而再往左侧，K8S原生的控制面服务，则是对CSI组件的请求调用，我们暂且忽略。</p><p>先看下左半部分External Components。</p><p>External Components同样也是被K8S社区所维护的项目，存放与K8S的CSI SIG中。</p><h3 id="Driver-Registrar"><a href="#Driver-Registrar" class="headerlink" title="Driver Registrar"></a><strong>Driver Registrar</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><strong>Driver Registerar 组件通过请求CSI插件的Identity服务，来获取插件信息，将插件注册到kubelet中。</strong>在当前的K8S版本中（CSI spec 0.3后），Driver Registrar已不再维护，取而代之的是<a href="https://github.com/kubernetes-csi/cluster-driver-registrar">cluster-driver-registrar</a>和<a href="https://github.com/kubernetes-csi/node-driver-registrar">node-driver-registrar</a>。而在K8S 1.13版本以后，cluster-driver-registrar也进入deprecated，在1.16版本以后被正式弃用。<strong>而<a href="https://github.com/kubernetes-csi/node-driver-registrar">node-driver-registrar</a>是目前仍在维护的driver registar。而cluster-deriver-registar需要通过创建 <a href="https://kubernetes-csi.github.io/docs/csi-driver-object.html">CSIDriver Object </a>的方式来实现。</strong></p><p>node-driver-registrar的本质是sidecar容器，一般与CSI的daemonSet容器部署在一起。</p><p>部署yaml example：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">csi-driver-registrar</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.5.0</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--csi-address=/csi/csi.sock&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--kubelet-registration-path=/var/lib/kubelet/plugins/&lt;drivername.example.com&gt;/csi.sock&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--health-port=9809&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">plugin-dir</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/csi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">registration-dir</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/registration</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9809</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">healthz</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">healthz</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">registration-dir</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/var/lib/kubelet/plugins_registry/</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">plugin-dir</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/var/lib/kubelet/plugins/&lt;drivername.example.com&gt;/</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br></pre></td></tr></table></figure><h4 id="核心逻辑分析"><a href="#核心逻辑分析" class="headerlink" title="核心逻辑分析"></a><strong>核心逻辑分析</strong></h4><h3 id="External-Provisioner"><a href="#External-Provisioner" class="headerlink" title="External Provisioner"></a><strong>External Provisioner</strong></h3><h3 id="External-Attacher"><a href="#External-Attacher" class="headerlink" title="**External Attacher **"></a>**External Attacher **</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解k8s的CSI plugin编写前，我们需要先了解下有关K8S的持久化存储机制。&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Devops</title>
    <link href="http://example.com/2021/04/09/Cloud-Devops/"/>
    <id>http://example.com/2021/04/09/Cloud-Devops/</id>
    <published>2021-04-09T06:55:57.000Z</published>
    <updated>2022-11-28T09:22:46.480Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>容器文件系统</title>
    <link href="http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-04-09T05:44:33.000Z</published>
    <updated>2022-11-28T09:22:46.482Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>linux container</title>
    <link href="http://example.com/2021/04/09/linux-container/"/>
    <id>http://example.com/2021/04/09/linux-container/</id>
    <published>2021-04-09T05:44:06.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>cgroup</title>
    <link href="http://example.com/2021/04/09/cgroup/"/>
    <id>http://example.com/2021/04/09/cgroup/</id>
    <published>2021-04-09T05:43:53.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>容器网络是怎么打通的</title>
    <link href="http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</id>
    <published>2021-04-09T05:43:47.000Z</published>
    <updated>2022-11-28T09:22:46.482Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要从docker网络到k8s CNI进行尽可能详细的阐述和分析，笔者能力有限，如有疏漏，那就忽略好了 -_-||。</p><span id="more"></span><h3 id="Docker容器网络"><a href="#Docker容器网络" class="headerlink" title="Docker容器网络"></a>Docker容器网络</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要从docker网络到k8s CNI进行尽可能详细的阐述和分析，笔者能力有限，如有疏漏，那就忽略好了 -_-||。&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
    <category term="container" scheme="http://example.com/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>K8S Operator</title>
    <link href="http://example.com/2021/04/09/K8S-Operator/"/>
    <id>http://example.com/2021/04/09/K8S-Operator/</id>
    <published>2021-04-09T05:24:48.000Z</published>
    <updated>2022-11-28T09:22:46.481Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
