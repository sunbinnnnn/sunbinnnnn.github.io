<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neil&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-13T02:51:49.380Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>NeilSun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kubelet</title>
    <link href="http://example.com/2021/06/23/kubelet/"/>
    <id>http://example.com/2021/06/23/kubelet/</id>
    <published>2021-06-23T08:43:01.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>garbage-collector-controller</title>
    <link href="http://example.com/2021/06/15/garbage-collector-controller/"/>
    <id>http://example.com/2021/06/15/garbage-collector-controller/</id>
    <published>2021-06-15T02:44:16.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes在删除对象时，其对应的controller并不会真正去删除对象，删除对象工作是由GarbageCollectorController负责的。</p><span id="more"></span><p>当删除一个对象时，会根据删除策略来对资源进行回收处理。</p><h3 id="K8S中的删除策略"><a href="#K8S中的删除策略" class="headerlink" title="K8S中的删除策略"></a>K8S中的删除策略</h3><p>Orphan</p><p>Foreground</p><p>Background</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubernetes在删除对象时，其对应的controller并不会真正去删除对象，删除对象工作是由GarbageCollectorController负责的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>CSI plugin</title>
    <link href="http://example.com/2021/04/20/CSI-plugin/"/>
    <id>http://example.com/2021/04/20/CSI-plugin/</id>
    <published>2021-04-20T08:37:27.000Z</published>
    <updated>2021-07-13T04:59:04.240Z</updated>
    
    <content type="html"><![CDATA[<p>在了解k8s的CSI plugin编写前，我们需要先了解下有关K8S的持久化存储机制。</p><span id="more"></span><h3 id="理解k8s持久化存储"><a href="#理解k8s持久化存储" class="headerlink" title="理解k8s持久化存储"></a>理解k8s持久化存储</h3><p>在k8s中，持久化存储采用PV和PVC进行绑定的的方式进行管理。</p><p><em>PV（PersistentVolume）：</em>存储卷对象映射，一般由管理员手动创建或通过存储插件（External Provisioner）创建。示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv0003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span> <span class="comment"># K8S支持两种volumeMode：Filesystem和Block</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 三种策略可选：Retain\Recycle\Delete，只有NFS和HostPath支持Recycle（纯调用rm -rf命令进行文件系统级别删除）</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">slow</span></span><br><span class="line">  <span class="attr">mountOptions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p><em>PVC（PersistentVolumeClaim）</em>：存储卷声明，一般由开发人员定义，对于支持Dynamic Provisioning的存储类型，通过对PVC的声明（可以在pod中完成），可以让PersistentVolumeController找到一块合适的PV与PVC进行bound操作。示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">fast</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure><p>这种绑定操作可以是<strong>静态的（Static Provisioning）</strong>，也可以是<strong>动态的（Dynamic Provisioning）</strong></p><p>首先说静态，通过静态方式进行时，由管理员创建PV，通过PersistentVolumeController，k8s可以完成PV和PVC的绑定，PersistentVolumeController(<code>pkg/controller/volume/persistentvolume/pv_controller.go</code>)存在一个控制循环，不断遍历所有可用状态的PV，尝试与PVC进行绑定（Bound）操作，绑定成功后，则为声明该PVC的Pod提供存储服务。</p><h4 id="PV和PVC绑定调度流程："><a href="#PV和PVC绑定调度流程：" class="headerlink" title="PV和PVC绑定调度流程："></a>PV和PVC绑定调度流程：</h4><p>当PVC被声明出来时（单独声明 or statefulSet），会被cache.Controller watch到，并开始执行<code>syncClaim</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *PersistentVolumeController)</span> <span class="title">syncClaim</span><span class="params">(claim *v1.PersistentVolumeClaim)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;synchronizing PersistentVolumeClaim[%s]: %s&quot;</span>, claimToClaimKey(claim), getClaimStatusForLogging(claim))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set correct &quot;migrated-to&quot; annotations on PVC and update in API server if</span></span><br><span class="line"><span class="comment">// necessary</span></span><br><span class="line">newClaim, err := ctrl.updateClaimMigrationAnnotations(claim)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Nothing was saved; we will fall back into the same</span></span><br><span class="line"><span class="comment">// condition in the next call to this method</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">claim = newClaim</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !metav1.HasAnnotation(claim.ObjectMeta, pvutil.AnnBindCompleted) &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.syncUnboundClaim(claim)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.syncBoundClaim(claim)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>pv.kubernetes.io/bind-completed</code> annotation来判断pvc是否已经完成bound操作，如果该PVC未进行bound操作，则调用<code>syncUnboundClaim</code>进行bound操作。</p><p>在进行<code>syncUnboundClaim</code>前，首先会确认PVC是否定义了<strong>延迟绑定</strong>策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsDelayBindingMode checks if claim is in delay binding mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsDelayBindingMode</span><span class="params">(claim *v1.PersistentVolumeClaim, classLister storagelisters.StorageClassLister)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">className := storagehelpers.GetPersistentVolumeClaimClass(claim)</span><br><span class="line"><span class="keyword">if</span> className == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class, err := classLister.Get(className)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> apierrors.IsNotFound(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> class.VolumeBindingMode == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;VolumeBindingMode not set for StorageClass %q&quot;</span>, className)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *class.VolumeBindingMode == storage.VolumeBindingWaitForFirstConsumer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟绑定主要用在Local PersistentVolume的情况下，当采用本地卷作为持久化卷时，如果PVC和PV即时绑定，则可能在pod启动的节点上找不到PV，mount过程会失败，而延迟绑定则将PVC和PV的绑定延后到Pod 调度器中，从而使Volume卷可以被正常挂载到Pod上。</p><p>之后执行PV查找过程，首先从<code>pvIndex</code>中按照<code>AccessModes</code>找到所有符合的PV：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allPossibleModes := pvIndex.allPossibleMatchingAccessModes(claim.Spec.AccessModes)</span><br></pre></td></tr></table></figure><p>例如PVC请求的PV的AccessMode是<code>ReadWriteOnce</code>，则包含<code>ReadWriteOnce</code>的PV都会被检索出。</p><p>之后通过调用<code>FindMatchingVolume</code>方法找到最合适的PV。</p><p>这里的逻辑是通过遍历符合AccessMode的所有PV，首先判定PV是否已经被其他PVC预绑定（pre-bound）或已经被绑定：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> volume.Spec.ClaimRef != <span class="literal">nil</span> &amp;&amp; !IsVolumeBoundToClaim(volume, claim) &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsVolumeBoundToClaim</span><span class="params">(volume *v1.PersistentVolume, claim *v1.PersistentVolumeClaim)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> volume.Spec.ClaimRef == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> claim.Name != volume.Spec.ClaimRef.Name || claim.Namespace != volume.Spec.ClaimRef.Namespace &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> volume.Spec.ClaimRef.UID != <span class="string">&quot;&quot;</span> &amp;&amp; claim.UID != volume.Spec.ClaimRef.UID &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当开启了 延迟绑定后，PV将会被直接跳过，交给Pod调度器进行调度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &amp;&amp; delayBinding &#123;</span><br><span class="line">    <span class="comment">// PV controller does not bind this claim.</span></span><br><span class="line">    <span class="comment">// Scheduler will handle binding unbound volumes</span></span><br><span class="line">    <span class="comment">// Scheduler path will have node != nil</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会检查PV的状态是否处于 Available 、PVC中定义的labelSelector是否符合要求以及StorageClass是否符合（默认都为空，则为符合），不符合则跳过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> volume.Status.Phase != v1.VolumeAvailable &#123;</span><br><span class="line">    <span class="comment">// We ignore volumes in non-available phase, because volumes that</span></span><br><span class="line">    <span class="comment">// satisfies matching criteria will be updated to available, binding</span></span><br><span class="line">    <span class="comment">// them now has high chance of encountering unnecessary failures</span></span><br><span class="line">    <span class="comment">// due to API conflicts.</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> selector != <span class="literal">nil</span> &amp;&amp; !selector.Matches(labels.Set(volume.Labels)) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> storagehelpers.GetPersistentVolumeClass(volume) != requestedClass &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上都完毕后，从所有的符合条件的PV中找到符合PVC requestSize且最小的一个PV：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> smallestVolume == <span class="literal">nil</span> || smallestVolumeQty.Cmp(volumeQty) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    smallestVolume = volume</span><br><span class="line">    smallestVolumeQty = volumeQty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> smallestVolume != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Found a matching volume</span></span><br><span class="line">    <span class="keyword">return</span> smallestVolume, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是PV和PVC的调度绑定流程。</p><h4 id="Dynamic-Provisioning"><a href="#Dynamic-Provisioning" class="headerlink" title="Dynamic Provisioning"></a>Dynamic Provisioning</h4><p>这个过程在PersistentVolumeController中完成，而当Pod在实际使用Volume前，需要通过Attach以及Mount流程后，才能真正进行使用。</p><p>而实际的应用场景则是，在环境中可能没有提前创建好可供“bound”的PV，这时候<strong>Dynamic Provisioning</strong>就派上用场了。</p><p>使用Dynamic Provisioning方式很简单，通过定义StorageClass就可以完成。</p><p>以Rook-Ceph的RBD服务为例，可以创建如下格式的StorageClass，以提供块存储服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">provisioner:</span> <span class="string">ceph.rook.io/block</span></span><br><span class="line">  <span class="attr">parameters:</span></span><br><span class="line">    <span class="attr">pool:</span> <span class="string">replicapool</span></span><br><span class="line">    <span class="attr">clusterNamespace:</span> <span class="string">rook-ceph</span></span><br></pre></td></tr></table></figure><p>通过在PVC中声明storageClassName字段，就可以进行动态使用了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">claim1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">block-service</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">30Gi</span></span><br></pre></td></tr></table></figure><p>在PVController watch到动态PVC被声明后，首先会寻找该PVC对应的plugin和storageClass:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin, storageClass, err := ctrl.findProvisionablePlugin(claim)</span><br></pre></td></tr></table></figure><p>这个过程会通过PersistentVolumeController的findProvisionablePlugin方法来进行寻找in-tree plugin，而find过程的关键在于通过PVC声明的storageClassName寻找对应的in-tree Plugin：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a plugin for the class</span></span><br><span class="line"><span class="keyword">if</span> ctrl.csiMigratedPluginManager.IsMigrationEnabledForPlugin(class.Provisioner) &#123;</span><br><span class="line">    <span class="comment">// CSI migration scenario - do not depend on in-tree plugin</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, class, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">plugin, err := ctrl.volumePluginMgr.FindProvisionablePluginByName(class.Provisioner)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(class.Provisioner, <span class="string">&quot;kubernetes.io/&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// External provisioner is requested, do not report error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, class, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, class, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> plugin, class, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>在1.14之后，PVController会先判断是否属于in-tree plugin到CSI的迁移(migration)场景，如果属于，则会将in-tree的plugin迁移到CSI，关于migration的产生背景，可以看下这篇介绍：<a href="https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/">https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/</a></p><p>简单来说，为了支持Plugin机制的广泛使用，K8S社区越来越倾向于减少in-tree的代码，而通过Plugin的机制来进行扩展，原先in-tree的Plugin也被通过migration的机制，逐渐往CSI上迁，从中也能看出K8S社区对扩展性的考量，未来K8S极有可能成为Plugin的“媒介”系统（目前还未采用Plugin机制的，仅有kube-scheduler，而随着K8S社区的不断演进，kube-scheduler的默认调度器也会和CSI、CNI一样，支持自定义调度插件）。</p><p>继续往下分析，PVController会通过scheduleOperation来传入PV的Operation方法作为闭包，scheduleOperation的作用主要是通过grm（goroutinemap）的读写锁来判定，是否有Operation已经在运行中，运行中的作业会被预先加入goroutinemap中，用以判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutinemap</span></span><br><span class="line"><span class="keyword">type</span> goRoutineMap <span class="keyword">struct</span> &#123;</span><br><span class="line">operations                <span class="keyword">map</span>[<span class="keyword">string</span>]operation</span><br><span class="line">exponentialBackOffOnError <span class="keyword">bool</span></span><br><span class="line">cond                      *sync.Cond</span><br><span class="line">lock                      sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Attach-amp-Mount"><a href="#Attach-amp-Mount" class="headerlink" title="Attach &amp; Mount"></a>Attach &amp; Mount</h4><p>在实际挂载时，通过ADController调用CSI的Attach操作，并在kubelet中调用Mount操作，完成存储卷和Pod的挂载过程。</p><p>在ADController中，首先会构建出PV对应的VolumeSpec，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSpecFromPersistentVolume creates an Spec from an v1.PersistentVolume</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSpecFromPersistentVolume</span><span class="params">(pv *v1.PersistentVolume, readOnly <span class="keyword">bool</span>)</span> *<span class="title">Spec</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Spec&#123;</span><br><span class="line">PersistentVolume: pv,</span><br><span class="line">ReadOnly:         readOnly,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后根据VolumeSpec寻找到plugin， 通过调用operation_executor，完成Attach操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oe *operationExecutor)</span> <span class="title">AttachVolume</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">volumeToAttach VolumeToAttach,</span></span></span><br><span class="line"><span class="function"><span class="params">actualStateOfWorld ActualStateOfWorldAttacherUpdater)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">generatedOperations :=</span><br><span class="line">oe.operationGenerator.GenerateAttachVolumeFunc(volumeToAttach, actualStateOfWorld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> util.IsMultiAttachAllowed(volumeToAttach.VolumeSpec) &#123;</span><br><span class="line"><span class="keyword">return</span> oe.pendingOperations.Run(</span><br><span class="line">volumeToAttach.VolumeName, <span class="string">&quot;&quot;</span> <span class="comment">/* podName */</span>, volumeToAttach.NodeName, generatedOperations)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oe.pendingOperations.Run(</span><br><span class="line">volumeToAttach.VolumeName, <span class="string">&quot;&quot;</span> <span class="comment">/* podName */</span>, <span class="string">&quot;&quot;</span> <span class="comment">/* nodeName */</span>, generatedOperations)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Mount操作则在kubelet中进行，在kubelet中会生成VolumeManager对象。</p><p>关于VolumeManager的处理逻辑会在kubelet的详细介绍文章中介绍。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解k8s的CSI plugin编写前，我们需要先了解下有关K8S的持久化存储机制。&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Devops</title>
    <link href="http://example.com/2021/04/09/Cloud-Devops/"/>
    <id>http://example.com/2021/04/09/Cloud-Devops/</id>
    <published>2021-04-09T06:55:57.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>容器文件系统</title>
    <link href="http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-04-09T05:44:33.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>linux container</title>
    <link href="http://example.com/2021/04/09/linux-container/"/>
    <id>http://example.com/2021/04/09/linux-container/</id>
    <published>2021-04-09T05:44:06.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>cgroup</title>
    <link href="http://example.com/2021/04/09/cgroup/"/>
    <id>http://example.com/2021/04/09/cgroup/</id>
    <published>2021-04-09T05:43:53.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>容器网络</title>
    <link href="http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</id>
    <published>2021-04-09T05:43:47.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要从docker网络到k8s CNI进行尽可能详细的阐述和分析，笔者能力有限，如有疏漏，那就忽略好了 -_-||。</p><span id="more"></span><h3 id="Docker容器网络"><a href="#Docker容器网络" class="headerlink" title="Docker容器网络"></a>Docker容器网络</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要从docker网络到k8s CNI进行尽可能详细的阐述和分析，笔者能力有限，如有疏漏，那就忽略好了 -_-||。&lt;/p&gt;</summary>
    
    
    
    
    <category term="container" scheme="http://example.com/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>K8S Operator</title>
    <link href="http://example.com/2021/04/09/K8S-Operator/"/>
    <id>http://example.com/2021/04/09/K8S-Operator/</id>
    <published>2021-04-09T05:24:48.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>容器问题总结</title>
    <link href="http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/04/09/%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-09T05:22:47.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络部分</strong></p><p>1.Docker中的网络是如何连通的？container和container直接网络访问的流程？</p><span id="more"></span><p>2.如何实现Pod跨宿主机通信？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;网络部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Docker中的网络是如何连通的？container和container直接网络访问的流程？&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>文件IO调用</title>
    <link href="http://example.com/2021/04/09/%E6%96%87%E4%BB%B6IO%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2021/04/09/%E6%96%87%E4%BB%B6IO%E8%B0%83%E7%94%A8/</id>
    <published>2021-04-09T05:22:18.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux启动过程刨析</title>
    <link href="http://example.com/2021/04/08/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/04/08/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2021-04-08T13:38:04.000Z</published>
    <updated>2021-07-13T02:51:49.380Z</updated>
    
    <content type="html"><![CDATA[<p>Linux启动过程主要包含boot和startup两个阶段。</p><span id="more"></span><p>*本文不包含硬件相关的加载细节</p><h3 id="引导-Boot-阶段"><a href="#引导-Boot-阶段" class="headerlink" title="引导(Boot)阶段"></a>引导(Boot)阶段</h3><p>Boot阶段始于按下开机键或通过内核指令执行reboot操作，之后会经历以下过程：</p><h4 id="1-BIOS-POST"><a href="#1-BIOS-POST" class="headerlink" title="1.BIOS POST"></a>1.BIOS POST</h4><p>第一阶段启动和Linux本身关系不大，主要围绕硬件启动部分，在绝大大数操作系统上行为是一致的。当计算机被启动时，首先运行的是POST（Power On Self Test 开机自检）过程，这是BIOS（Basic I/O System）的一部分。</p><p>当IBM在1981年设计了第一台PC开始，BIOS就被设计为初始化硬件的组件。POST是BIOS检查计算机硬件，并确保计算机硬件功能正常的阶段。如果POST失败了，计算机将无法正常启动，Boot程序也不会继续。</p><p>BIOS POST过程中会检查硬件的基本引导能力，当定位到可引导设备上的引导扇区时，会发出BIOS中断指令INT 13H中断BIOS POST过程。第一个被找到的引导扇区上包含了一个可用的的引导设备。第一个被找到的引导扇区将会包含一个可用的引导记录并被加载到内存，随后将引导的控制权转移从引导扇区加载的代码中。</p><p>加载引导扇区实际上是引导加载程序的第一阶段。大多数Linux发行版使用了三种引导加载程序：GRUB、GRUB2和LILO，目前用的最多的是GRUB2。</p><h4 id="2-GRUB2"><a href="#2-GRUB2" class="headerlink" title="2.GRUB2"></a>2.GRUB2</h4><p>GRUB2的全称是“GRand Unified Bootloader, version 2”，目前是Linux发行版中最主流的引导加载程序（bootloader）。GRUB2的作用是让计算机能够灵活得找到操作系统Kernel并且加载到内存中。（下文中将用GRUB指代GRUB2）。</p><p>GRUB被设计为多引导规范（<a href="https://en.wikipedia.org/wiki/Multiboot_specification">Multiboot specification</a>）支持，这使得GRUB可以引导Linux的多数版本以及其他开放操作系统，也可以链接到其他专有操作系统的引导记录（例如通过GRUB加载Windows的引导程序）。</p><p>GRUB允许用户选择从任意给定的Linux发行版的不通内核中引导，如果因为内核版本变化导致引导失败，GRUB还支持了故障回滚机制，能够引导到之前的内核版本。GRUB可以使用 <code>/boot/grub/grub.conf</code> 进行回滚策略的变更。</p><p>以下将介绍GRUB2的三个引导阶段：</p><h5 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h5><p>在BIOS POST的POST阶段的末尾，BIOS会搜索连接的磁盘上的引导记录，通常位于主引导记录（<a href="https://en.wikipedia.org/wiki/Master_boot_record">MBR</a>）中，POST会找到第一个引导记录并加载到内存中，然后开始执行引导记录。GRUB2 stage 1即执行引导程序代码，这块被设计得非常小，因为它必须与分区表一起放在硬盘驱动器的第一个512字节扇区中。在经典的通用MBR中，为实际引导代码分区的空间量是446字节。Stage 1中的446字节文件名为<code>boot.img</code>，头部的446中不包含单独的引导分区。</p><p>由于引导记录大小的限制，使得其无法直接获取文件系统结构，因此，Stage 1阶段的唯一目的是定义并加载Stage 1.5，GRUB Stage 1.5阶段必须位于引导记录本身和驱动器第一个分区之间，GRUB Stage 1.5被加载到Ram后，控制权随即转为Stage 1.5</p><h5 id="Stage-1-5"><a href="#Stage-1-5" class="headerlink" title="Stage 1.5"></a>Stage 1.5</h5><p>Stage 1.5的工作主要是加载寻找 /boot目录中Stage 2阶段所必须的驱动。</p><p>GRUB Stage 1.5必须位于引导记录本身与磁盘驱动器第一个分区之间的空间中。硬盘驱动器的第一个分区从扇区63开始，而MBR在扇区0剩下的62个扇区（512字节-31744字节）中存放了执行Stage 1.5的<code>core.img</code>，<code>core.img</code>大小被设计为25389字节，可以被存放在MBR和磁盘第一个分区之间。</p><p>对于Stage 1.5来说，它能够存放比Stage 1多的多的代码，一般来说，一些常见文件系统的驱动程序会存放在此（例如EXT、FAT、NTFS等）。GRUB2的core.img比GRUB1更复杂，功能更强大，GRUB2的core.img可以直接位于标准EXT文件系统上（不支持放在逻辑卷上），所以Stage 2的标准路径是<code>/boot</code> 目录，一般是<code>/boot/grub2</code>。</p><p>需要注意的是，<code>/boot</code>目录必须创建在GRUB支持的文件系统上。</p><h5 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h5><p>与GRUB1一样，GRUB2也支持从多种Linux内核之一进行引导。红帽软件包管理器DNF支持保留内核的多个版本，因此，如果最新版本的内核出现问题，则可以引导较旧版本的内核。默认情况下，GRUB提供已安装内核的预引导菜单，包括救援选项和恢复选项（如果已配置）。</p><p>GRUB Stage2阶段所需文件都在 <code>/boot/grub2</code>目录中，GRUB Stage2阶段中没有Stage1和1.5那样的image文件，主要会由运行时Kernel Modules构成，一般从<code>/boot/grub2/i386-pc</code>目录中加载。</p><p>GRUB Stage2的职责主要是定位Linux Kernel并加载到RAM中，并将整个控制权移交给kernel。</p><p>Kernel及其相关文件都位于/boot目录中，Kernel文件一般以vmlinuz开头命名，通过列出 /boot 目录的内容，可以查看当前系统安装的内核。</p><p>GRUB2 和 1都支持多内核引导。RedHat的包管理系统DNF支持在仓库中保留多个Kernel版本，如果最新版本内核出现问题，可以通过GRUB提供的内核预引导菜单（pre-boot menu），引导前一个版本的内核。</p><h5 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h5><p>为了节省磁盘空间，所有的内核均采用自解压的压缩格式。内核、初始RAM磁盘映像（InitRamFs）以及硬盘的社区映射都位于 /boot目录中。</p><p>选定的内核被加载到内存开始执行时，首先进行自解压，提取可执行作业，并加载。内核提取后首先systemd，并将启动控制权进行交接。</p><p>Boot阶段到此全部结束，此时，Linux Kernel和systemd程序正在运行。</p><h3 id="启动-Startup-阶段"><a href="#启动-Startup-阶段" class="headerlink" title="启动(Startup)阶段"></a>启动(Startup)阶段</h3><p>Startup阶段和Boot阶段完成后随即开始，主要工作是让计算机能够真正执行生产作业。</p><h5 id="0号进程和1号进程"><a href="#0号进程和1号进程" class="headerlink" title="0号进程和1号进程"></a>0号进程和1号进程</h5><p>systemd是系统的1号进程，在1号进程启动前，系统会自动创建0号进程，0号进程的pid=0，也是唯一一个没有通过<code>fork</code>或者<code>kernel_thread</code>生成的进程。</p><p>0号进程是系统所有进程的先祖，进程描述符<code>init_task</code>是内核静态创建的，而它在初始化的时候通过<code>kernel_thread</code>的方式创建了两个内核线程，分别是<code>kernel_init</code>和<code>kthreadd</code>，其中<code>kernel_init</code>为1号进程。</p><p>0号进程创建1号进程的方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br></pre></td></tr></table></figure><p>我们发现1号进程的执行函数就是kernel_init，kernel_init函数将完成设备驱动程序的初始化，并调用init_post函数启动用户空间的init进程即systemd。</p><h5 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h5><p>systemd是所有用户进程的祖先，它负责使Linux主机达到可以完成生产性工作的状态。它的某些功能比旧的init程序要更为广泛。</p><p>首先，systemd会挂载<code>/etc/fstab</code>定义的文件系统，包括所有交换分区和普通分区。此时，它可以访问/etc目录来确定系统配置相关信息。当找到配置文件<code>/etc/systemd/system/default.target</code>时，会使用该配置文件来确定将主机引导到的状态或目标。 <code>default.target</code>文件是指向真实目标文件的链接。对于带GUI界面的系统，通常将其作为<code>graphic.target</code>，等效于旧SystemV init中的runlevel 5。对于不带GUI解密的系统，默认值则为<code>multi-user.target</code>，类似于SystemV中的runlevel 3，<code>emergency.target</code>则与单用户模式相似。</p><p>下表是对systemd targets与的systemV runlevel的比较。 systemd target aliases 由systemd提供，用于向后兼容。target aliases 允许脚本使用init 3这样的SystemV命令来更改运行级别。SystemV命令将转发给systemd进行解释和执行。</p><table><thead><tr><th><strong>SystemV Runlevel</strong></th><th><strong>systemd target</strong></th><th><strong>systemd target aliases</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td></td><td>halt.target</td><td></td><td>Halts the system without powering it down.</td></tr><tr><td>0</td><td>poweroff.target</td><td>runlevel0.target</td><td>Halts the system and turns the power off.</td></tr><tr><td>S</td><td>emergency.target</td><td></td><td>Single user mode. No services are running; filesystems are not mounted. This is the most basic level of operation with only an emergency shell running on the main console for the user to interact with the system.</td></tr><tr><td>1</td><td>rescue.target</td><td>runlevel1.target</td><td>A base system including mounting the filesystems with only the most basic services running and a rescue shell on the main console.</td></tr><tr><td>2</td><td></td><td>runlevel2.target</td><td>Multiuser, without NFS but all other non-GUI services running.</td></tr><tr><td>3</td><td>multi-user.target</td><td>runlevel3.target</td><td>All services running but command line interface (CLI) only.</td></tr><tr><td>4</td><td></td><td>runlevel4.target</td><td>Unused.</td></tr><tr><td>5</td><td>graphical.target</td><td>runlevel5.target</td><td>multi-user with a GUI.</td></tr><tr><td>6</td><td>reboot.target</td><td>runlevel6.target</td><td>Reboot</td></tr><tr><td></td><td>default.target</td><td></td><td>This target is always aliased with a symbolic link to either multi-user.target or graphical.target. systemd always uses the default.target to start the system. The default.target should never be aliased to halt.target, poweroff.target, or reboot.target.</td></tr></tbody></table><p>每个target都有对应的配置文件可供配置，并且具备相互依赖的特性，下图描述了target的依赖关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">local-fs-pre.target</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">   (various mounts and   (various swap   (various cryptsetup</span><br><span class="line">    fsck services...)     devices...)        devices...)       (various low-level   (various low-level</span><br><span class="line">            |                  |                  |             services: udevd,     API VFS mounts:</span><br><span class="line">            v                  v                  v             tmpfiles, random     mqueue, configfs,</span><br><span class="line">     local-fs.target      swap.target     cryptsetup.target    seed, sysctl, ...)      debugfs, ...)</span><br><span class="line">            |                  |                  |                    |                    |</span><br><span class="line">            \__________________|_________________ | ___________________|____________________&#x2F;</span><br><span class="line">                                                 \|&#x2F;</span><br><span class="line">                                                  v</span><br><span class="line">                                           sysinit.target</span><br><span class="line">                                                  |</span><br><span class="line">             ____________________________________&#x2F;|\________________________________________</span><br><span class="line">            &#x2F;                  |                  |                    |                    \</span><br><span class="line">            |                  |                  |                    |                    |</span><br><span class="line">            v                  v                  |                    v                    v</span><br><span class="line">        (various           (various               |                (various          rescue.service</span><br><span class="line">       timers...)          paths...)              |               sockets...)               |</span><br><span class="line">            |                  |                  |                    |                    v</span><br><span class="line">            v                  v                  |                    v              rescue.target</span><br><span class="line">      timers.target      paths.target             |             sockets.target</span><br><span class="line">            |                  |                  |                    |</span><br><span class="line">            v                  \_________________ | ___________________&#x2F;</span><br><span class="line">                                                 \|&#x2F;</span><br><span class="line">                                                  v</span><br><span class="line">                                            basic.target</span><br><span class="line">                                                  |</span><br><span class="line">             ____________________________________&#x2F;|                                 emergency.service</span><br><span class="line">            &#x2F;                  |                  |                                         |</span><br><span class="line">            |                  |                  |                                         v</span><br><span class="line">            v                  v                  v                                 emergency.target</span><br><span class="line">        display-        (various system    (various system</span><br><span class="line">    manager.service         services           services)</span><br><span class="line">            |             required for            |</span><br><span class="line">            |            graphical UIs)           v</span><br><span class="line">            |                  |           multi-user.target</span><br><span class="line">            |                  |                  |</span><br><span class="line">            \_________________ | _________________&#x2F;</span><br><span class="line">                              \|&#x2F;</span><br><span class="line">                               v</span><br><span class="line">                     graphical.target</span><br></pre></td></tr></table></figure><p>根据依赖拓扑完成启动后，Linux系统结束启动过程。</p><h3 id="附录：关于initramd的定制"><a href="#附录：关于initramd的定制" class="headerlink" title="附录：关于initramd的定制"></a>附录：关于initramd的定制</h3><p>解压：</p><p><code>xz -dc &lt; initrd.img| cpio -idmv</code></p><p>打包：</p><p><code>find . 2&gt;/dev/null | cpio -c -o | xz -9 --format=xz --check=crc32 &gt; /tmp/new.img</code></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://opensource.com/article/17/2/linux-boot-and-startup">https://opensource.com/article/17/2/linux-boot-and-startup</a></p><p><a href="https://blog.csdn.net/gatieme/article/details/51532804">https://blog.csdn.net/gatieme/article/details/51532804</a></p><p><a href="https://www.golinuxcloud.com/update-rebuild-initrd-image-centos-rhel-7-8/#Method_2_Extract_initrd_image">https://www.golinuxcloud.com/update-rebuild-initrd-image-centos-rhel-7-8/#Method_2_Extract_initrd_image</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux启动过程主要包含boot和startup两个阶段。&lt;/p&gt;</summary>
    
    
    
    
    <category term="system" scheme="http://example.com/tags/system/"/>
    
  </entry>
  
</feed>
