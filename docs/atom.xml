<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neil&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-12T02:50:43.790Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>NeilSun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go并发-并发原语踩坑</title>
    <link href="http://example.com/2022/07/12/Go%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2022/07/12/Go%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E8%B8%A9%E5%9D%91/</id>
    <published>2022-07-12T02:38:23.000Z</published>
    <updated>2022-07-12T02:50:43.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RWMutex-的-3-个踩坑点"><a href="#RWMutex-的-3-个踩坑点" class="headerlink" title="RWMutex 的 3 个踩坑点"></a>RWMutex 的 3 个踩坑点</h2><h3 id="1：不可复制"><a href="#1：不可复制" class="headerlink" title="1：不可复制"></a><strong>1：不可复制</strong></h3><p>不能复制的原因和互斥锁一样。一旦读写锁被使用，它的字段就会记录它当前的一些状态。这个时候你去复制这把锁，就会把它的状态也给复制过来。但是，原来的锁在释放的时候，并不会修改你复制出来的这个读写锁，这就会导致复制出来的读写锁的状态不对，可能永远无法释放锁。</p><h3 id="2：重入导致死锁"><a href="#2：重入导致死锁" class="headerlink" title="2：重入导致死锁"></a><strong>2：重入导致死锁</strong></h3><p>读写锁因为重入（或递归调用）导致死锁（deadlock）的情况更多。</p><p>死锁三种情况：</p><ul><li>第一种情况：读写锁内部基于互斥锁实现对 writer 的并发访问，而互斥锁本身是有重入问题的，所以，writer 重入调用 Lock 的时候，就会出现死锁的现象。</li><li>第二种情况：我们知道，有活跃 reader 的时候，writer 会等待，如果我们在 reader 的读操作时调用 writer 的写操作（它会调用 Lock 方法），那么，这个 reader 和 writer 就会形成互相依赖的死锁状态。Reader 想等待 writer 完成后再释放锁，而 writer 需要这个 reader 释放锁之后，才能不阻塞地继续执行。这是一个读写锁常见的死锁场景。</li><li>第三种情况：当一个 writer 请求锁的时候，如果已经有一些活跃的 reader，它会等待这些活跃的 reader 完成，才有可能获取到锁，但是，如果之后活跃的 reader 再依赖新的 reader 的话，这些新的 reader 就会等待 writer 释放锁之后才能继续执行，这就形成了一个环形依赖： writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer,稍微等待，然后制造一个调用Lock的场景</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">        mu.Lock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Lock&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Unlock&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        factorial(&amp;mu, <span class="number">10</span>) <span class="comment">// 计算10的阶乘, 10!</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用计算阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(m *sync.RWMutex, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> &#123; <span class="comment">// 阶乘退出条件 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;RLock&quot;</span>)</span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;RUnlock&quot;</span>)</span><br><span class="line">        m.RUnlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> factorial(m, n<span class="number">-1</span>) * n <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>factoria 方法是一个递归计算阶乘的方法，我们用它来模拟 reader。为了更容易地制造出死锁场景，在这里加上了 sleep 的调用，延缓逻辑的执行。这个方法会调用读锁（第 27 行），在第 33 行递归地调用此方法，每次调用都会产生一次读锁的调用，所以可以不断地产生读锁的调用，而且必须等到新请求的读锁释放，这个读锁才能释放。</p><p>同时，我们使用另一个 goroutine 去调用 Lock 方法，来实现 writer，这个 writer 会等待 200 毫秒后才会调用 Lock，这样在调用 Lock 的时候，factoria 方法还在执行中不断调用 RLock。这两个 goroutine 互相持有锁并等待，谁也不会退让一步，满足了“writer 依赖活跃的 reader -&gt; 活跃的 reader 依赖新来的 reader -&gt; 新来的 reader 依赖 writer”的死锁条件，所以就导致了死锁的产生。</p><h3 id="3：释放未加锁的-RWMutex"><a href="#3：释放未加锁的-RWMutex" class="headerlink" title="3：释放未加锁的 RWMutex"></a><strong>3：释放未加锁的 RWMutex</strong></h3><p>和互斥锁一样，Lock 和 Unlock 的调用总是成对出现的，RLock 和 RUnlock 的调用也必须成对出现。Lock 和 RLock 多余的调用会导致锁没有被释放，可能会出现死锁，而 Unlock 和 RUnlock 多余的调用会导致 panic。在生产环境中出现 panic 是大忌，你总不希望半夜爬起来处理生产环境程序崩溃的问题吧？所以，在使用读写锁的时候，一定要注意，不遗漏不多余。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RWMutex-的-3-个踩坑点&quot;&gt;&lt;a href=&quot;#RWMutex-的-3-个踩坑点&quot; class=&quot;headerlink&quot; title=&quot;RWMutex 的 3 个踩坑点&quot;&gt;&lt;/a&gt;RWMutex 的 3 个踩坑点&lt;/h2&gt;&lt;h3 id=&quot;1：不可复制&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Redis云原生设计</title>
    <link href="http://example.com/2022/07/11/Redis%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/07/11/Redis%E4%BA%91%E5%8E%9F%E7%94%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-07-11T09:05:04.000Z</published>
    <updated>2022-07-11T09:05:08.191Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>架构设计-设计模式篇</title>
    <link href="http://example.com/2022/07/11/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/"/>
    <id>http://example.com/2022/07/11/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AF%87/</id>
    <published>2022-07-11T07:57:23.000Z</published>
    <updated>2022-07-11T07:57:27.759Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Go并发-常见并发原语</title>
    <link href="http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/"/>
    <id>http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD/</id>
    <published>2022-07-11T07:56:06.000Z</published>
    <updated>2022-07-12T02:45:13.516Z</updated>
    
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go并发-goroutine并发模型</title>
    <link href="http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-goroutine%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-goroutine%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-07-11T07:55:11.000Z</published>
    <updated>2022-07-12T02:45:25.366Z</updated>
    
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go并发-channel</title>
    <link href="http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-channel/"/>
    <id>http://example.com/2022/07/11/Go%E5%B9%B6%E5%8F%91-channel/</id>
    <published>2022-07-11T07:33:14.000Z</published>
    <updated>2022-07-11T09:14:15.715Z</updated>
    
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Go并发 - 并发原语Mutex、RWMutex</title>
    <link href="http://example.com/2022/05/12/Go%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2022/05/12/Go%E5%B9%B6%E5%8F%91/</id>
    <published>2022-05-12T07:11:36.000Z</published>
    <updated>2022-07-12T02:45:03.317Z</updated>
    
    <content type="html"><![CDATA[<p>并发问题是在大型项目开发过程中不可绕过的问题，而Go以其对并发的性能优异而得名，那Golang对并发场景的优势以及对并发问题的解决原理是如何的呢？</p><span id="more"></span><h2 id="并发原语"><a href="#并发原语" class="headerlink" title="并发原语"></a>并发原语</h2><p>原语一般是指内核提供给核外调用的过程或者函数成为原语（primitive），原语在执行过程中不允许中断,而并发原语一般是指原语的并发实现。</p><p>Golang作为主打并发编程的语言，在其设计中，也存在一系列的并发原语来解决并发编程中资源访问、线程交互等并发问题。</p><h3 id="Golang并发原语："><a href="#Golang并发原语：" class="headerlink" title="Golang并发原语："></a>Golang并发原语：</h3><h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a><strong>Mutex</strong></h4><p>Mutex即Go中最基本的互斥锁（排他锁）实现，在并发编程中，我们常常需要保障一组内存空间（资源）在同一时间有且仅有一个对象在访问或操作，这一组内存空间（资源）一般被称为<strong>临界区</strong>。</p><p>使用互斥锁可以限制临界区内只能由一个线程访问。</p><h5 id="Mutex（Locker）接口包含方法"><a href="#Mutex（Locker）接口包含方法" class="headerlink" title="Mutex（Locker）接口包含方法"></a><strong>Mutex（Locker）接口包含方法</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock：进入临界区时调用</p><p>Unlock：退出临界区时调用</p><h5 id="Mutex使用方法"><a href="#Mutex使用方法" class="headerlink" title="Mutex使用方法"></a><strong>Mutex使用方法</strong></h5><p>Mutex可以直接在代码中进行调用，而无需初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;sync&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 互斥锁保护计数器</span></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="comment">// 计数器的值</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辅助变量，用来确认所有的goroutine都完成</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动10个gourontine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 累加10万次</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">                mu.Lock()</span><br><span class="line">                count++</span><br><span class="line">                mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多情况下，Mutex会与其他的struct同时出现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex <span class="comment">// 一般将Mutex放在需要控制的字段上面</span></span><br><span class="line">    Count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Counter)</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.mu.Unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f.count &lt; <span class="number">1000</span> &#123;</span><br><span class="line">        f.count += <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    f.count++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mutex内部实现"><a href="#Mutex内部实现" class="headerlink" title="Mutex内部实现"></a><strong>Mutex内部实现</strong></h5><p>虽然其他语言同样有关于Mutex的实现，这里我们只关注Go的Mutex实现。</p><p>Mutex的架构演进过程：</p><p>初版（完全依赖CAS） -&gt;  给新人机会（新的goroutine也能有机会竞争锁） -&gt; 多给些机会（新来的和被唤醒的有更多的机会竞争锁） -&gt; 解决饥饿问题（解决竞争问题，不会让goroutine长久等待）</p><h6 id="初版"><a href="#初版" class="headerlink" title="初版"></a><strong>初版</strong></h6><p>完全依赖于CAS（compare-and-swap）。这里简单描述下CAS指令的过程，CAS指令将<strong>给定的值</strong>和<strong>内存地址中的值</strong>进行比较，如果是同一个值，就使用新值替换内存中地址中的值，<strong>如果同时有其他线程已经修改了这个值，CAS返回失败，返回false</strong>，不难看出，CAS是一个原子（atomic）操作。</p><p>初版实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// CAS操作，当时还没有抽象出atomic包</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">cas</span><span class="params">(val *<span class="keyword">int32</span>, old, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="title">bool</span></span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">semacquire</span><span class="params">(*<span class="keyword">int32</span>)</span></span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">semrelease</span><span class="params">(*<span class="keyword">int32</span>)</span></span></span><br><span class="line"> <span class="comment">// 互斥锁的结构，包含两个字段</span></span><br><span class="line"> <span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">     key  <span class="keyword">int32</span> <span class="comment">// 锁是否被持有的标识</span></span><br><span class="line">     sema <span class="keyword">int32</span> <span class="comment">// 信号量专用，用以阻塞/唤醒goroutine</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 保证成功在val上增加delta的值</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">xadd</span><span class="params">(val *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">     <span class="keyword">for</span> &#123;</span><br><span class="line">         v := *val</span><br><span class="line">         <span class="keyword">if</span> cas(val, v, v+delta) &#123;</span><br><span class="line">             <span class="keyword">return</span> v + delta</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">panic</span>(<span class="string">&quot;unreached&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 请求锁</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">1</span>) == <span class="number">1</span> &#123; <span class="comment">//标识加1，如果等于1，成功获取到锁</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     semacquire(&amp;m.sema) <span class="comment">// 否则阻塞等待</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">-1</span>) == <span class="number">0</span> &#123; <span class="comment">// 将标识减去1，如果等于0，则没有其它等待者</span></span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     semrelease(&amp;m.sema) <span class="comment">// 唤醒其它阻塞的goroutine</span></span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure><p>Mutex结构体包含两个字段：</p><p><strong>字段 key</strong>：是一个 flag，用来标识这个排外锁是否被某个 goroutine 所持有，如果 key 大于等于 1，说明这个排外锁已经被持有；</p><p><strong>字段 sema</strong>：是个信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒。</p><p>调用 Lock 请求锁的时候，通过 xadd 方法进行 CAS 操作（第 25行），xadd 方法通过循环执行 CAS 操作直到成功，保证对 key 加 1 的操作成功完成。如果比较幸运，锁没有被别的 goroutine 持有，那么，Lock 方法成功地将 key 设置为 1，这个 goroutine 就持有了这个锁；如果锁已经被别的 goroutine 持有了，那么，当前的 goroutine 会把 key 加 1，而且还会调用 semacquire 方法（第 28 行），使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。</p><p>持有锁的 goroutine 调用 Unlock 释放锁时，它会将 key 减 1（第 32行）。如果当前没有其它等待这个锁的 goroutine，这个方法就返回了。但是，如果还有等待此锁的其它 goroutine，那么，它会调用 semrelease 方法（第 35 行），利用信号量唤醒等待锁的其它 goroutine 中的一个。</p><p>这里需要注意的一点是：</p><p><u><strong>Unlock 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，Unlock 也不会对此进行检查。Mutex 的这个设计一直保持至今。</strong></u></p><p>这种设计比较简单，但如果其他goroutine提前释放了自己的锁，在临界区的goroutine可能不知道自己的锁已经释放了，会带来data race问题。在使用Mutex要遵循<u><strong>谁申请，谁释放</strong></u>的原则。</p><h6 id="给新人机会"><a href="#给新人机会" class="headerlink" title="给新人机会"></a><strong>给新人机会</strong></h6><p>Mutex发展的第二阶段，对Mutex进行了一次大的调整：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">     state <span class="keyword">int32</span></span><br><span class="line">     sema  <span class="keyword">uint32</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">     mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">     mutexWoken</span><br><span class="line">     mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>这里Mutex的第一个字段从<code>key</code>改为了<code>state</code>。</p><p>state是一个复合字段，一个字段包含多个意义，这样可以通过尽可能少的内存来实现互斥锁。这个字段的第一位（最小的一位）来表示这个锁是否被持有，第二位代表是否有唤醒的 goroutine，剩余的位数代表的是等待此锁的 goroutine 数。所以，state 这一个字段被分成了三部分，代表三个数据：</p><p>mutexWaiters（阻塞等待的waiter数量） – mutexWorken（唤醒标记） – mutexLocked（持有锁的标记）</p><p>主要实现逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Fast path: 幸运case，能够直接获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        awoke := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            old := m.state</span><br><span class="line">            <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态加锁</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift <span class="comment">//等待者数量加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> awoke &#123;</span><br><span class="line">                <span class="comment">// goroutine是被唤醒的，</span></span><br><span class="line">                <span class="comment">// 新状态清除唤醒标志</span></span><br><span class="line">                <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;<span class="comment">//设置新状态</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">// 锁原状态未加锁</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                runtime.Semacquire(&amp;m.sema) <span class="comment">// 请求信号量</span></span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先是通过 CAS 检测 state 字段中的标志（第 3 行），如果没有 goroutine 持有锁，也没有等待持有锁的 goroutine，那么，当前的 goroutine 就很幸运，可以直接获得锁。如果state不是零值，那就存在一定的竞争关系，此时当前goroutine会进行休眠，当锁被释放后被唤醒。</p><p>但当被唤醒时，并不能直接获取到锁，此时需要与waiter进行竞争（for 循环是不断尝试获取锁，如果获取不到，就通过 runtime.Semacquire(&amp;m.sema) 休眠，休眠醒来之后 awoke 置为 true，尝试争抢锁。），<strong>这点是与初版设计不一样的地方，这会给后来请求锁的goroutine一些机会，也让 CPU 中正在执行的 goroutine 有更多的机会获取到锁，在一定程度上提高了程序的性能。</strong></p><p>代码中的第 10 行将当前的 flag 设置为加锁状态，如果能成功地通过 CAS 把这个新值赋予 state（第 19 行和第 20 行），就代表抢夺锁的操作成功了。</p><p>由于涉及到对单个值的位操作，释放锁的逻辑也会相对复杂：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">        <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked) <span class="comment">//去掉锁标志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">//本来就没有加锁</span></span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> &#123; <span class="comment">// 没有等待者，或者有唤醒的waiter，或者锁原来已加锁</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken <span class="comment">// 新状态，准备唤醒goroutine，并设置唤醒标志</span></span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime.Semrelease(&amp;m.sema)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第 3 行是尝试将持有锁的标识设置为未加锁的状态，这是通过减 1 而不是将标志位置零的方式实现。</p><p>第 4 到 6 行还会检测原来锁的状态是否已经未加锁的状态，如果是 Unlock 一个未加锁的 Mutex 会直接 panic。不过，即使将加锁置为未加锁的状态，这个方法也不能直接返回，还需要一些额外的操作，因为还可能有一些等待这个锁的 goroutine（有时候我也把它们称之为 waiter）需要通过信号量的方式唤醒它们中的一个。</p><p>所以接下来的逻辑有两种情况。</p><ul><li>第一种情况（无waiter竞争），如果没有其它的 waiter，说明对这个锁的竞争的 goroutine 只有一个，那就可以直接返回了；如果这个时候有唤醒的 goroutine，或者是又被别人加了锁，那么，无需我们操劳，其它 goroutine 自己干得都很好，当前的这个 goroutine 就可以放心返回了。</li><li>第二种情况（存在waiter），如果有等待者，并且没有唤醒的 waiter，那就需要唤醒一个等待的 waiter。在唤醒之前，需要将 waiter 数量减 1，并且将 mutexWoken 标志设置上，这样，Unlock 就可以返回了。</li></ul><h6 id="多给些机会"><a href="#多给些机会" class="headerlink" title="多给些机会"></a><strong>多给些机会</strong></h6><p>在这次的改动中，Golang工程师加入了<a href="https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/runtime/proc.go#L5580">自旋</a>（spin，通过循环不断尝试）的特性。</p><p>如果信赖的goroutine或者是被唤醒的 goroutine 首次获取不到锁，它们就会通过自旋的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Fast path: 幸运之路，正好获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        awoke := <span class="literal">false</span></span><br><span class="line">        iter := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123; <span class="comment">// 不管是新来的请求锁的goroutine, 还是被唤醒的goroutine，都不断尝试请求锁</span></span><br><span class="line">            old := m.state <span class="comment">// 先保存当前锁的状态</span></span><br><span class="line">            <span class="built_in">new</span> := old | mutexLocked <span class="comment">// 新状态设置加锁标志</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexLocked != <span class="number">0</span> &#123; <span class="comment">// 锁还没被释放</span></span><br><span class="line">                <span class="keyword">if</span> runtime_canSpin(iter) &#123; <span class="comment">// 还可以自旋</span></span><br><span class="line">                    <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                        awoke = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    runtime_doSpin()</span><br><span class="line">                    iter++</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">// 自旋，再次尝试请求锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">new</span> = old + <span class="number">1</span>&lt;&lt;mutexWaiterShift</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> awoke &#123; <span class="comment">// 唤醒状态</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="built_in">panic</span>(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> old&amp;mutexLocked == <span class="number">0</span> &#123; <span class="comment">// 旧状态锁已释放，新状态成功持有了锁，直接返回</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                runtime_Semacquire(&amp;m.sema) <span class="comment">// 阻塞等待</span></span><br><span class="line">                awoke = <span class="literal">true</span> <span class="comment">// 被唤醒</span></span><br><span class="line">                iter = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果可以 spin 的话，第 9 行的 for 循环会重新检查锁是否释放。对于临界区代码执行非常短的场景来说，这是一个非常好的优化。因为<strong>临界区的代码耗时很短，锁很快就能释放</strong>，而抢夺锁的 goroutine 不用通过休眠唤醒方式等待调度，直接 spin 几次，可能就获得了锁。</p><h6 id="解决饥饿问题"><a href="#解决饥饿问题" class="headerlink" title="解决饥饿问题"></a><strong>解决饥饿问题</strong></h6><p>在之前的几代Mutex优化中，考虑的主要是为“新来的goroutine”分配临界区的占有权，而在极端情况下，很可能出现<strong>等待中的goroutine一直获取不到锁的情况，出现饥饿问题</strong>。</p><p>最新的Mutex实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">     state <span class="keyword">int32</span></span><br><span class="line">     sema  <span class="keyword">uint32</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">     mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">     mutexWoken</span><br><span class="line">     mutexStarving <span class="comment">// 从state字段中分出一个饥饿标记</span></span><br><span class="line">     mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"> </span><br><span class="line">     starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// Fast path: 幸运之路，一下就获取到了锁</span></span><br><span class="line">     <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Slow path：缓慢之路，尝试自旋竞争或饥饿状态下饥饿goroutine竞争</span></span><br><span class="line">     m.lockSlow()</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">     starving := <span class="literal">false</span> <span class="comment">// 此goroutine的饥饿标记</span></span><br><span class="line">     awoke := <span class="literal">false</span> <span class="comment">// 唤醒标记</span></span><br><span class="line">     iter := <span class="number">0</span> <span class="comment">// 自旋次数</span></span><br><span class="line">     old := m.state <span class="comment">// 当前的锁的状态</span></span><br><span class="line">     <span class="keyword">for</span> &#123;</span><br><span class="line">         <span class="comment">// 锁是非饥饿状态，锁还没被释放，尝试自旋</span></span><br><span class="line">         <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">             <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                 awoke = <span class="literal">true</span></span><br><span class="line">             &#125;</span><br><span class="line">             runtime_doSpin()</span><br><span class="line">             iter++</span><br><span class="line">             old = m.state <span class="comment">// 再次获取锁的状态，之后会检查是否锁被释放了</span></span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">new</span> := old</span><br><span class="line">         <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">             <span class="built_in">new</span> |= mutexLocked <span class="comment">// 非饥饿状态，加锁</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">             <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift <span class="comment">// waiter数量加1</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">             <span class="built_in">new</span> |= mutexStarving <span class="comment">// 设置饥饿状态</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> awoke &#123;</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                 throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">new</span> &amp;^= mutexWoken <span class="comment">// 新状态清除唤醒标记</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 成功设置新状态</span></span><br><span class="line">         <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">             <span class="comment">// 原来锁的状态已释放，并且不是饥饿状态，正常请求到了锁，返回</span></span><br><span class="line">             <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                 <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 处理饥饿状态</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果以前就在队列里面，加入到队列头</span></span><br><span class="line">             queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">             <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                 waitStartTime = runtime_nanotime()</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 阻塞等待</span></span><br><span class="line">             runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">             <span class="comment">// 唤醒之后检查锁是否应该处于饥饿状态</span></span><br><span class="line">             starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">             old = m.state</span><br><span class="line">             <span class="comment">// 如果锁已经处于饥饿状态，直接抢到锁，返回</span></span><br><span class="line">             <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                     throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// 有点绕，加锁并且将waiter数减1</span></span><br><span class="line">                 delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                 <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                     delta -= mutexStarving <span class="comment">// 最后一个waiter或者已经不饥饿了，清除饥饿标记</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             &#125;</span><br><span class="line">             awoke = <span class="literal">true</span></span><br><span class="line">             iter = <span class="number">0</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             old = m.state</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">     <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">     <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">         m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">         throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">         old := <span class="built_in">new</span></span><br><span class="line">         <span class="keyword">for</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">             <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                 runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line">             &#125;</span><br><span class="line">             old = m.state</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>与之前的实现相比，当前的 Mutex 最重要的变化，就是增加饥饿模式。第 123行将饥饿模式的最大等待时间阈值设置成了 1 毫秒，这就意味着，一旦等待者等待的时间超过了这个阈值，Mutex 的处理就有可能进入饥饿模式。</p><h6 id="饥饿模式-vs-正常模式"><a href="#饥饿模式-vs-正常模式" class="headerlink" title="饥饿模式 vs 正常模式"></a><strong>饥饿模式 vs 正常模式</strong></h6><p>请求锁时调用的 Lock 方法中一开始是 fast path，这是一个幸运的场景，当前的 goroutine 幸运地获得了锁，没有竞争，直接返回，否则就进入了 lockSlow 方法。</p><p>在lockSlow方法下就会进行正常模式与饥饿模式的切换。</p><p>正常模式下，waiter 都是进入先入先出队列，被唤醒的 waiter 并不会直接持有锁，而是要和新来的 goroutine 进行竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</p><p>在饥饿模式下，Mutex 的拥有者将<strong>直接把锁交给队列最前面的 waiter</strong>。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin，它会乖乖地加入到等待队列的尾部。如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p><ul><li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li><li>此 waiter 的等待时间小于 1 毫秒。</li></ul><p>正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。</p><p>饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。</p><p>综上，则是Mutex整个发展过程，可以看出Mutex设计者的一个核心理念： 在<strong>Mutex的设计中，绝不容忍一个goroutine被落下，尽可能地让等待时间较长的goroutine更有机会获取到锁。</strong></p><h4 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a><strong>RWMutex</strong></h4><p>Mutex已经能够为我们保证临界区资源的并发安全，但相对得牺牲了并发性能，为此，我们需要引入“读写分离”的概念，把并发中的写和读单独抽出考虑。</p><h5 id="RWMutex接口包含方法"><a href="#RWMutex接口包含方法" class="headerlink" title="RWMutex接口包含方法"></a><strong>RWMutex接口包含方法</strong></h5><p><strong>Lock/Unlock</strong>：写操作时调用的方法。如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。</p><p><strong>RLock/RUnlock</strong>：读操作时调用的方法。如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。</p><p><strong>RLocker</strong>：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</p><h5 id="Mutex使用方法-1"><a href="#Mutex使用方法-1" class="headerlink" title="Mutex使用方法"></a><strong>Mutex使用方法</strong></h5><p>RWMutex和Mutex一样，零值是未加锁的状态，当使用时，可以嵌入到其他strcut中，不必显示初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter Counter</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; <span class="comment">// 10个reader</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                counter.Count() <span class="comment">// 计数器读操作</span></span><br><span class="line">                time.Sleep(time.Millisecond)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">// 一个writer</span></span><br><span class="line">        counter.Incr() <span class="comment">// 计数器写操作</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个线程安全的计数器</span></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex</span><br><span class="line">    count <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用写锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    c.count++</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用读锁保护</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span> <span class="title">Count</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    c.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RWMutex内部实现"><a href="#RWMutex内部实现" class="headerlink" title="RWMutex内部实现"></a><strong>RWMutex内部实现</strong></h5><p>Golang中RWMutex是基于Mutex实现的。</p><p>readers-writers 问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。</p><p><strong>Read-preferring：</strong>读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。</p><p><strong>Write-preferring：</strong>写优先的设计意味着，如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。</p><p><strong>不指定优先级：</strong>这种设计比较简单，不区分 reader 和 writer 优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。</p><p><strong>Go中的RWmutex采用Write-preferring。</strong></p><p>RWMutex结构包含一个Mutex，和四个辅助字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  w           Mutex   <span class="comment">// 互斥锁解决多个writer的竞争</span></span><br><span class="line">  writerSem   <span class="keyword">uint32</span>  <span class="comment">// writer信号量</span></span><br><span class="line">  readerSem   <span class="keyword">uint32</span>  <span class="comment">// reader信号量</span></span><br><span class="line">  readerCount <span class="keyword">int32</span>   <span class="comment">// reader的数量</span></span><br><span class="line">  readerWait  <span class="keyword">int32</span>   <span class="comment">// writer等待完成的reader的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>字段 w：</strong>Mutex锁，为 writer 的竞争锁而设计。</p><p><strong>字段 readerCount：</strong>记录当前 reader 的数量（以及是否有 writer 竞争锁）。</p><p><strong>readerWait：</strong>记录 writer 请求锁时需要等待 read 完成的 reader 的数量</p><p><em><strong>writerSem 和 readerSem：</strong></em>都是为了阻塞设计的信号量。</p><h6 id="RLock-RUnlock-的实现"><a href="#RLock-RUnlock-的实现" class="headerlink" title="RLock/RUnlock 的实现"></a><strong>RLock/RUnlock 的实现</strong></h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rw.rUnlockSlow(r) <span class="comment">// 有等待的writer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个reader了，writer终于有机会获得锁了</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>readerCount字段的双重含义：</strong></p><ul><li>没有 writer 竞争或持有锁时，readerCount 和我们正常理解的 reader 的计数是一样的。</li><li>如果有 writer 竞争锁或者持有锁时，那么，readerCount 不仅仅承担着 reader 的计数功能，还能够标识当前是否有 writer 竞争或持有锁，在这种情况下，请求锁的 reader 的处理进入第 4 行，阻塞等待锁的释放。</li></ul><p>在RUnlock时，需要先检查是否存在writer竞争锁（readerCount为负值），在这种情况下，还会调用方rUnlockSlow方法等待所有的reader锁释放。</p><p><strong>当 writer 请求锁的时候，是无法改变既有的 reader 持有锁的现实的，也不会强制这些 reader 释放锁，它的优先权只是限定后来的 reader 不要和它抢。</strong></p><h6 id="Lock-的实现"><a href="#Lock-的实现" class="headerlink" title="Lock 的实现"></a><strong>Lock 的实现</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (rw *RWMutex) Lock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先解决其他writer竞争问题</span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    &#x2F;&#x2F; 反转readerCount，告诉reader有writer竞争锁</span><br><span class="line">    r :&#x3D; atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    &#x2F;&#x2F; 如果当前有reader持有锁，那么需要等待</span><br><span class="line">    if r !&#x3D; 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) !&#x3D; 0 &#123;</span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, false, 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(&gt;=0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。</p><p>如果 readerCount 不是 0，就说明当前有持有读锁的 reader，RWMutex 需要把这个当前 readerCount 赋值给 readerWait 字段保存下来（第 7 行）， 同时，这个 writer 进入阻塞等待状态（第 8 行）。</p><p>每当一个 reader 释放读锁的时候（调用 RUnlock 方法时），readerWait 字段就减 1，直到所有的活跃的 reader 都释放了读锁，才会唤醒这个 writer。</p><h6 id="Unlock-的实现"><a href="#Unlock-的实现" class="headerlink" title="Unlock 的实现"></a><strong>Unlock 的实现</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func (rw *RWMutex) Unlock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 告诉reader没有活跃的writer了</span><br><span class="line">    r :&#x3D; atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 唤醒阻塞的reader们</span><br><span class="line">    for i :&#x3D; 0; i &lt; int(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, false, 0)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 释放内部的互斥锁</span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 writer 释放锁的时候，它会再次反转 readerCount 字段。</p><p>当writer 要释放锁了，需要唤醒之后新来的 reader，不必再阻塞它们了（第7行）</p><p>Mutex在这里需要保障修改字段的互斥关系（实现代码中省略），在 Lock 方法中，是先获取内部互斥锁，才会修改的其他字段；而在 Unlock 方法中，是先修改的其他字段，才会释放内部互斥锁，这样才能保证字段的修改也受到互斥锁的保护。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并发问题是在大型项目开发过程中不可绕过的问题，而Go以其对并发的性能优异而得名，那Golang对并发场景的优势以及对并发问题的解决原理是如何的呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Golang" scheme="http://example.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>openstack-helm离线部署</title>
    <link href="http://example.com/2022/04/19/openstack-helm%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2022/04/19/openstack-helm%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/</id>
    <published>2022-04-19T06:27:23.000Z</published>
    <updated>2022-05-18T08:32:43.958Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>节点名</th><th>角色</th></tr></thead><tbody><tr><td>knode1</td><td>融合节点</td></tr><tr><td>knode2</td><td>融合节点</td></tr><tr><td>knode3</td><td>融合节点</td></tr><tr><td>knode4</td><td>计算、存储节点</td></tr></tbody></table><blockquote><p>文章中引用的chart包是经过改造的，如需要，请联系笔者</p><p>Linux发行版为centos7，openstack版本为w版（nova组件为u版，u版以上无法完全适配centos7 3.10 kernel）</p></blockquote><h1 id="一-helm准备"><a href="#一-helm准备" class="headerlink" title="一.helm准备"></a>一.helm准备</h1><p>1.将helm二进制复制到<code>/usr/bin</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp binary&#x2F;helm &#x2F;usr&#x2F;bin&#x2F;helm</span><br><span class="line">chmod +x &#x2F;usr&#x2F;bin&#x2F;helm</span><br></pre></td></tr></table></figure><p>2.去除master节点的污点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes knode1 node-role.kubernetes.io&#x2F;master:NoSchedule-</span><br><span class="line">kubectl taint nodes knode2 node-role.kubernetes.io&#x2F;master:NoSchedule-</span><br><span class="line">kubectl taint nodes knode3 node-role.kubernetes.io&#x2F;master:NoSchedule-</span><br></pre></td></tr></table></figure><p>3.为节点添加label（3控制同时作为控制节点和计算节点，单独的node4作为单独计算节点，所有节点默认都是存储节点，控制节点作为进出口流量节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes knode1 ceph-control-plane&#x3D;enabled openstack-control-plane&#x3D;enabled  openvswitch&#x3D;enabled openstack-compute-node&#x3D;enabled ingress-node&#x3D;enabled</span><br><span class="line">kubectl label nodes knode2 ceph-control-plane&#x3D;enabled openstack-control-plane&#x3D;enabled  openvswitch&#x3D;enabled openstack-compute-node&#x3D;enabled ingress-node&#x3D;enabled</span><br><span class="line">kubectl label nodes knode3 ceph-control-plane&#x3D;enabled openstack-control-plane&#x3D;enabled  openvswitch&#x3D;enabled openstack-compute-node&#x3D;enabled ingress-node&#x3D;enabled</span><br><span class="line">kubectl label nodes knode4 openstack-compute-node&#x3D;enabled openvswitch&#x3D;enabled </span><br></pre></td></tr></table></figure><h1 id="二-安装rook-ceph"><a href="#二-安装rook-ceph" class="headerlink" title="二.安装rook-ceph"></a>二.安装rook-ceph</h1><p>1.安装rook-ceph-operator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm install --create-namespace --namespace rook-ceph rook-ceph .&#x2F;charts&#x2F;rook-ceph-0.0.1.tgz  --set image.tag&#x3D;v1.8.8</span><br><span class="line"># wait for operator start</span><br><span class="line">sleep 10</span><br></pre></td></tr></table></figure><p>2.创建ceph cluster、storageClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --create-namespace --namespace rook-ceph rook-ceph-cluster .&#x2F;charts&#x2F;rook-ceph-cluster-0.0.1.tgz --set cephClusterSpec.dashboard.enabled&#x3D;false</span><br></pre></td></tr></table></figure><blockquote><p>删除时，需要先执行<code>kubectl -n rook-ceph patch cephcluster rook-ceph --type merge -p &#39;&#123;&quot;spec&quot;:&#123;&quot;cleanupPolicy&quot;:&#123;&quot;confirmation&quot;:&quot;yes-really-destroy-data&quot;&#125;&#125;&#125;&#39;</code></p></blockquote><p>3.等待集群创建完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Ready -n rook-ceph cephcluster rook-ceph --timeout&#x3D;1800s</span><br><span class="line"> </span><br><span class="line"># 等待osd pod正常创建并启动</span><br><span class="line">sleep 180</span><br><span class="line"></span><br><span class="line">kubectl get pod -n rook-ceph # 确认所有pod都处于Running或Complete状态，确保4个osd成功创建（集群Ready后，OSD不一定完全启动），创建成功后才能进行下一步</span><br><span class="line"># 查看ceph集群状态,HEALTH_WARN或HEALTH_OK均可</span><br><span class="line">kubectl exec -it -n rook-ceph &#96;kubectl  get pod -n rook-ceph -owide|grep tools|awk &#39;&#123; print $1 &#125;&#39;&#96; -- ceph -s</span><br></pre></td></tr></table></figure><blockquote><p>1.ceph osd无法启动？</p><p>查看prepare osd job pod的日志，确认各节点有一块以上未使用的磁盘，operator轮询过程可能比较慢，可能需要等待5分钟以上才能创建出osd</p><p>2.新增节点osd未被添加？</p><p>rook operator会以周期频率检查新加入节点，如果长时间未被添加，手动重启rook operator pod，1分钟左右新节点会被加入</p></blockquote><h1 id="三-安装Registry、ChartMuseum"><a href="#三-安装Registry、ChartMuseum" class="headerlink" title="三.安装Registry、ChartMuseum"></a>三.安装Registry、ChartMuseum</h1><p>1.安装并配置docker-registry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm install docker-registry --create-namespace --namespace registry .&#x2F;charts&#x2F;docker-registry-2.1.0.tgz --set persistence.size&#x3D;60Gi</span><br><span class="line">kubectl get pod  -n registry |grep 1&#x2F;1 # 确认registry pod成功创建，成功后才能进行下一步</span><br></pre></td></tr></table></figure><p>2.设置私有仓库和设置dns地址（<strong>需要在所有节点执行</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># replace nameserver to kubedns, every nodes should do below</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;insecure-registries&quot; : [&quot;docker-registry.registry.svc.cluster.local&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">sleep 30</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Available -n registry deploy docker-registry --timeout&#x3D;120s</span><br></pre></td></tr></table></figure><blockquote><p>测试：</p><p>docker tag rook/ceph:v1.8.8 docker-registry.registry.svc.cluster.local/ceph:v1.8.8</p><p>docker push docker-registry.registry.svc.cluster.local/ceph:v1.8.8</p></blockquote><p>3.导入镜像到registry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 添加kubedns，所有节点都需要配置该nameserver，否则kubelet无法拉取镜像，node节点如果无法执行kubectl命令，则需要从master节点拷贝</span><br><span class="line">NAMESERVER&#x3D;&#96;kubectl get svc -n kube-system|awk &#39;&#123; print $3 &#125;&#39;|grep -v IP&#96;</span><br><span class="line">echo &quot;nameserver $NAMESERVER&quot; &gt; &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改Kubelet ImageGC配置，防止kubelet删除节点镜像</span><br><span class="line">echo &quot;imageGCHighThresholdPercent: 100&quot; &gt;&gt; &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml</span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">docker load -q &lt; images&#x2F;components&#x2F;all_components_images.tar.gz</span><br><span class="line">docker images | grep docker-registry.registry.svc.cluster.local | awk &#39;&#123;print &quot;docker push -q &quot;$1&quot;:&quot;$2&#125;&#39;|sh</span><br><span class="line"></span><br><span class="line"># 复原kubelet配置</span><br><span class="line">sed -i &#39;&#x2F;imageGCHighThresholdPercent&#x2F;d&#39;  &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml</span><br><span class="line">systemctl restart kubelet</span><br><span class="line">sleep 30</span><br></pre></td></tr></table></figure><p>4.安装并配置chartmuseum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm install chartmuseum --create-namespace --namespace registry .&#x2F;charts&#x2F;chartmuseum-3.7.0.tgz</span><br><span class="line">kubectl  wait --for&#x3D;condition&#x3D;Available -n registry deploy chartmuseum --timeout&#x3D;120s</span><br><span class="line">helm repo add chartmuseum http:&#x2F;&#x2F;chartmuseum.registry.svc.cluster.local:8080&#x2F;</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure><p>5.安装并配置openstackclient</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 在所有控制节点安装</span><br><span class="line">yum install -y python3</span><br><span class="line">mkdir -p &#x2F;tmp&#x2F;pip_packs&#x2F;</span><br><span class="line">tar -zxf .&#x2F;pip_packs&#x2F;openstackclient_pip_packs.tar.gz -C &#x2F;tmp&#x2F;pip_packs&#x2F;</span><br><span class="line">sudo -H -E pip3 install  --no-index --find-links&#x3D;&#x2F;tmp&#x2F;pip_packs&#x2F; cmd2 python-openstackclient python-heatclient --ignore-installed</span><br><span class="line"></span><br><span class="line">sudo -H mkdir -p &#x2F;etc&#x2F;openstack</span><br><span class="line">sudo -H chown -R $(id -un): &#x2F;etc&#x2F;openstack</span><br><span class="line">FEATURE_GATE&#x3D;&quot;tls&quot;; if [[ $&#123;FEATURE_GATES&#x2F;&#x2F;,&#x2F; &#125; &#x3D;~ (^|[[:space:]])$&#123;FEATURE_GATE&#125;($|[[:space:]]) ]]; then</span><br><span class="line">  tee &#x2F;etc&#x2F;openstack&#x2F;clouds.yaml &lt;&lt; EOF</span><br><span class="line">  clouds:</span><br><span class="line">    openstack_helm:</span><br><span class="line">      region_name: RegionOne</span><br><span class="line">      identity_api_version: 3</span><br><span class="line">      volume_api_version: 3</span><br><span class="line">      cacert: &#x2F;etc&#x2F;openstack-helm&#x2F;certs&#x2F;ca&#x2F;ca.pem</span><br><span class="line">      auth:</span><br><span class="line">        username: &#39;admin&#39;</span><br><span class="line">        password: &#39;password&#39;</span><br><span class="line">        project_name: &#39;admin&#39;</span><br><span class="line">        project_domain_name: &#39;default&#39;</span><br><span class="line">        user_domain_name: &#39;default&#39;</span><br><span class="line">        auth_url: &#39;https:&#x2F;&#x2F;keystone-api.openstack.svc.cluster.local:5000&#x2F;v3&#39;</span><br><span class="line">EOF</span><br><span class="line">else</span><br><span class="line">  tee &#x2F;etc&#x2F;openstack&#x2F;clouds.yaml &lt;&lt; EOF</span><br><span class="line">  clouds:</span><br><span class="line">    openstack_helm:</spa